untyped

globalize_all_functions

global const float FLOAT_INFINITY = 3.40282e+38 + 3.40282e+38
global const float FLOAT_INDETERMINATE = FLOAT_INFINITY * 0.0
global const float FLOAT_NAN = -FLOAT_INDETERMINATE

global const float DEG_TO_RAD = 0.01745329251994 
global const float RAD_TO_DEG = 57.29577951308232 

global const float DOT_1DEGREE =	0.9998476951564
global const float DOT_2DEGREE =	0.9993908270191
global const float DOT_3DEGREE =	0.9986295347546
global const float DOT_4DEGREE =	0.9975640502598
global const float DOT_5DEGREE =	0.9961946980917
global const float DOT_6DEGREE =	0.9945218953683
global const float DOT_7DEGREE =	0.9925461516413
global const float DOT_8DEGREE =	0.9902680687416
global const float DOT_9DEGREE =	0.9876883405951
global const float DOT_10DEGREE =	0.9848077530122
global const float DOT_15DEGREE =	0.9659258262891
global const float DOT_20DEGREE =	0.9396926207859
global const float DOT_25DEGREE =	0.9063077870367
global const float DOT_30DEGREE =	0.866025403784
global const float DOT_45DEGREE =	0.707106781187
global const float DOT_50DEGREE =	0.64278760968
global const float DOT_60DEGREE =	0.5
global const float DOT_80DEGREE =	0.17364817766
global const float DOT_85DEGREE =	0.0871557427477









global const string WHITESPACE_CHARACTERS = "\r\n\t " 

const string MTX_EVENT_1 = "MTX_Event_1"
const string MTX_EVENT_2 = "MTX_Event_2"

#if DEV
global const bool DEV_FORCE_LOAD_ALL_ENTITIES = false
#endif




global typedef FXHandle int


#if DEV
global enum eAssetType
{
	ASSETTYPE_CHARACTER,
	ASSETTYPE_WEAPON,
	ASSETTYPE_CHARM,

	_count
}
#endif


global const PST_TIME_ZONE_OFFSET = -8        
global const PDT_TIME_ZONE_OFFSET = -7
global enum eDaysOfWeek
{
	SUNDAY,
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY,
	SATURDAY,
	_NUM_DAYS
}
global const array<string> MONTH_NAMES = [
	"#MONTH_JAN",
	"#MONTH_FEB",
	"#MONTH_MAR",
	"#MONTH_APR",
	"#MONTH_MAY",
	"#MONTH_JUN",
	"#MONTH_JUL",
	"#MONTH_AUG",
	"#MONTH_SEP",
	"#MONTH_OCT",
	"#MONTH_NOV",
	"#MONTH_DEC",
]
global struct TimeParts
{
	int year
	int month
	int day
	int hour
	int minute
	int second
}
global struct DisplayTime
{
	int days
	int hours
	int minutes
	int seconds
}

global struct Coord
{
	vector pos
	vector ang
}

global struct AABB
{
	vector mins
	vector maxs
}

global struct PassByReferenceInt
{
	int value
}

global struct PassByReferenceFloat
{
	float value
}

global struct PassByReferenceBool
{
	bool value
}

global struct PassByReferenceVector
{
	vector value
}

global struct PassByReferenceEntity
{
	entity value
}

global struct PassByReferenceString
{
	string value
}

global enum eStreamMode
{
	DISABLED,
	KILLER,
	ALL,
}

global struct Timeout
{
	float startTime
	float duration
}

global struct ShuffleData
{
	array<int> _indices
	int        _pos
}

global struct DebounceData
{
	float              lastRunTime = 0.0
	bool               isQueued = false
	void functionref() latestFunc
}

const int THROTTLE_DEFAULT_MAXPERINTERVAL = 1
const float THROTTLE_DEFAULT_INTERVAL = 1.0
global struct ThrottleData
{
	float lastProcessTime = 0.0
	float decayingActionCount = 0
	float interval = THROTTLE_DEFAULT_INTERVAL
	int   maxPerInterval = THROTTLE_DEFAULT_MAXPERINTERVAL
}

global struct WaitQuotaItem
{
	int _count
	int _budget
}

global struct WallToTopResults
{
	bool found
	vector pos
	vector normal
	entity hitEnt
}

struct
{
	int  lastHostThreadMode
	int  lastScriptPrecacheErrors
	int  lastReportFatal
	bool devUnlockedSPMissions

	int hud_setting_accessibleChatCache

	float skyZPos = MAX_WORLD_COORD_BUFFER
} file

void function ShUtilityAll_Init()
{
	#document( "DistanceAlongVector", "" )
	#document( "GetClosestPointOnLineSegment", "Get the nearest point on a line segment" )
	#document( "GetDistanceFromLineSegment", "" )
	#document( "GetDistanceSqrFromLineSegment", "" )

	RegisterSignal( "Timeout" )
	RegisterSignal( "CancelTimeout" )



		
		PrecacheParticleSystem( $"P_wpn_ghurka_swipe_FP" )
		PrecacheParticleSystem( $"P_wpn_ghurka_swipe_3P" )
		PrecacheParticleSystem( $"P_ghurka_amb_plasma_FP" )
		PrecacheParticleSystem( $"P_ghurka_amb_plasma_3P" )
		PrecacheParticleSystem( $"P_ghurka_plasma_mdl" )
		PrecacheParticleSystem( $"P_ghurka_plasma_mdl_3P" )
		PrecacheParticleSystem( $"P_ghurka_exe_kick_impact" )
		PrecacheParticleSystem( $"P_wpn_ghurka_swipe_spin_3P" )
		PrecacheParticleSystem( $"p_wpn_ghurka_blade_Tip" )
		
		PrecacheParticleSystem( $"P_wpn_ghurka_rt01_swipe_FP" )
		PrecacheParticleSystem( $"P_wpn_ghurka_rt01_swipe_3P" )
		PrecacheParticleSystem( $"P_ghurka_rt01_amb_plasma_FP" )
		PrecacheParticleSystem( $"P_ghurka_rt01_amb_plasma_3P" )
		PrecacheParticleSystem( $"P_ghurka_rt01_plasma_mdl" )
		PrecacheParticleSystem( $"P_ghurka_rt01_plasma_mdl_3P" )
		PrecacheParticleSystem( $"P_wpn_ghurka_rt01_inspect_sharpening" )
		PrecacheParticleSystem( $"P_ghurka_rt01_airsprint" )
		PrecacheParticleSystem( $"P_wpn_ghurka_rt01_swipe_Drill_FP" )
		PrecacheParticleSystem( $"P_wpn_ghurka_rt01_swipe_spin_3P" )
		PrecacheParticleSystem( $"P_ghurka_rt01_exe_kick_impact" )
		PrecacheParticleSystem( $"p_wpn_ghurka_rt01_blade_Tip" )
		PrecacheParticleSystem( $"P_ghurka_rt01_impact" )
		PrecacheImpactEffectTable( "melee_gurkha_rt01")
		
		PrecacheParticleSystem( $"P_ash_HL_NC_Impact" )
		
		
		
		PrecacheParticleSystem( $"test_death_box_mdl" )
		PrecacheParticleSystem( $"P_death_box_artifact_mdl" )
		PrecacheParticleSystem( $"P_death_box_artifact_stech" )
		PrecacheParticleSystem( $"P_death_box_artifact_steampunk" )
		PrecacheParticleSystem( $"P_death_box_hisoc_artifact_mdl" )

		PrecacheParticleSystem( $"P_PODIUM_SPOTLIGHT" )

		
		PrecacheParticleSystem( $"P_bhaxe_rt01_swipe" )
		PrecacheParticleSystem( $"P_bhaxe_rt01_swipe_3P" )
		PrecacheParticleSystem( $"P_bhaxe_rt01_gas_glow_3P" )
		PrecacheParticleSystem( $"P_bhaxe_rt01_gas_glow" )
		PrecacheImpactEffectTable( "melee_bhaxe_rt01")


}


Timeout function BeginTimeout( float duration )
{
	Timeout to



	to.startTime = Time()

	to.duration = duration
	thread __RunTimeoutInternal( to )
	return to
}


void function __RunTimeoutInternal( Timeout to )
{
	EndSignal( to, "CancelTimeout" )
	wait to.duration
	Signal( to, "Timeout" )
}


void function CancelTimeoutIfAlive( Timeout to )
{
	Signal( to, "CancelTimeout" )
}





void function print_dev( ... )
{
#if DEV
		if ( vargc <= 0 )
			return

		local msg = vargv[0]
		if ( PREFIX_PRINTT )
			msg = "<" + getstackinfos( 2 ).func + "> " + msg

		for ( int i = 1; i < vargc; i++ )
			msg = (msg + " " + vargv[i] )

		printl( msg )
#endif
}

void function PrintObject( obj, int indent, int depth, int maxDepth )
{
	if ( IsTable( obj ) )
	{
		if ( depth >= maxDepth )
		{
			printl( "{...}" )
			return
		}

		printl( "{" )
		foreach ( k, v in obj )
		{
			print( TableIndent( indent + 2 ) + k + " = " )
			PrintObject( v, indent + 2, depth + 1, maxDepth )
		}
		printl( TableIndent( indent ) + "}" )
	}
	else if ( IsArray( obj ) )
	{
		if ( depth >= maxDepth )
		{
			printl( "[...]" )
			return
		}

		printl( "[" )
		foreach ( v in obj )
		{
			print( TableIndent( indent + 2 ) )
			PrintObject( v, indent + 2, depth + 1, maxDepth )
		}
		printl( TableIndent( indent ) + "]" )
	}
	else if ( obj != null )
	{
		printl( "" + obj )
	}
	else
	{
		printl( "<null>" )
	}
}


string function GetStack( int offset = 2 )
{
	string stackInfo = ""

	for ( int i = offset; i < 20; i++ )
	{
		if ( !("src" in getstackinfos( i )) )
			break

		if ( i != offset )
		{
			stackInfo += "\n"
		}

		stackInfo += getstackinfos( i )["src"] + " [" + getstackinfos( i )["line"] + "], " + getstackinfos( i )["func"] + "()"
	}

	return stackInfo
}

string function GetPreviousFunction()
{
	int i = 3
	if ( !("src" in getstackinfos( i )) )
		return ""
	return "Called from: " + getstackinfos( i )["src"] + " [" + getstackinfos( i )["line"] + "] : " + getstackinfos( i )["func"] + "() "
}


bool function IsNewThread()
{
	int i
	for ( i = 0 ; i < 20; i++ )
	{
		if ( !("src" in getstackinfos( i )) )
			break
	}

	return (i == 3)
}


bool function CallingFuncIsNewThread()
{
	int i
	for ( i = 0 ; i < 20; i++ )
	{
		if ( !("src" in getstackinfos( i )) )
			break
	}

	const int CHECK_DEPTH = 4
	return (i == CHECK_DEPTH)
}


void function AssertIsNewThread()
{
	Assert( CallingFuncIsNewThread(), "Must be threaded" )
}


void function AssertParameters( func, int paramCount, string paramDesc )
{
	table funcInfos = expect table( func.getinfos() )
	string funcName = expect string( funcInfos.name )
	
	Assert( funcInfos.parameters.len() == (paramCount + 1), "Function \"" + funcName + "\" must have exactly " + paramCount + " parameters (" + paramDesc + ")." )
}


string function GetNameForEnum( table<string, int> enumTable, int val )
{
	foreach ( string name, int index in enumTable )
	{
		if ( index == val )
			return name
	}
	return format( "%s() - INVALID: %d", FUNC_NAME(), val )
}


void function PrintTable( tbl, int indent = 0, int maxDepth = 4 )
{
	print( TableIndent( indent ) )
	PrintObject( tbl, indent, 0, maxDepth )
}


string function TableIndent( int indent )
{
	return ("                                            ").slice( 0, indent )
}


string function RepeatString( string str, int times )
{
	string out = ""
	for ( int i = 0; i < times; i++ )
	{
		out += str
	}
	return out
}


bool function IsOdd( int num )
{
	return (num % 2) == 1
}


bool function IsEven( int num )
{
	return !IsOdd( num )
}


float function DegToRad( float degrees )
{
	return degrees * DEG_TO_RAD
}


float function RadToDeg( float radians )
{
	return radians * RAD_TO_DEG
}


float function CalcFOVScale( float baseFOV, float zoomScale )
{
	return RadToDeg( atan( tan( DegToRad( baseFOV / 2.0 ) ) / zoomScale ) ) * 2
}

int function CalcZoomMag( float baseFOV, float fov )
{
	float magf = tan( DegToRad( baseFOV/2 ) ) / tan( DegToRad( fov/2 ) )
	return int ( floor( magf + 0.5) )
}


vector function RotateAroundOrigin2D( vector originToRotate, vector origin, float angRadians )
{
	vector rotated     = <0, 0, originToRotate.z>
	float sinOffsetAng = sin( angRadians )
	float cosOffsetAng = cos( angRadians )
	vector offset      = originToRotate - origin

	rotated.x = origin.x + (offset.x * cosOffsetAng) - (offset.y * sinOffsetAng)
	rotated.y = origin.y + (offset.x * sinOffsetAng) + (offset.y * cosOffsetAng)

	return rotated
}


vector function RotateVector( vector vec, vector rotateAngles )
{
	return vec.x * AnglesToForward( rotateAngles ) + vec.y * -1.0 * AnglesToRight( rotateAngles ) + vec.z * AnglesToUp( rotateAngles )

	
	
	
	
}


AABB function RotateAABB( vector mins, vector maxs, vector rotateAngles )
{
	vector cnr_000 = RotateVector( < mins.x, mins.y, mins.z >, rotateAngles )
	vector cnr_001 = RotateVector( < mins.x, mins.y, maxs.z >, rotateAngles )
	vector cnr_010 = RotateVector( < mins.x, maxs.y, mins.z >, rotateAngles )
	vector cnr_011 = RotateVector( < mins.x, maxs.y, maxs.z >, rotateAngles )
	vector cnr_100 = RotateVector( < maxs.x, mins.y, mins.z >, rotateAngles )
	vector cnr_101 = RotateVector( < maxs.x, mins.y, maxs.z >, rotateAngles )
	vector cnr_110 = RotateVector( < maxs.x, maxs.y, mins.z >, rotateAngles )
	vector cnr_111 = RotateVector( < maxs.x, maxs.y, maxs.z >, rotateAngles )

	AABB result
	result.mins = <
	min( cnr_000.x, min( cnr_001.x, min( cnr_010.x, min( cnr_011.x, min( cnr_100.x, min( cnr_101.x, min( cnr_110.x, cnr_111.x ) ) ) ) ) ) ),
	min( cnr_000.y, min( cnr_001.y, min( cnr_010.y, min( cnr_011.y, min( cnr_100.y, min( cnr_101.y, min( cnr_110.y, cnr_111.y ) ) ) ) ) ) ),
	min( cnr_000.z, min( cnr_001.z, min( cnr_010.z, min( cnr_011.z, min( cnr_100.z, min( cnr_101.z, min( cnr_110.z, cnr_111.z ) ) ) ) ) ) )
	>
	result.maxs = <
	max( cnr_000.x, max( cnr_001.x, max( cnr_010.x, max( cnr_011.x, max( cnr_100.x, max( cnr_101.x, max( cnr_110.x, cnr_111.x ) ) ) ) ) ) ),
	max( cnr_000.y, max( cnr_001.y, max( cnr_010.y, max( cnr_011.y, max( cnr_100.y, max( cnr_101.y, max( cnr_110.y, cnr_111.y ) ) ) ) ) ) ),
	max( cnr_000.z, max( cnr_001.z, max( cnr_010.z, max( cnr_011.z, max( cnr_100.z, max( cnr_101.z, max( cnr_110.z, cnr_111.z ) ) ) ) ) ) )
	>
	return result
}


float function RadWrap( float ang, float lowValue = -PI )
{
	return ((ang - lowValue) % (2.0 * PI)) + lowValue
}


vector function FindAnyPerpendicularVector( vector v )
{
	return RotateVector( <0, 0, 1> * Length( v ), VectorToAngles( Normalize( v ) ) )
}


float function GetArcLengthDeg( float startDeg, float endDeg )
{
	if ( endDeg < startDeg )
		endDeg += 360

	return fabs( startDeg - endDeg )
}

bool function CirclesAreIntersecting( vector org1, float rad1, vector org2, float rad2 )
{
	float distBetweenCircles = Distance( org1, org2 )
	float epsilon = 1

	
	if ( distBetweenCircles < fabs( rad1 - rad2 ) + epsilon )
		return false
	else if ( distBetweenCircles < fabs( rad2 - rad1 ) + epsilon )
		return false

	
	else if ( distBetweenCircles == 0 && rad2 == rad1 )
		return false

	
	else if ( distBetweenCircles > ( rad1 + rad2 + epsilon ) )
		return false

	return true
}

bool function IsCircleAEncompassingCircleB( vector org1, float rad1, vector org2, float rad2 )
{
	float epsilon
	float distBetweenCircles = Distance( org1, org2 )
	if ( ( distBetweenCircles < fabs( rad1 - rad2 ) + epsilon ) && ( rad1 > rad2 ) )
		return true

	return false
}

array<vector> function GetCircleToCircleIntersectionPoints( vector org1, float rad1, vector org2, float rad2, vector up = < 0, 0, 1 >, bool debugDraw = false )
{
	float distBetweenCircles        = Distance( org1, org2 )
	float distOrg1ToIntersectCenter = ( ( rad1 * rad1 ) - ( rad2 * rad2 ) + ( distBetweenCircles * distBetweenCircles ) ) / ( 2.0 * distBetweenCircles )

	vector intersectDir    = Normalize( org2 - org1 )
	vector intersectCenter = intersectDir * distOrg1ToIntersectCenter

	float intersectHeight = sqrt( ( rad1 * rad1 ) - ( distOrg1ToIntersectCenter * distOrg1ToIntersectCenter ) )
	vector heightDir      = CrossProduct( up, intersectDir )

	array<vector> intersectionPoints = [ intersectCenter + ( heightDir * intersectHeight ), intersectCenter - ( heightDir * intersectHeight ) ]

	if ( debugDraw )
	{

		
		DebugDrawLine( org1, org1 + < 0, 0, 32 >, COLOR_RED, true, 1.0 )
		DebugDrawLine( org2, org2 + < 0, 0, 32 >, COLOR_GREEN, true, 1.0 )

		
		DebugDrawLine( org2, intersectionPoints[ 0 ] + org1, COLOR_WHITE, true, 1.0 )
		DebugDrawLine( org2, intersectionPoints[ 1 ] + org1, COLOR_BLACK, true, 1.0 )

	}

	return intersectionPoints
}

bool function IsLobbyMapName( string levelname )
{
	if ( levelname == "mp_lobby" )
		return true

	return false
}

bool function IsStormPoint()
{
	string mapName



		mapName = GetMapName()

	return mapName == "mp_rr_tropic_island"
}

bool function Freelance_IsHubLevel()
{
#if 0



		string mapName = GetMapName()


	switch( mapName )
	{
		case "mp_rr_nobody":
			return true
	}
#endif
	return false
}


bool function IsBotPlaygroundMatch()
{
	return GetCurrentPlaylistName() == BOTPLAYGROUND
}




bool function Is2TeamPvPGame()

{
	return (MAX_TEAMS == 2)
}


bool function IsMultiTeamPvPGame()
{
	return (MAX_TEAMS > 2)
}


bool function IsFFAGame()
{
	return (MAX_TEAMS == MAX_PLAYERS)
}


bool function IsSingleTeamMode()
{
	return (1 == GetCurrentPlaylistVarInt( "max_teams", 2 ))
}


bool function IsMultiTeamMission()
{
	if ( IsSingleTeamMode() )
		return false
	if ( Freelance_IsHubLevel() )
		return false
	return true
}


bool function IsShotgunsAndSnipersMode()
{
	return GetCurrentPlaylistVarBool( "shotguns_and_snipers_mode", false )
}


bool function IsArmedAndDangerousEvolvedMode()
{
	return GetCurrentPlaylistName() == "armed_and_dangerous_evolved"
}


int function GetExpectedSquadSize( entity player = null )
{
	
	return int ( GetCurrentPlaylistVarFloat( "max_players", 60 ) / GetCurrentPlaylistVarFloat( "max_teams", 20 ) )
}


bool function IsDuoMode()
{
	return (GetCurrentPlaylistVarFloat( "max_players", 60 ) / GetCurrentPlaylistVarFloat( "max_teams", 20 ) == 2.0)
}


bool function IsLastPlaylistSolo( entity player )
{
	return GetPersistentLastGameTypeFlag( player, eGameType.SOLO )
}


bool function IsS03E03Mode()
{
	return GetCurrentPlaylistVarBool( "s03e03_mode", false )
}


bool function IsThirdPersonMode()
{
	return GetCurrentPlaylistVarBool( "thirdperson_mode", false )
}


bool function IsSpawnOnSquadMode()
{
	return GetCurrentPlaylistVarBool( "spawn_on_squad_mode", false )
}

bool function UseNightAnnouncer()
{
	return GetCurrentPlaylistVarBool( "UseNocAnnouncerAtNight", false )
}

bool function UseNightRingAnnouncer()
{
	return GetCurrentPlaylistVarBool( "UseNocRingAnnouncerAtNight", false )
}

bool function IsNightMap()
{
	string mapName



		mapName = GetMapName()


	switch ( mapName )
	{
		case "mp_rr_olympus_mu1_night":
		case "mp_rr_canyonlands_mu1_night":
		case "mp_rr_desertlands_night":
			return true
			break
		default:
			break
	}

	return false
}

bool function IsPVEMode()
{









#if MP_PVEMODE
			return true
#else
			return false
#endif

}


bool function IsNightMapMode()
{
	return GetCurrentPlaylistVarBool( "night_map_mode", false )
}


bool function IsAlwaysBeClosingMode()
{
	return GetCurrentPlaylistVarBool( "always_be_closing_mode", false )
}


bool function IsGoldRushMode()
{
	return GetCurrentPlaylistVarBool( "gold_rush_mode", false )
}


bool function IsDummieMode()
{
	return GetCurrentPlaylistVarBool( "dummie_mode", false )
}

bool function HasBoundaryWall()
{
	return GetCurrentPlaylistVarBool( "has_boundary_wall", false )
}
















bool function BigTDM_IsModeEnabled()
{
	return GetCurrentPlaylistVarBool( "freedm_big_tdm_active", false )
}


bool function UseLTMPodiumBanner()
{
	return ( GetCurrentPlaylistVarString( "gamemode_logo", "BATTLE_ROYALE" ) == "LTM" )
}




















bool function IsCurrentModeMixtape()
{
	return GameMode_IsActive( eGameModes.CONTROL ) || GameMode_IsActive( eGameModes.FREEDM )
}


bool function PrestigeBadgeIsAllowed()
{
	bool allowBadges    = GetCurrentPlaylistVarBool( "allow_prestige_badges", false )
	string playlistName = GetCurrentPlaylistName()
	string funcName     = FUNC_NAME()
















	printf( "%s(): playlist = %s - deferring to allow_prestige_badges = %s", funcName, playlistName, allowBadges ? "True" : "False" )
	return allowBadges
}

bool function IsSpectator( entity player )
{
	if ( !IsValid( player ) )
		return false

	return player.GetTeam() == TEAM_SPECTATOR
}


int function GetEnemyTeam( int team )
{
	if ( IsMultiTeamPvPGame() )
		return TEAM_UNASSIGNED

	if ( team == TEAM_SPECTATOR )
		return TEAM_UNASSIGNED

	Assert( team == TEAM_IMC || team == TEAM_MILITIA )

	return (TEAM_IMC + TEAM_MILITIA) - team
}


array<int> function GetAllEnemyTeams( int team )
{
	array<int> resultArray
	if ( Is2TeamPvPGame() || IsSingleTeamMode() )
	{
		resultArray.append( GetEnemyTeam( team ) )
		return resultArray
	}

	int maxTeams = GetCurrentPlaylistVarInt( "max_teams", MAX_TEAMS )
	Assert( team >= TEAM_MULTITEAM_FIRST )
	Assert( team <= TEAM_MULTITEAM_LAST )

	for ( int i = TEAM_MULTITEAM_FIRST; i < TEAM_MULTITEAM_FIRST + maxTeams; ++i )
	{
		if ( i == team )
			continue

		resultArray.append( i )
	}

	return resultArray
}


array<int> function GetAllTeams()
{
	array<int> resultArray

	int maxTeams = GetCurrentPlaylistVarInt( "max_teams", MAX_TEAMS )

	for ( int i = TEAM_MULTITEAM_FIRST; i < TEAM_MULTITEAM_FIRST + maxTeams; ++i )
	{
		resultArray.append( i )
	}

	return resultArray
}


bool function IsPositionWithinRadius( float radius, vector position1, vector position2 )
{
	float radiusToTestSqr = pow( radius, 2 )
	float positionDistSqr = Distance2DSqr( position1, position2 )

	if ( positionDistSqr < radiusToTestSqr )
		return true

	return false
}

int function GetDefaultNonSpectatorTeam()
{
	int resultTeam

	if ( Is2TeamPvPGame() )
		resultTeam = TEAM_IMC
	else
		resultTeam = TEAM_MULTITEAM_FIRST

	return resultTeam
}


string function GetMapDisplayNameAllCaps( string mapname )
{
	return "#" + mapname + "_ALLCAPS"
}


string function GetMapDisplayName( string mapname )
{
	return "#" + mapname
}


string function GetMapDisplayDesc( string mapname )
{
	return "#" + mapname + "_CLASSIC_DESC"
}


float function RoundToNearestInt( float value )
{
	return floor( value + 0.5 )
}


float function RoundToNearestMultiplier( float value, float multiplier )
{
	Assert( multiplier > 0 )
	bool neg = value < 0
	value = fabs( value )

	float remainder = value % multiplier

	value -= remainder

	if ( remainder >= (multiplier / 2) )
		value += multiplier

	return neg ? -value : value
}

bool function IsBitFlagSet( int bitMask, int flag )
{
	return ( bitMask & flag ) != 0
}

int function SetBitFlag( int bitMask, int flag )
{
	return bitMask | flag
}

int function ClearBitFlag( int bitMask, int flag )
{
	return bitMask & ~flag
}

int function HIWORD( int value )
{
	return (value >> 16) & 0xFFFF
}


int function LOWORD( int value )
{
	return value
}

bool function IsWeaponKeyFieldDefined( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )

	if ( val != null )
		return true

	return false
}

bool function IsWithinRadius( vector testLoc, vector center, float radius )
{
	float radiusToTestSqr = pow( radius, 2 )
	float positionDistSqr = Distance2DSqr( testLoc, center )

	return( positionDistSqr <= radiusToTestSqr )
}

string function GetWeaponInfoFileKeyField_GlobalString( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect string( val )
}

string function GetWeaponInfoFileKeyField_WithMods_GlobalString( string ref, array<string> mods, string variable )
{
	var val = GetWeaponInfoFileKeyField_WithMods_Global( ref, mods, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect string( val )
}

int function GetWeaponInfoFileKeyField_GlobalInt( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect int( val )
}

int function GetWeaponInfoFileKeyField_WithMods_GlobalInt( string ref, array<string> mods, string variable )
{
	var val = GetWeaponInfoFileKeyField_WithMods_Global( ref, mods, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect int( val )
}

float function GetWeaponInfoFileKeyField_WithMods_GlobalFloat( string ref, array<string> mods, string variable )
{
	var val = GetWeaponInfoFileKeyField_WithMods_Global( ref, mods, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect float( val )
}

int function GetWeaponInfoFileKeyField_GlobalInt_WithDefault( string ref, string variable, int defaultVal )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	return val != null ? expect int( val ) : defaultVal
}


float function GetWeaponInfoFileKeyField_GlobalFloat( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect float( val )
}


bool function GetWeaponInfoFileKeyField_GlobalBool( string ref, string variable )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	return expect bool( val )
}

vector function GetWeaponInfoFileKeyField_GlobalVectorFloat( string ref, string variable, string delimiter = WHITESPACE_CHARACTERS )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	expect string( val )
	array<string> arr = split( val, delimiter )
	Assert( arr.len() >= 3, "Vector value \"" + val + " has < 3 arguments" )
	return <float(arr[0]), float(arr[1]), float(arr[2])>
}

vector function GetWeaponInfoFileKeyField_GlobalVectorInt( string ref, string variable, string delimiter = WHITESPACE_CHARACTERS )
{
	var val = GetWeaponInfoFileKeyField_Global( ref, variable )
	Assert( val != null, "Weapon key \"" + variable + "\" does not exist in weapon \"" + ref + "\" !" )
	expect string( val )
	array<string> arr = split( val, delimiter )
	Assert( arr.len() >= 3, "Vector value \"" + val + " has < 3 arguments" )
	return <int(arr[0]), int(arr[1]), int(arr[2])>
}






































































void function WaitFrame()
{
	
	wait 0.0001
}


void function WaitFrames( int frames )
{
	int framesRemaining = frames
	while ( framesRemaining > 0 )
	{
		WaitFrame()
		framesRemaining--
	}
}












string function VectorToString( vector vec )
{
	return "< " + vec.x + "," + vec.y + "," + vec.z + " >"
}

string function VectorToColorString( vector color, float alpha )
{
	return color.x + " " + color.y + " " + color.z + " " + alpha
}

vector function FlattenNormalizeVec( vector v )
{
	return Normalize( <v.x, v.y, 0> )
}

bool function VectorWithinBounds( vector v, float maxValue )
{
	return (fabs( v.x ) < maxValue && fabs( v.y ) < maxValue && fabs( v.z ) < maxValue)
}



int function GetReportStyle()
{





		return GetCurrentPlaylistVarInt( "enable_report", 2 )

}


vector function GetClosestPointOnPlane( vector a, vector b, vector c, vector p, bool clampInside = false )
{
	vector n    = CrossProduct( b - a, c - a )
	float eqTop = DotProduct( p - a, n )
	float eqBot = DotProduct( n, n )

	
	if ( fabs( eqBot ) < 0.001 )
		return GetClosestPointOnLineSegment( a, b, p )

	float magnitude = eqTop / eqBot

	vector endPoint = p - (n * magnitude)

	if ( clampInside )
	{
		float testAB = DotProduct( CrossProduct( b - a, n ), p - a )
		float testBC = DotProduct( CrossProduct( c - b, n ), p - b )
		float testCA = DotProduct( CrossProduct( a - c, n ), p - c )

		
		if ( testAB * testBC < 0 || testBC * testCA < 0 )
		{
			vector lineAB = GetClosestPointOnLineSegment( a, b, p )
			vector lineBC = GetClosestPointOnLineSegment( b, c, p )
			vector lineCA = GetClosestPointOnLineSegment( c, a, p )

			vector closestVector = lineAB
			float closestDist    = DistanceSqr( p, lineAB )
			float dist           = DistanceSqr( p, lineBC )
			if ( dist < closestDist )
			{
				closestDist = dist
				closestVector = lineBC
			}
			dist = DistanceSqr( p, lineCA )
			if ( dist < closestDist )
			{
				closestDist = dist
				closestVector = lineCA
			}
			return closestVector
		}
		
	}

	return endPoint
}


float function DistanceAlongVector( vector origin, vector lineStart, vector lineForward )
{
	vector originDif = origin - lineStart
	return DotProduct( originDif, lineForward )
}


vector function GetClosestPointOnLineSegment( vector a, vector b, vector p )
{
	float distanceSqr = LengthSqr( a - b )

	if ( distanceSqr == 0.0 )
		return a

	float t = DotProduct( p - a, b - a ) / distanceSqr
	if ( t < 0.0 )
		return a
	else if ( t > 1.0 )
		return b

	return a + t * (b - a)
}


vector function GetClosestPointOnLine( vector a, vector b, vector p )
{
	float distanceSqr = LengthSqr( a - b )

	if ( distanceSqr == 0.0 )
		return a

	float t = DotProduct( p - a, b - a ) / distanceSqr

	return a + t * (b - a)
}


vector ornull function GetIntersectionOfLineAndPlane( vector a, vector b, vector planePoint, vector planeNormal )
{
	float sT = DotProduct( planeNormal, planePoint - a )
	float sB = DotProduct( planeNormal, b - a )

	if ( sB > -0.0000001 && sB < 0.0000001 )
		return null

	float s = sT / sB
	return a + (b - a) * s
}


float function GetDistanceFromLineSegment( vector a, vector b, vector p )
{
	vector closestPoint = GetClosestPointOnLineSegment( a, b, p )
	return Distance( p, closestPoint )
}


float function GetDistanceSqrFromLineSegment( vector a, vector b, vector p )
{
	vector closestPoint = GetClosestPointOnLineSegment( a, b, p )
	return DistanceSqr( p, closestPoint )
}


float function GetProgressAlongLineSegment( vector P, vector A, vector B )
{
	vector AP = P - A
	vector AB = B - A

	float ab2   = DotProduct( AB, AB ) 
	float ap_ab = DotProduct( AP, AB ) 
	float t     = ap_ab / ab2
	return t
}


string function PadString( string str, int len )
{
	for ( int i = str.len(); i < len; i++ )
		str += " "

	return str
}


bool function IsSpawner( entity ent )
{
	return (IsValid( ent ) && ent.GetNetworkedClassName() == "spawner")
}


string function GetAISettingsStringForMode()
{
	return "aiSettingsFile"
}




float function EaseIn( float val )
{
	return AttackDecay( 0, 2, val )
}


float function EaseOut( float val )
{
	return AttackDecay( 2, 0, val )
}


float function AttackDecay( float attack, float decay, float time )
{
	float sum = attack + decay
	float a   = sum - 2.0
	float b   = (3.0 - attack) - sum
	float c   = attack
	float t   = max( min( time, 1.0 ), 0.0 )

	return t * (c + t * (b + t * a))
}


float function Clamp( float value, float minValue, float maxValue )
{
	return max( min( value, maxValue ), minValue )
}


float function ClampFloor( float value, float floor )
{
	return max( value, floor )
}


float function ClampCeiling( float value, float ceiling )
{
	return min( value, ceiling )
}

int function ClampInt( int value, int minValue, int maxValue )
{
	return maxint( minint( value, maxValue ), minValue )
}


int function ClampFloorInt( int value, int floor )
{
	return maxint( value, floor )
}


int function ClampCeilingInt( int value, int ceiling )
{
	return minint( value, ceiling )
}


bool function IsValidArrayIndex( int index, int arrayLen )
{
	return (index >= 0) && (index < arrayLen)
}

void function RemoveDupesFromSorted_String( array<string> data )
{
	for ( int i = 0; i < data.len() - 1; i++ )
	{
		if ( data[i] == data[i + 1] )
		{
			data.remove( i )
			i--
		}
	}
}


function SortAlphabetize( a, b )
{
	if ( a > b )
		return 1

	if ( a < b )
		return -1

	return 0
}


int function SortStringAlphabetize( string a, string b )
{
	if ( a > b )
		return 1

	if ( a < b )
		return -1

	return 0
}


int function SortAssetAlphabetize( asset a, asset b )
{
	if ( a > b )
		return 1

	if ( a < b )
		return -1

	return 0
}


void function RemoveDupesFromSorted_Asset( array<asset> data )
{
	for ( int i = 0; i < data.len() - 1; i++ )
	{
		if ( data[i] == data[i + 1] )
		{
			data.remove( i )
			i--
		}
	}
}


void function DisablePrecacheErrors()
{
	file.lastHostThreadMode = GetConVarInt( "host_thread_mode" )
	file.lastScriptPrecacheErrors = GetConVarInt( "script_precache_errors" )
	file.lastReportFatal = GetConVarInt( "fs_report_sync_opens_fatal" )


		entity player = GetLocalClientPlayer()
		player.ClientCommand( "host_thread_mode 0" )
		player.ClientCommand( "script_precache_errors 0" )
		player.ClientCommand( "fs_report_sync_opens_fatal 0" )







}

void function RestorePrecacheErrors()
{

		entity player = GetLocalClientPlayer()
		player.ClientCommand( "host_thread_mode " + file.lastHostThreadMode )
		player.ClientCommand( "script_precache_errors " + file.lastScriptPrecacheErrors )
		player.ClientCommand( "fs_report_sync_opens_fatal " + file.lastReportFatal )







}




















string function GetTitanReadyHintFromSetFile( asset setFile )
{
	return GetGlobalSettingsString( setFile, "readyhint" )
}


bool function CoinFlip()
{
	return RandomInt( 2 ) != 0
}


ToolTipData function CreateSimpleToolTip( string titleText, string descText, string actionHint1 = "", string actionHint2 = "", string actionHint3 = "", string actionHint4 = "" )
{
	ToolTipData toolTipData
	toolTipData.titleText = titleText
	toolTipData.descText = descText
	toolTipData.actionHint1 = actionHint1
	toolTipData.actionHint2 = actionHint2
	toolTipData.actionHint3 = actionHint3
	toolTipData.actionHint4 = actionHint4

	return toolTipData
}




bool function PointInBounds( vector point, UIPos pos, UISize size )
{
	if ( point.x < pos.x )
		return false
	if ( point.y < pos.y )
		return false
	if ( point.x > pos.x + size.width )
		return false
	if ( point.y > pos.y + size.height )
		return false

	return true
}





UIPos function REPLACEHud_GetPos( var panel )
{
	var untypedPos = Hud_GetPos( panel )

	UIPos pos
	pos.x = expect int( untypedPos[0] )
	pos.y = expect int( untypedPos[1] )

	return pos
}


UIPos function REPLACEHud_GetAbsPos( var panel )
{
	var untypedPos = Hud_GetAbsPos( panel )

	UIPos pos
	pos.x = expect int( untypedPos[0] )
	pos.y = expect int( untypedPos[1] )

	return pos
}


UIPos function REPLACEHud_GetBasePos( var panel )
{
	var untypedPos = Hud_GetBasePos( panel )

	UIPos pos
	pos.x = expect int( untypedPos[0] )
	pos.y = expect int( untypedPos[1] )

	return pos
}


UISize function REPLACEHud_GetSize( var panel )
{
	var untypedSize = Hud_GetSize( panel )

	UISize size
	size.width = expect int( untypedSize[0] )
	size.height = expect int( untypedSize[1] )

	return size
}

UIPos function REPLACEHud_GetParentRelativePos( var panel )
{
	var untypedPos = Hud_GetParentRelativePos( panel )

	UIPos pos
	pos.x = expect int( untypedPos[0] )
	pos.y = expect int( untypedPos[1] )

	return pos
}

UISize function GetScreenSize()
{



		array screenSize = expect array( Hud.GetScreenSize() )

		UISize size
		size.width = expect int( screenSize[0] )
		size.height = expect int( screenSize[1] )

		return size

}

UIScaleFactor function GetContentScaleFactor( var panel )
{
	UISize size
	float heightBasis = 1080.0




		array screenSize = expect array( panel.GetScreenSize() )
		size.width = expect int( screenSize[0] )
		size.height = expect int( screenSize[1] )


	float aspectRatio = size.width / float( size.height )

	UIScaleFactor scaleFactor
	scaleFactor.x = size.width / (heightBasis * aspectRatio)
	scaleFactor.y = size.height / heightBasis

	return scaleFactor
}

UIScaleFactor function GetContentFixedScaleFactor( var panel )
{
	UISize size
	float vwidth  = 1920
	float vheight = 1080




		array screenSize = expect array( panel.GetScreenSize() )
		size.width = expect int( screenSize[0] )
		size.height = expect int ( screenSize[1] )


	float rx = size.width / vwidth
	float ry = size.height / vheight

	UIScaleFactor scaleFactor
	if ( rx < ry )
	{
		scaleFactor.x = rx
		scaleFactor.y = rx
	}
	else
	{
		scaleFactor.x = ry
		scaleFactor.y = ry
	}

	return scaleFactor
}

bool function ButtonIsBoundToAction( int buttonID, string actionSubString )
{
	string binding = GetEffectiveButtonBinding( buttonID )
	if ( binding.tolower().find_olduntyped( actionSubString.tolower() ) != null )
		return true

	return false
}

bool function ButtonIsBoundToHoldAction( int buttonID, string actionSubString )
{
	string binding = GetEffectiveButtonHoldBinding( buttonID )
	if ( binding.tolower().find_olduntyped( actionSubString.tolower() ) != null )
		return true

	return false
}

bool function ButtonIsBoundToPing( int buttonID )
{
	return ButtonIsBoundToAction( buttonID, "+ping" )
}
























string function BackslashToSlash( string originalString )
{
	array<string> tokens = split( originalString, "\\" )
	if ( tokens.len() == 0 )
		return ""

	string resultString = tokens[0]
	for ( int index = 1; index < tokens.len(); index++ )
	{
		resultString += "/"
		resultString += tokens[index]
	}

	return resultString
}


array<string> function GetTrimmedSplitString( string originalString, string splitChars )
{
	array<string> stringList = split( originalString, splitChars )
	for ( int i = 0 ; i < stringList.len() ; i++ )
		stringList[i] = strip( stringList[i] )
	return stringList
}


array<string> function GetTrimmedSplitLoweredString( string originalString, string splitChars )
{
	array<string> stringList = split( originalString, splitChars )
	for ( int i = 0 ; i < stringList.len() ; i++ )
		stringList[i] = strip( stringList[i] ).tolower()
	return stringList
}


int function SortByEntIndex( entity a, entity b )
{
	
	if ( a.GetEntIndex() > b.GetEntIndex() )
		return 1
	else if ( a.GetEntIndex() < b.GetEntIndex() )
		return -1

	return 0
}


int function SortByTeamMemberIndex( entity a, entity b )
{
	if ( a.GetTeamMemberIndex() > b.GetTeamMemberIndex() )
		return 1
	else if ( a.GetTeamMemberIndex() < b.GetTeamMemberIndex() )
		return -1

	return 0
}



bool function AllegianceCheck( int req, entity entA, entity entB )
{
	if ( req == eAllegiance.IRRELEVANT )
		return true
	if ( req == eAllegiance.FRIENDLY_ONLY )
		return IsFriendlyTeam( entA.GetTeam(), entB.GetTeam() )
	if ( req == eAllegiance.ENEMY_ONLY )
		return IsEnemyTeam( entA.GetTeam(), entB.GetTeam() )

	Assert( false, ("Unhandled allegience req #:" + req) )
	return false
}


vector function GetRandomCenterBiasedToEdge( vector center, float minDeviation, float maxDeviation, float minAngle = 0, float maxAngle = 360 )
{
	float deviation = RandomFloatRange( 0.0, 1.0 )
	deviation = minDeviation + (sqrt( deviation ) * (maxDeviation - minDeviation))
	vector angles    = <0, RandomFloatRange( minAngle, maxAngle ) % 360, 0>
	vector newCenter = center + (AnglesToForward( angles ) * deviation)
	return newCenter
}


vector function GetRandomCenter( vector center, float minDeviation, float maxDeviation, float minAngle = 0, float maxAngle = 360, var randomSeed = null )
{
	float deviation
	vector angles
	if ( IsValid ( randomSeed ) )
	{
		deviation = RandomFloatRangeSeeded( randomSeed, minDeviation, maxDeviation )
		angles = <0, RandomFloatRangeSeeded( randomSeed, minAngle, maxAngle ) % 360, 0>
	}
	else
	{
		deviation = RandomFloatRange( minDeviation, maxDeviation )
		angles = <0, RandomFloatRange( minAngle, maxAngle ) % 360, 0>
	}
	vector newCenter = center + (AnglesToForward( angles ) * deviation)
	return newCenter
}


vector function GetRandomCenterDistributed( vector center, float minDeviation, float maxDeviation, float minAngle = 0, float maxAngle = 360 )
{
	float deviation   = RandomFloatRange( minDeviation, maxDeviation )
	float angles      = RandomFloatRange( minAngle, maxAngle ) % 360
	float scale_ratio = 0
	if ( maxDeviation > 0 )	
		scale_ratio = maxDeviation / sqrt( maxDeviation )
	float r           = sqrt( deviation ) * scale_ratio
	return center + (< deg_cos( angles ) * r, deg_sin( angles ) * r, 0 >)
}

table<string, table<int, string> > reverseEnumLookupMap = {}
bool function BuildEnumReverseLookup( string enumName, bool assertOnDuplicates = true )
{
	table enumTableCopy = expect table(getconsttable()[enumName])

	table<int, string> reverseLookup = {}
	foreach ( string key, int value in enumTableCopy )
	{
		if ( value in reverseLookup )
		{
			Assert( !assertOnDuplicates, "Enum '" + enumName + "' has two keys with value '" + string(value) + "'" )
			return false
		}
		reverseLookup[value] <- key
	}
	reverseEnumLookupMap[enumName] <- reverseLookup
	return true
}


bool function IsValidEnumValue( string enumName, int value )
{
	if ( !(enumName in reverseEnumLookupMap) )
		BuildEnumReverseLookup( enumName )

	return (value in reverseEnumLookupMap[enumName])
}


string function GetEnumString( string enumName, int value )
{
	

	if ( !(enumName in reverseEnumLookupMap) )
		BuildEnumReverseLookup( enumName )

	return reverseEnumLookupMap[enumName][value]
}


string function DEV_GetEnumStringSafe( string enumName, int value )
{
	if ( IsValidEnumValue( enumName, value ) )
		return GetEnumString( enumName, value )

	return "<UNKNOWN ENUM VALUE FOR '" + enumName + "': " + value + ">"
}


string function GetEnumStringSlow( table enumTbl, int value )
{
	foreach ( entryKey, entryValue in enumTbl )
	{
		if ( entryValue == value )
			return expect string(entryKey)
	}

	return "<UNKNOWN ENUM VALUE: " + value + ">"
}


#if DEV
string function DEV_ArrayConcat( array<string> arr, string sep = "," )
{
	string out   = ""
	bool isFirst = true
	foreach ( string part in arr )
	{
		if ( isFirst )
			isFirst = false
		else
			out += sep

		out += part
	}
	return out
}
#endif


int function SortByInventoryIndexAndCount( ConsumableInventoryItem a, ConsumableInventoryItem b )
{
	if ( a.type < b.type )
		return -1
	if ( a.type > b.type )
		return 1

	if ( a.count > b.count )
		return -1
	if ( a.count < b.count )
		return 1

	return 0
}


vector function RandomVec( float range )
{
	
	vector vec = <0, 0, 0>
	vec.x = RandomFloatRange( -range, range )
	vec.y = RandomFloatRange( -range, range )
	vec.z = RandomFloatRange( -range, range )

	return vec
}


float function real_float_modulo( float x, float n )
{
	return ((x % n) + n) % n
}


int function real_int_modulo( int x, int n )
{
	return ((x % n) + n) % n
}


vector function OriginToGround( vector origin, int traceMask = TRACE_MASK_NPCWORLDSTATIC, entity tracingEnt = null )
{
	vector endOrigin         = <origin.x, origin.y, -MAX_WORLD_COORD_BUFFER >
	array <entity> ignoreArray = []
	if ( IsValid( tracingEnt ) )
		ignoreArray.append( tracingEnt )

	TraceResults traceResult = TraceLine( origin, endOrigin, ignoreArray, traceMask, TRACE_COLLISION_GROUP_NONE, tracingEnt )

	return traceResult.endPos
}

vector function GetGroundPositionOpenToSky( vector origin, bool excludePlayers = true )
{
	vector newOrigin = < origin.x, origin.y, file.skyZPos >

	vector endOrigin = < origin.x, origin.y, -MAX_WORLD_COORD_BUFFER >

	array< entity > excludeEnts
	if ( excludePlayers )
	{
		excludeEnts.extend( GetPlayerArray_Alive() )
	}

	
	TraceResults traceResult = TraceLine( newOrigin, endOrigin, excludeEnts, TRACE_MASK_SHOT, TRACE_COLLISION_GROUP_NONE )

	newOrigin = traceResult.endPos

	int maxTries = 4
	int tries = 0

	for ( tries = 0; tries < maxTries; tries++ ) 
	{
		if( traceResult.hitSky )
		{
			if( traceResult.endPos.z < 0 ) 
			{
				
				newOrigin = < origin.x, origin.y, origin.z >
				break
			}
			else
			{
				
				file.skyZPos = traceResult.endPos.z - 1000

				vector startPos = < origin.x, origin.y, file.skyZPos >

				traceResult = TraceLine( startPos, endOrigin, excludeEnts, TRACE_MASK_SHOT, TRACE_COLLISION_GROUP_NONE )

				newOrigin = traceResult.endPos
			}
		}
		else
		{
			break
		}
	}

	
	Assert( tries < maxTries, "Traces for Pings from map are hitting the skybox too many times, the skybox may be too large or misconfigured." )

	return newOrigin
}

WallToTopResults function TraceFromWallToTop(vector wallPos, vector wallNormal, array<entity> ignoreEnts, float checkBackDistance, float checkUpDistance, int traceMask, int collisionGroup, float DEBUG_DRAW_TIME = 0.0, bool doHullTrace = false, vector hullBoundsMin = ZERO_VECTOR, vector hullBoundsMax = ZERO_VECTOR )
{
	WallToTopResults results
	results.found = false

	vector flattenedNormal = FlattenNormalizeVec( wallNormal )
	
	
	vector traceUpStart = wallPos + (wallNormal * checkBackDistance )
	vector traceUpEnd = traceUpStart + (UP_VECTOR * checkUpDistance )

	TraceResults trUp
	if ( doHullTrace )
		trUp = TraceHull( traceUpStart, traceUpEnd, hullBoundsMin, hullBoundsMax, ignoreEnts, traceMask, collisionGroup)
	else
		trUp = TraceLine( traceUpStart, traceUpEnd, ignoreEnts, traceMask , collisionGroup )

#if DEV
		if ( DEBUG_DRAW_TIME > 0.0 )
		{
			DebugDrawArrow( traceUpStart, trUp.endPos, 10, COLOR_ORANGE, false, DEBUG_DRAW_TIME )
			DebugDrawText( trUp.endPos, string(checkUpDistance), false, DEBUG_DRAW_TIME )
			if( doHullTrace )
			{
				if ( !trUp.startSolid )
					DebugDrawBox( traceUpStart, hullBoundsMin, hullBoundsMax, COLOR_ORANGE, 1, DEBUG_DRAW_TIME )

				vector endColor = trUp.fraction < 1.0 ?  COLOR_LIGHT_RED : COLOR_LIGHT_GREEN
				DebugDrawBox( trUp.endPos, hullBoundsMin, hullBoundsMax, endColor, 1, DEBUG_DRAW_TIME )
			}
		}
#endif

	
	{

		
		
		vector traceBackStart = trUp.endPos
		vector traceBackEnd = traceBackStart - (flattenedNormal * checkBackDistance * 2 )
		TraceResults trBack
		if ( doHullTrace )
			trBack = TraceHull( traceBackStart, traceBackEnd, hullBoundsMin, hullBoundsMax, ignoreEnts, traceMask, collisionGroup)
		else
			trBack = TraceLine( traceBackStart, traceBackEnd, ignoreEnts, traceMask , collisionGroup )

#if DEV

			if ( DEBUG_DRAW_TIME > 0.0 )
			{
				DebugDrawArrow( traceBackStart, trBack.endPos, 10, COLOR_YELLOW, false, DEBUG_DRAW_TIME )
				if( doHullTrace )
				{
					if ( !trUp.startSolid )
						DebugDrawBox( traceBackStart, hullBoundsMin, hullBoundsMax, COLOR_ORANGE, 1, DEBUG_DRAW_TIME )

					vector endColor = trBack.fraction < 1.0 ?  COLOR_LIGHT_RED : COLOR_LIGHT_GREEN
					DebugDrawBox( trBack.endPos, hullBoundsMin, hullBoundsMax, endColor, 1, DEBUG_DRAW_TIME )
				}
			}
#endif

		if ( trBack.fraction > 0.5 )
		{
			vector ledgeStartTrace = trBack.endPos + (flattenedNormal * checkBackDistance*(1.5-trBack.fraction)/2.0)
			vector ledgeEndTrace = ledgeStartTrace - (UP_VECTOR * checkUpDistance * 1.25)

			TraceResults trDownToLedge
			if ( doHullTrace )
				trDownToLedge = TraceHull( ledgeStartTrace, ledgeEndTrace, hullBoundsMin, hullBoundsMax, ignoreEnts, traceMask, collisionGroup)
			else
				trDownToLedge = TraceLine( ledgeStartTrace, ledgeEndTrace, ignoreEnts, traceMask , collisionGroup )

			if ( trDownToLedge.fraction >= 1.0 )
			{
				ledgeStartTrace = trBack.endPos
				ledgeEndTrace = ledgeStartTrace - (UP_VECTOR * checkUpDistance * 1.25)
				if ( doHullTrace )
					trDownToLedge = TraceHull( ledgeStartTrace, ledgeEndTrace, hullBoundsMin, hullBoundsMax, ignoreEnts, traceMask, collisionGroup)
				else
					trDownToLedge = TraceLine( ledgeStartTrace, ledgeEndTrace, ignoreEnts, traceMask , collisionGroup )
			}


#if DEV

				if ( DEBUG_DRAW_TIME > 0.0 )
				{
					DebugDrawArrow( ledgeStartTrace, trDownToLedge.endPos, 10, COLOR_LIGHT_GREEN, false, DEBUG_DRAW_TIME )
					if( doHullTrace )
					{
						if ( !trUp.startSolid )
							DebugDrawBox( ledgeStartTrace, hullBoundsMin, hullBoundsMax, COLOR_ORANGE, 1, DEBUG_DRAW_TIME )

						vector endColor = trDownToLedge.fraction < 1.0 ?  COLOR_LIGHT_RED : COLOR_LIGHT_GREEN
						DebugDrawBox( trDownToLedge.endPos, hullBoundsMin, hullBoundsMax, endColor, 1, DEBUG_DRAW_TIME )
					}
				}
#endif

			if ( !trDownToLedge.startSolid && trDownToLedge.fraction < 1.0 && IsNormalVertical(trDownToLedge.surfaceNormal) )
			{
				
#if DEV
					if ( DEBUG_DRAW_TIME > 0.0 )
					{
						DebugDrawSphere( trDownToLedge.endPos, 2,COLOR_LIGHT_GREEN,false, DEBUG_DRAW_TIME )
						DebugDrawText( trDownToLedge.endPos + <0,0,10>,"CornerPos Found", false, DEBUG_DRAW_TIME )
						
					}
#endif

				results.found = true
				results.pos = trDownToLedge.endPos - (FLT_EPSILON*UP_VECTOR)
				results.normal = trDownToLedge.surfaceNormal
				results.hitEnt = trDownToLedge.hitEnt
			}
		}
	}

	return results
}



bool function IsNormalVertical( vector normal )
{
	float dot = DotProduct( normal, UP_VECTOR )
	if ( dot > DOT_45DEGREE )	
		return true

	return false
}




void function Shuffle_Init( ShuffleData sd, int count )
{
	Assert( count > 0 )
	sd._indices.resize( count )
	for ( int idx = 0; idx < count; ++idx )
		sd._indices[idx] = idx

	sd._pos = count
}


int function Shuffle_GetNextIndex( ShuffleData sd )
{
	Assert( sd._indices.len() > 0 )

	array<int> idxs = sd._indices
	int count       = idxs.len()
	if ( count == 1 )
		return idxs[0]

	++(sd._pos)
	if ( sd._pos >= count )
	{
		int lastIndexPlayed = ((sd._pos == count) ? idxs.top() : -1)
		idxs.randomize()
		if ( idxs[0] == lastIndexPlayed )
			idxs.reverse()    

		sd._pos = 0
	}

	return idxs[sd._pos]
}


int function Shuffle_GetCount( ShuffleData sd )
{
	return sd._indices.len()
}





vector function LocalPosToWorldPos( vector pos, entity ent )
{
	return ent.GetOrigin() + RotateVector( pos, ent.GetAngles() )
}
vector function LocalPosToWorldPos_NoEnt( vector pos, vector parentPos, vector parentAng )
{
	return parentPos + RotateVector( pos, parentAng )
}
vector function WorldPosToLocalPos( vector pos, entity ent )
{
	return RotateVector( pos - ent.GetOrigin(), AnglesInverse( ent.GetAngles() ) )
}
vector function WorldPosToLocalPos_NoEnt( vector pos, vector parentPos, vector parentAng )
{
	return RotateVector( pos - parentPos, AnglesInverse( parentAng ) )
}
vector function LocalDirToWorldDir( vector dir, entity ent )
{
	return RotateVector( dir, ent.GetAngles() )
}
vector function LocalDirToWorldDir_NoEnt( vector dir, vector parentAng )
{
	return RotateVector( dir, parentAng )
}
vector function WorldDirToLocalDir( vector dir, entity ent )
{
	return RotateVector( dir, AnglesInverse( ent.GetAngles() ) )
}
vector function WorldDirToLocalDir_NoEnt( vector dir, vector parentAng )
{
	return RotateVector( dir, AnglesInverse( parentAng ) )
}
vector function LocalAngToWorldAng( vector ang, entity ent )
{
	return AnglesCompose( ent.GetAngles(), ang )
}
vector function LocalAngToWorldAng_NoEnt( vector ang, vector parentAng )
{
	return AnglesCompose( parentAng, ang )
}
vector function WorldAngToLocalAng( vector ang, entity ent )
{
	return AnglesCompose( AnglesInverse( ent.GetAngles() ), ang )
}
vector function WorldAngToLocalAng_NoEnt( vector ang, vector parentAng )
{
	return AnglesCompose( AnglesInverse( parentAng ), ang )
}


void function WaitForever()
{




		clGlobal.levelEnt.WaitSignal( "forever" )



}

bool function IsLobbyEvent1Active()
{
#if DEV
		
		int devLobby = GetCurrentPlaylistVarInt( "dev_force_lobby", -1 )
		if ( devLobby != -1 )
			return ( devLobby == 1 )
#endif

	return IsMTXEventActive( MTX_EVENT_1 )
}

bool function IsLobbyEvent2Active()
{
#if DEV
		
		int devLobby = GetCurrentPlaylistVarInt( "dev_force_lobby", -1 )
		if ( devLobby != -1 )
			return ( devLobby == 2 )
#endif

	return IsMTXEventActive( MTX_EVENT_2 )
}

bool function IsMTXEventActive( string eventPlaylistVar )
{

		asset itemAsset = GetCurrentPlaylistVarAsset( eventPlaylistVar, $"" )
		if ( itemAsset == $"" )
			return false

		ItemFlavor event = GetItemFlavorByAsset( itemAsset )
		return CalEvent_IsActive( event, GetUnixTimestamp() )


	return false
}

bool function IsT1Active()
{
	int unixTimeNow = GetUnixTimestamp()
	if ( unixTimeNow > expect int( GetCurrentPlaylistVarTimestamp( "t1_active", UNIX_TIME_FALLBACK_2038 ) ) )
	{
		return true
	}

	return false
}


bool function IsMatchmakingFromMatchEnabled()
{
	return GetConVarBool( "matchmake_from_match_enabled" ) && GetCurrentPlaylistVarBool( "matchmake_from_match", false ) && ( GetCurrentPlaylistVarBool( "private_match", false ) == false )
}

bool function IsMatchmakingFromMatchAllowed( entity player )
{
	bool isAllowed = IsMatchmakingFromMatchEnabled()
	isAllowed = isAllowed && !Playlist_ShouldBeHiddenForScheduleBlocks( GetCurrentPlaylistName() )












	return isAllowed
}


































bool function IsVDUDialogueEnabled()
{
	return GetCurrentPlaylistVarBool( "enable_vdu_dialogue", false )
}

bool function IsEventFinale()
{
	return GetCurrentPlaylistVarBool( "is_event_finale", false )
}

bool function FiringRangeHasFriendlyFire()
{
	return GetCurrentPlaylistVarBool( "firingrange_has_friendlyfire", true )
}


bool function FiringRangeHasInfiniteClips()
{
	return GetCurrentPlaylistVarBool( "has_infinite_clips", false )
}

bool function FiringRangeHasHitIndictators()
{
	return GetCurrentPlaylistVarBool ( "hud_training_hit_dots", true )
}



bool function FiringRangeHasDynamicStats()
{
	return GetCurrentPlaylistVarBool ("has_fr_dynamic_stats", true )
}


bool function FreelanceSystemsAreEnabled()
{
	const bool ENABLED_BY_DEFAULT = false
	return GetCurrentPlaylistVarBool( "freelance_systems_enabled", ENABLED_BY_DEFAULT )
}

bool function SpectreShacksAreEnabled()
{
	return GetCurrentPlaylistVarBool( "spectre_shacks_enabled", false )
}










bool function NewPlayerBotQueueAreEnabled()
{
	return GetCurrentPlaylistVarBool( "is_bot_royale_match", false )
}

bool function IsBotModeMatch()
{
	return GetCurrentPlaylistVarBool( "is_bot_royale_match", false )
}



bool function AreMultipleHumansInTeam( int teamIndex )
{
	int numHumans         = 0
	array<entity> players = GetPlayerArrayOfTeam( teamIndex )
	foreach ( player in players )
	{
		if ( !player.IsBot() )
		{
			numHumans++
			if ( numHumans >= 2 )
				return true
		}
	}
	return false
}


float function LerpFloat( float startValue, float endValue, float time )
{
	return ((1 - time) * startValue + time * endValue)
}


bool function UpgradeCore_IsCorrectGameState()
{
	bool isGameStateCorrect =
			(
					( !GameModeVariant_IsActive( eGameModeVariants.SURVIVAL_FIRING_RANGE ) && ( GetGameState() == eGameState.Playing ) ) ||
					( GameModeVariant_IsActive( eGameModeVariants.SURVIVAL_FIRING_RANGE ) && ( GetGameState() == eGameState.WaitingForPlayers ))
			)

	return isGameStateCorrect
}


string function RandomHex( int length = 16 )
{
	string out = ""
	for ( int idx = 0; idx < length; idx++ )
	{
		int c = RandomInt( 16 )
		out += format( "%c", (c < 10 ? '0' : ('A' - 10)) + c )
	}
	return out
}


int function StringHash( string str )
{
	int res    = 0
	int length = str.len()
	for ( int i = 0; i < length; i++ )
	{
		res *= 31
		res += expect int( str[i] )
	}
	return res
}




int function SortByScriptId( var a, var b )
{
	int aId = int( Hud_GetScriptID( a ) )
	int bId = int( Hud_GetScriptID( b ) )
	if ( aId > bId )
		return 1
	else if ( bId > aId )
		return -1

	return 0
}



int function AlphabeticalPlayerSort( entity a, entity b )
{
	if ( a.GetPlayerName() > b.GetPlayerName() )
		return 1

	if ( a.GetPlayerName() < b.GetPlayerName() )
		return -1

	return 0
}


bool function IsNormalized( vector vec )

{
	return fabs( 1.0 - LengthSqr( vec ) ) < 0.01
}



void function UpdateAccessibilityChatHintEnabledCache()
{
	file.hud_setting_accessibleChatCache = GetConVarInt( "hud_setting_accessibleChat" )
}



bool function IsAccessibilityChatHintEnabled()
{

		return file.hud_setting_accessibleChatCache == 1 || file.hud_setting_accessibleChatCache == 3




}




bool function IsAccessibilityChatToSpeech()
{
	if ( !IsAccessibilityAvailable() )
		return false

	return GetConVarInt( "speechtotext_enabled" ) > 0
}



bool function IsAccessibilityAvailable()
{





	return true
}




int function GetStreamerMode()
{
	return GetConVarInt( "hud_setting_streamerMode" )
}




bool function DisplayKillerName()
{
	return GetStreamerMode() < eStreamMode.KILLER
}




bool function DisplayObituaryName()
{
	return GetStreamerMode() < eStreamMode.ALL
}



bool function DisplayHopupPopup()
{
	bool forceHidePopup = GetCurrentPlaylistVarBool( "hud_hide_hopuppopup", false )
	return !forceHidePopup && GetConVarBool( "hud_setting_showHopUpPopUp" )
}



bool function IsNetGraphEnabled()
{
	return GetConVarInt( "net_netGraph2" ) > 0
}



bool function IsAnonymousModeEnabled()
{
	return GetConVarInt( "hud_setting_anonymousMode" ) > 0
}



vector function GetKeyColor( int colorID, int optionalParam = 0 )
{
	Assert( optionalParam >= 0, "optionalParam must not be negative" )
	return ColorPalette_GetColorFromID( colorID + optionalParam )
}














void function Debounce( DebounceData data, float interval, void functionref() func )
{
	data.latestFunc = func

	if ( data.isQueued )
		return

	thread __DebounceInternalThread( data, interval )
}


void function __DebounceInternalThread( DebounceData data, float interval )
{
	OnThreadEnd( void function() : ( data ) {
		data.isQueued = false
		data.latestFunc = null
	} )

	data.isQueued = true





	wait max( 0.01, interval - (Time() - data.lastRunTime) )
	data.lastRunTime = Time()

	data.latestFunc()
}


ThrottleData function InitThrottle( float interval = THROTTLE_DEFAULT_INTERVAL, int maxPerInterval = THROTTLE_DEFAULT_MAXPERINTERVAL )
{
	ThrottleData data
	data.interval = interval
	data.maxPerInterval = maxPerInterval

	return data
}


bool function Throttle( ThrottleData data )
{




	float timeSinceLastAction = Time() - data.lastProcessTime
	data.lastProcessTime = Time()


	data.decayingActionCount = max( 0.0, data.decayingActionCount - timeSinceLastAction / (data.interval / data.maxPerInterval) )
	if ( data.decayingActionCount > data.interval )
		return true

	data.decayingActionCount += 1.0
	return false
}



const float GAMMA = 2.4
vector function LinearToSrgb( vector inputColor )
{
	inputColor.x = (inputColor.x < 0.0031308) ? (inputColor.x > 0.0 ? inputColor.x * 12.92 : inputColor.x) : 1.055 * pow( inputColor.x, 1.0 / GAMMA ) - 0.055
	inputColor.y = (inputColor.y < 0.0031308) ? (inputColor.y > 0.0 ? inputColor.y * 12.92 : inputColor.y) : 1.055 * pow( inputColor.y, 1.0 / GAMMA ) - 0.055
	inputColor.z = (inputColor.z < 0.0031308) ? (inputColor.z > 0.0 ? inputColor.z * 12.92 : inputColor.z) : 1.055 * pow( inputColor.z, 1.0 / GAMMA ) - 0.055

	return inputColor
}









int function ConvertStringToInt( string str )
{
	Assert( str.isnumeric() )
	return int( str )
}

const int DST_2024_START = 1710064800 
const int DST_2024_END = 1730628000 
const int DST_2025_START = 1741514400 
const int DST_2025_END = 1762077600 
const int DST_2026_START = 1772964000 
const int DST_2026_END = 1793527200 
const int DST_2027_START = 1805018400 
const int DST_2027_END = 1825581600 
const int DST_2028_START = 1836468000 
const int DST_2028_END = 1857031200 
const array< int > DST_TIMESTAMPS = [
	
	DST_2024_START,
	DST_2024_END,
	DST_2025_START,
	DST_2025_END,
	DST_2026_START,
	DST_2026_END,
	DST_2027_START,
	DST_2027_END,
	DST_2028_START,
	DST_2028_END,
]

int ornull function DateTimeStringToUnixTimestamp( string str )
{
	str = strip( str )

	
	if ( str.isnumeric() )
		return int( str )

	
	string datetimeStringPattern = "2020-12-28 10:00:00 -08:00"

	if ( str.len() != datetimeStringPattern.len() )
		return null

	TimeParts parts
	parts.year = ConvertStringToInt(str.slice(0, 4))
	parts.month = ConvertStringToInt(str.slice(5, 7))
	parts.day = ConvertStringToInt(str.slice(8, 10))
	parts.hour = ConvertStringToInt(str.slice(11, 13))
	parts.minute = ConvertStringToInt(str.slice(14, 16))
	parts.second = ConvertStringToInt(str.slice(17, 19))
	int timezoneOffsetHours = ( str.slice(20, 21) == "-" ? -1 : 1 ) * ConvertStringToInt( str.slice(21, 23) )





	
	int convertedUnixTime = GetUnixTimeFromParts( parts, timezoneOffsetHours ) 





	foreach ( int idx, int timestamp in DST_TIMESTAMPS )
	{
		if ( timestamp > convertedUnixTime )
		{
			if ( idx == 0 )
				break 







			if ( idx % 2 == 0 && timezoneOffsetHours != -8 ) 
			{
				Warning( format( "Updating DST offset for %s to -08:00", str ) )
				timezoneOffsetHours = -8
			}
			else if ( idx % 2 == 1 && timezoneOffsetHours != -7 ) 
			{
				Warning( format( "Updating DST offset for %s to -07:00", str ) )
				timezoneOffsetHours = -7
			}

			convertedUnixTime = GetUnixTimeFromParts( parts, timezoneOffsetHours )
			break
		}
		else if ( idx == DST_TIMESTAMPS.len() - 1 )
		{



		}
	}

	return convertedUnixTime
}


int function GetUnixTimePST()
{
	int unixTime = GetUnixTimestamp()
	unixTime += (PST_TIME_ZONE_OFFSET * SECONDS_PER_HOUR)
	return unixTime
}


int function GetUnixTimePDT()
{
	int unixTime = GetUnixTimestamp()
	unixTime += (PDT_TIME_ZONE_OFFSET * SECONDS_PER_HOUR)
	return unixTime
}


string function GetDebugTimeString()
{
	

	if ( GetDeveloperLevel() == 0 )
		return ""

	bool dst 		  = GetIsDSTActive()
	int utTime        = dst ? GetUnixTimePDT() : GetUnixTimePST()
	string timeString = GetDateTimeString( utTime, 0 )
	string dayName    = GetDayOfWeekName( GetDayOfWeek( utTime ) )




	string localDayName = Localize( dayName )


	return format( "%s, %s %s", localDayName, timeString, dst ? "PDT" : "PST" )
}


void function PrintDebugTimeDetails()
{
	printt( FUNC_NAME() )

	string debugTime = GetDebugTimeString()
	printt( "DebugTime =", debugTime )
	PrintFakeTime()
}


TimeParts function GetUnixTimeParts( int unixtime, int timezoneOffsetHours = -7 )
{
	unixtime += SECONDS_PER_HOUR * timezoneOffsetHours

	
	TimeParts parts

	

	parts.second = unixtime % 60
	unixtime /= 60

	parts.minute = unixtime % 60
	unixtime /= 60

	parts.hour = unixtime % 24
	unixtime /= 24

	

	unixtime += 719499

	
	

	for ( parts.year = 1969 ; unixtime > __YearToDays( parts.year + 1 ) + 30; parts.year++ )
	{
	}

	
	unixtime -= __YearToDays( parts.year )

	

	
	for ( parts.month = 1 ; parts.month < 12 && unixtime > 367 * (parts.month + 1) / 12; parts.month++ )
	{
	}

	
	unixtime -= 367 * parts.month / 12

	

	
	parts.month += 2
	if ( parts.month > 12 )
	{
		parts.month -= 12
		parts.year++
	}

	parts.day = unixtime

	return parts
}


int function GetUnixTimeFromParts( TimeParts parts, int timezoneOffsetHours )
{
	int y                     = parts.year - (parts.month <= 2 ? 1 : 0)
	int era                   = (y >= 0 ? y : y - 399) / 400
	int yoe                   = y - era * 400 
	int doy                   = (153 * (parts.month + (parts.month > 2 ? -3 : 9)) + 2) / 5 + parts.day - 1 
	int doe                   = yoe * 365 + yoe / 4 - yoe / 100 + doy 
	int days_since_1970_01_01 = era * 146097 + doe - 719468

	return (SECONDS_PER_DAY * days_since_1970_01_01
	+ SECONDS_PER_HOUR * (parts.hour - timezoneOffsetHours)
	+ SECONDS_PER_MINUTE * parts.minute
	+ parts.second)
}


int function __YearToDays( int y )
{
	return (y) * 365 + (y) / 4 - (y) / 100 + (y) / 400
}


DisplayTime function SecondsToDHMS( int seconds )
{
	DisplayTime dt

	
	dt.days = int( floor( seconds / SECONDS_PER_DAY ) )

	
	int hourSeconds = seconds % SECONDS_PER_DAY
	dt.hours = int( floor( hourSeconds / SECONDS_PER_HOUR ) )

	
	int minuteSeconds = hourSeconds % SECONDS_PER_HOUR
	dt.minutes = int( floor( minuteSeconds / SECONDS_PER_MINUTE ) )

	
	int remainingSeconds = minuteSeconds % SECONDS_PER_MINUTE
	dt.seconds = int( ceil( remainingSeconds ) )

	return dt
}


string function GetDaysHoursRemainingLoc(int days, int hours)
{
	string dateFormat = "#DAYS_HOURS_REMAINING"

	if ( hours == 1 )
	{
		dateFormat = "#DAYS_HOUR_REMAINING"
	}
	if ( days == 1 )
	{
		if ( hours == 1 )
		{
			dateFormat = "#DAY_HOUR_REMAINING"
		}
		else
		{
			dateFormat = "#DAY_HOURS_REMAINING"
		}
	}

	return dateFormat
}


string function GetDaysHoursMinutesSecondsString( int seconds )
{
	
	DisplayTime dt = SecondsToDHMS( seconds )
	return format( "%i:%02i:%02i.%02i", dt.days, dt.hours, dt.minutes, dt.seconds )
}


int function GetDayOfWeek( int unixTime )
{
	return int( (floor( unixTime / SECONDS_PER_DAY ) + 4) % 7 )
}


string function GetDayOfWeekName( int dayOfWeek )
{
	array<string> days = ["#SUNDAY", "#MONDAY", "#TUESDAY", "#WEDNESDAY", "#THURSDAY", "#FRIDAY", "#SATURDAY"]
	Assert( dayOfWeek >= 0 && dayOfWeek < days.len() )
	return days[dayOfWeek]
}


string function GetDateTimeString( int unixTime, int timezoneOffsetHours = -7 )
{
	TimeParts timeParts = GetUnixTimeParts( unixTime, timezoneOffsetHours )
	return format( "%04i-%02i-%02i %02i:%02i:%02i", timeParts.year, timeParts.month, timeParts.day, timeParts.hour, timeParts.minute, timeParts.second )
}


string function GetDateTimeStringNoYearNoSeconds( int unixTime, int timezoneOffsetHours = 0 )
{
	TimeParts timeParts = GetUnixTimeParts( unixTime, timezoneOffsetHours )
	return format( "%02i/%02i %02i:%02i", timeParts.month, timeParts.day, timeParts.hour, timeParts.minute )
}


string function GetTimeString( int unixTime )
{
	TimeParts timeParts = GetUnixTimeParts( unixTime )
	return format( "%02i:%02i:%02i", timeParts.hour, timeParts.minute, timeParts.second )
}


string function GetDateTimeStringDayMonthYear( int unixTime, int timezoneOffsetHours = 0 )
{
	TimeParts timeParts = GetUnixTimeParts( unixTime, timezoneOffsetHours )
	return format( "%02i-%02i-%04i",  timeParts.day, timeParts.month, timeParts.year )
}


int function GetStartOfDay( int unixTime )
{
	TimeParts timeParts    = GetUnixTimeParts( unixTime )
	int unixTimeStartOfDay = unixTime
	unixTimeStartOfDay = unixTimeStartOfDay - (timeParts.hour * SECONDS_PER_HOUR) - (timeParts.minute * SECONDS_PER_MINUTE) - timeParts.second
	return unixTimeStartOfDay
}


int function GetEndOfDay( int unixTime )
{
	return GetStartOfDay( unixTime + SECONDS_PER_DAY )
}


int function SecondsRemainingInDay( int unixTime )
{
	int endOfDay = GetEndOfDay( unixTime )
	return endOfDay - unixTime
}


void function WaitForUnixTime( int unixTime )
{
	while ( true )
	{
		float delay = float(unixTime - GetUnixTimestamp())
		if ( delay <= 0.0 )
			break

#if DEV
			wait min( 1.0, delay )
#else
			wait delay
#endif
	}
}



bool function CanSendFriendRequest( entity player )
{
	if ( !GetCurrentPlaylistVarBool( "enable_squad_friend_invite", true ) )
		return false

	return true
}

bool function CanInviteSquadMate( string uid )
{
	if ( !GetCurrentPlaylistVarBool( "enable_squad_invite", true ) )
		return false

	if ( IsInMyParty( uid ) )
		return false

	if ( GetParty().numFreeSlots == 0 )
		return false

	return true
}

bool function IsInMyParty( string uid )
{
	Party party = GetParty()
	foreach ( p in party.members )
	{
		if ( p.uid == uid )
			return true
	}
	return false
}

bool function IsMyPartyMatchmaking()
{
	bool isMyPartyMatchmaking = false
	if ( AmIPartyLeader() )
		isMyPartyMatchmaking = AreWeMatchmaking()
	else
		isMyPartyMatchmaking = ( GetMyMatchmakingStatus() != "" )

	return isMyPartyMatchmaking
}




WaitQuotaItem function WaitFrameQuota_Init( int maxPerFrame )
{
	WaitQuotaItem wq
	wq._count = 0
	wq._budget = maxPerFrame
	return wq
}


void function WaitFrameQuota_Reset( WaitQuotaItem wq )
{
	wq._count = 0
}


void function WaitFrameQuota( WaitQuotaItem wq )
{
	wq._count += 1
	if ( wq._count < wq._budget )
		return
	wq._count = 0
	WaitFrame()
}


entity function AssertLocalOrServerValidPlayer( entity player )
{



		if ( player == null )
			player = GetLocalClientPlayer()
		Assert( player == GetLocalClientPlayer() )


	return player
}


bool function IsEverythingUnlocked()
{
#if DEV
		if ( GetCurrentPlaylistVarBool( "dev_force_everything_unlocked", false ) )
			return true
#endif

	return EverythingUnlockedConVarEnabled() 
}


string function StripRuiStringFormatting( string text )
{
	string newText = text
	while ( newText.find( "`" ) != -1 )
	{
		int idx = newText.find( "`" )

		if ( newText.len() < 2 )
			return ""

		string a = ""

		if ( idx > 0 )
		{
			a = newText.slice( 0, idx )
		}

		string b = ""

		if ( idx + 2 < newText.len() )
		{
			b = newText.slice( idx + 2, newText.len() )
		}

		newText = a + b
	}

	return newText
}









var function GetRandomWeighted( ... )
{
	Assert( vargc % 2 == 0, "Must pass pairs to GetRandomWeighted!" )
	float total = 0.0
	for ( int argIdx = 0; argIdx < vargc; argIdx += 2 )
		total += expect float(vargv[argIdx + 0])

	float choice = RandomFloat( total )
	total = 0.0
	for ( int argIdx = 0; argIdx < vargc; argIdx += 2 )
	{
		total += expect float(vargv[argIdx + 0])
		if ( choice < total )
			return vargv[argIdx + 1]
	}

	Assert( false )
	return null
}



FXHandle function StartWorldFXWithHandle( asset fxAsset, vector pos, vector ang )
{
	int fxAssetId = GetParticleSystemIndex( fxAsset )



		return StartParticleEffectInWorldWithHandle( fxAssetId, pos, ang )

}




FXHandle function StartEntityFXWithHandle( entity ent, asset fxAsset, int attachType, int attachData )
{
	int fxAssetId = GetParticleSystemIndex( fxAsset )



		return StartParticleEffectOnEntity( ent, fxAssetId, attachType, attachData )

}




FXHandle function CleanupFXHandle( FXHandle fxHandle, bool doRemoveAllParticlesNow = true, bool doPlayEndCap = false )
{




















		if ( EffectDoesExist( fxHandle ) )
			EffectStop( fxHandle, doRemoveAllParticlesNow, doPlayEndCap )

		return -1

}




void function CleanupFXArray( array<FXHandle> fxHandleArray, bool doRemoveAllParticlesNow, bool doPlayEndCap )
{
	string stopType
	if ( doRemoveAllParticlesNow )
	{
		Assert( !doPlayEndCap )
		stopType = "destroyImmediately"
	}
	else if ( doPlayEndCap )
		stopType = "playEndcap"
	else
		stopType = "normal"

	foreach ( FXHandle fxHandle in fxHandleArray )
	{








			if ( EffectDoesExist( fxHandle ) )
				EffectStop( fxHandle, doRemoveAllParticlesNow, doPlayEndCap )

	}
	fxHandleArray.clear()
}




array<entity> function GetEntArrayByScriptNameSequence( string fmtStr, int firstIdx = 0 )
{
	array<entity> out = []
	int idx           = firstIdx
	while ( true )
	{
		array<entity> ents = GetEntArrayByScriptName( format( fmtStr, idx ) )
		if ( ents.len() == 0 )
			break
		else if ( ents.len() == 1 )
			out.append( ents[0] )
		else
			Warning( "GetEntArrayByScriptNameSequence found more than one ent with script name \"%s\".", format( fmtStr, idx ) )
	}
	return out
}



void function WaitSignals( var obj, array<string> signals )
{
	Assert( signals.len() > 0 )
	waitthread __WaitSignalsInternal( obj, signals )
}


void function __WaitSignalsInternal( var obj, array<string> signals )
{
	foreach ( string signal in signals )
		EndSignal( obj, signal )
	WaitForever()
}


void function WaitEndSignal( var obj, string signal )
{
	waitthread __WaitEndSignalInternal( obj, signal )
}


void function __WaitEndSignalInternal( var obj, string signal )
{
	EndSignal( obj, signal )
	WaitForever()
}



int function GetSkinIndexByName_Safe( entity ent, string skinName )
{
	if ( ent.GetSkinCount() == 0 )
	{
		
		Warning( "GetSkinIndexByName_Safe called on ent with bad model. Callstack:\n%s", GetStack() )
		return -1
	}
	return ent.GetSkinIndexByName( skinName )
}




void function SetSkinByName_Safe( entity ent, string skinName )
{
	if ( ent.GetSkinCount() == 0 )
	{
		
		Warning( "SetSkinByName_Safe called on ent with bad model. Callstack:\n%s", GetStack() )
		return
	}
	int skinIdx = ent.GetSkinIndexByName( skinName )
	if ( skinIdx == -1 )
	{
		Warning( "SetSkinByName_Safe called with bad skin name (\"%s\"). Callstack:\n%s", skinName, GetStack() )
		return
	}
	ent.SetSkin( skinIdx )
}




bool function CanScriptPlaceableBePlacedOn( entity hitEnt )
{
	

	if ( hitEnt.IsWorld() )
		return true

	var hitEntClassname = hitEnt.GetNetworkedClassName()

	if ( hitEntClassname == "func_brush" || hitEntClassname == "script_mover" )
		return true

	return false
}




bool function ShouldScriptedPlaceableParentTo( entity hitEnt )
{
	var hitEntClassname = hitEnt.GetNetworkedClassName()

	if ( hitEntClassname == "func_brush" || hitEntClassname == "script_mover" )
		return true

	return false
}




vector function RoundVectorInLocalSpace( vector vec, float interval, vector parentPos, vector parentAng )
{
	vec = WorldPosToLocalPos_NoEnt( vec, parentPos, parentAng )
	vec = RotateVector( vec, AnglesInverse( parentAng ) )
	vec = <floor( vec.x / interval ) * interval, floor( vec.y / interval ) * interval, floor( vec.z / interval ) * interval >
	vec = RotateVector( vec, parentAng )
	vec = LocalPosToWorldPos_NoEnt( vec, parentPos, parentAng )
	return vec
}

bool function VectorInWorldBounds( vector vec )
{
	return fabs( vec.x ) <= MAX_WORLD_COORD_BUFFER && fabs( vec.y ) <= MAX_WORLD_COORD_BUFFER && fabs( vec.z ) <= MAX_WORLD_COORD_BUFFER
}


#if DEV
void function DEV_LifetimeDebugTool( entity thing )
{
	while ( true )
	{
		bool isValid          = IsValid( thing )
		bool isValidThisFrame = IsValid_ThisFrame( thing )
		printf( "[DEV_LifetimeDebugTool] %s, IsValid() = %s, IsValid_ThisFrame() = %s", string( thing ), string(isValid), string(isValidThisFrame) )

		if ( !isValid && !isValidThisFrame )
			break

		wait 1.0
	}
}
#endif














































vector function DirFBLRUD_ToDir( DirFBLRUD dir )
{
	switch ( dir )
	{
		case DIR_FBLRUD_FORWARD:
			return <1, 0, 0>

		case DIR_FBLRUD_BACK:
			return <-1, 0, 0>

		case DIR_FBLRUD_LEFT:
			return <0, 1, 0>

		case DIR_FBLRUD_RIGHT:
			return <0, -1, 0>

		case DIR_FBLRUD_UP:
			return <0, 0, 1>

		case DIR_FBLRUD_DOWN:
			return <0, 0, -1>
	}
	Assert( false, "Bad direction: " + dir )
	return <0, 0, 0>
}




float function DirFBLRUD_ForwardLength( DirFBLRUD dir, vector vec )
{
	switch ( dir )
	{
		case DIR_FBLRUD_FORWARD:
			return vec.x

		case DIR_FBLRUD_BACK:
			return -1.0 * vec.x

		case DIR_FBLRUD_LEFT:
			return vec.y

		case DIR_FBLRUD_RIGHT:
			return -1.0 * vec.y

		case DIR_FBLRUD_UP:
			return vec.z

		case DIR_FBLRUD_DOWN:
			return -1.0 * vec.z
	}
	Assert( false, "Bad direction: " + dir )
	return 0.0
}




void functionref( bool success ) MenuExtendedUse_callback = null
void function StartMenuExtendedUse( var focusElem, var holdToUseElem, float duration, bool requireControllerFocus, bool isAltAction, void functionref( bool success ) callback,
string loopSound = "survival_titan_linking_loop", string successSound = "ui_menu_store_purchase_success" )
{
	
	if ( MenuExtendedUse_callback != null )
		return

	MenuExtendedUse_callback = callback




		RunUIScript( "_ClientToUI_MenuExtendedUseBegin", focusElem, holdToUseElem, duration, loopSound, successSound, requireControllerFocus, isAltAction )

}










void function _UIToClient_MenuExtendedUseEnded( bool success )
{
	Assert( MenuExtendedUse_callback != null )
	MenuExtendedUse_callback( success )
	MenuExtendedUse_callback = null
}


























































































bool function IsInfiniteAmmoEnabled()
{
#if DEV
		if ( GetConVarBool( "sv_infinite_ammo" ) )
			return true
#endif
	return false
}




void function DestroyEntities( array<entity> ents )
{
	foreach ( entity ent in ents )
		if ( IsValid( ent ) )
			ent.Destroy()
}


void function SetConVarFloatFromPlaylist( string varName, float floatVal )
{
	SetConVarFloat( varName, GetCurrentPlaylistVarFloat( varName, floatVal ) )
}

string function GetMergedPlatformIdForPlayer( entity player )
{

	Assert( player == GetLocalClientPlayer() )


	string platformId = ""

	platformId = HARDWARE_TO_MERGED_PLATFORM[GetHardwareFromName( player.GetHardwareName() )]



	Assert( platformId != "" )
	return platformId
}


bool function IsPCPlatform( int hardwareID )
{
	if ( hardwareID == HARDWARE_PC || hardwareID == HARDWARE_PC_STEAM )
	{
		return true
	}

	return false
}



bool function IsUserOnSamePlatform( string hardware )
{




		entity player = GetLocalClientPlayer()
		return IsValid( player ) ? hardware == player.GetHardwareName() : false

}

bool function IsUserOnSamePlatformID( int hardwareID )
{

















		entity player = GetLocalClientPlayer()
		if( !IsValid( player ) )
		{
			return false
		}
		int localPlayerHardwareID = GetHardwareFromName( player.GetHardwareName() )
		if( ( hardwareID == HARDWARE_PS4 || hardwareID == HARDWARE_PS5 ) && (localPlayerHardwareID == HARDWARE_PS4 || localPlayerHardwareID == HARDWARE_PS5) )
		{
			return true
		}
		else if( ( hardwareID == HARDWARE_XBOXONE || hardwareID == HARDWARE_XB5 ) && (localPlayerHardwareID == HARDWARE_XBOXONE || localPlayerHardwareID == HARDWARE_XB5) )
		{
			return true
		}
		else
		{
			return IsValid( player ) ? hardwareID == GetHardwareFromName( player.GetHardwareName() ) : false
		}
		return false

}

bool function CrossplayUserOptIn()
{
	return IsUserOptedInToCrossPlay() && CrossplayEnabled()
}


bool function CrossplayEnabled()
{
	return GetConVarInt( "crossPlay_enabled" ) != 0
}

string function PlatformIDToIconString( int platformID )
{
	if ( IsUserOnSamePlatformID( platformID ) )
	{
		switch ( platformID )
		{
			case HARDWARE_PC:
			case HARDWARE_PC_STEAM:
				return Localize( "#CROSSPLAY_ICON_PC" )

			case HARDWARE_PS4:
			case HARDWARE_PS5:
				return Localize( "#CROSSPLAY_ICON_PS4" )

			case HARDWARE_XBOXONE:
			case HARDWARE_XB5:
				return Localize( "#CROSSPLAY_ICON_XBOX" )

			case HARDWARE_SWITCH:
				return Localize( "#CROSSPLAY_ICON_NX" )

			default:
				return ""
		}
	}
	else
	{
		switch ( platformID )
		{
			case HARDWARE_PC:
			case HARDWARE_PC_STEAM:
				return Localize( "#CROSSPLAY_ICON_PC" )

			case HARDWARE_PS4:
			case HARDWARE_XBOXONE:
			case HARDWARE_SWITCH:
			case HARDWARE_XB5:
			case HARDWARE_PS5:
				return Localize( "#CROSSPLAY_ICON_CONTROLLER" )

			default:
				return ""
		}
	}

	Assert( false, "Unhandled platformID " + platformID )
	unreachable
}


















const float ROG_MIN_VERT_DISTRIB 		= 1024.0 * 4.0 
const float ROG_MAX_VERT_DISTRIB 		= 1024.0 * 6.0
const float ROG_MIN_HORIZ_DISTRIBUTION			= 1024 * 12.0
const float ROG_DEFAULT_GRID_HALF_SIZE			= 64000.0
const int ROG_MAX_SPAWN_POOL_BEFORE_REDUCTION	= 100
const float ROG_MAX_SPAWN_TO_POOL_SATURATION	= 0.5




array<entity> function RandomOrientedGridDistribution(
			array<entity> possibleLocationEnts,						
			int numDesiredSpawns,									
			float defaultGridHalfSize = ROG_DEFAULT_GRID_HALF_SIZE,		
			float minDesiredVertSpacingParam = ROG_MIN_VERT_DISTRIB,					
			float maxDesiredVertSpacingParam = ROG_MAX_VERT_DISTRIB,					
			float minDesiredHorizSpacing = ROG_MIN_HORIZ_DISTRIBUTION,					
			int maxNumSpawnsBeforeReduction = ROG_MAX_SPAWN_POOL_BEFORE_REDUCTION,		
			float maxSpawnSaturationBeforeRandomPick = ROG_MAX_SPAWN_TO_POOL_SATURATION 	
		)
{
	
	int numSpawnPoints       	= possibleLocationEnts.len()
	int numSpawnsToReturn = numDesiredSpawns

	if ( (numSpawnPoints == 0) || (numSpawnsToReturn == 0) )
	{
		array<entity> empty
		return empty
	}

	float desiredToLocationRatio = float( numSpawnsToReturn / numSpawnPoints )
	if ( desiredToLocationRatio > maxSpawnSaturationBeforeRandomPick )
	{
		if ( numSpawnsToReturn > numSpawnPoints )
			numSpawnsToReturn = numSpawnPoints

		printt( "!!! WARNING !!! Ratio of desired tick spawns to available locations too high to be worth it! Randomizing and returning results!", desiredToLocationRatio )
		possibleLocationEnts.randomize()
		return possibleLocationEnts.slice( 0, numSpawnsToReturn )
	}

	vector verticalAxis   = Normalize( < RandomFloatRange( -1, 1 ), RandomFloatRange( -1, 1 ), 0 > )
	vector horizAxis      = CrossProduct( verticalAxis, < 0, 0, 1 > )
	vector vertAxisOrigin = verticalAxis * -defaultGridHalfSize

	bool verbosePrint = GetCurrentPlaylistVarInt( "debug_loot_ticks", 0 ) == 1

	
	
	
	
	array<table> selectedSpawnPositions
	float closestSpawnOriginToVertAxisOrigin  = defaultGridHalfSize
	float furthestSpawnOriginToVertAxisOrigin = 0
	float minWidth                            = defaultGridHalfSize
	float maxWidth                            = -defaultGridHalfSize
	bool shouldDiscardSomeCandidates          = numSpawnPoints > maxNumSpawnsBeforeReduction 
	int numSelectedSpawnEnts
	foreach( spawnEnt in possibleLocationEnts )
	{
		if ( !IsValid( spawnEnt ) )
			continue

		
		if ( shouldDiscardSomeCandidates && CoinFlip() )
			continue

		numSelectedSpawnEnts++

		vector vertAxisOriginToEnt      = spawnEnt.GetOrigin() - vertAxisOrigin
		float distToVertAxisOrigin      = DotProduct2D( vertAxisOriginToEnt, verticalAxis )
		float horizDistToVertAxisOrigin = DotProduct2D( vertAxisOriginToEnt, horizAxis )
		selectedSpawnPositions.append( { ent = spawnEnt, vertDist = distToVertAxisOrigin, horizDist = horizDistToVertAxisOrigin } )

		
		if ( distToVertAxisOrigin > furthestSpawnOriginToVertAxisOrigin )
			furthestSpawnOriginToVertAxisOrigin = distToVertAxisOrigin
		else if ( distToVertAxisOrigin < closestSpawnOriginToVertAxisOrigin )
			closestSpawnOriginToVertAxisOrigin = distToVertAxisOrigin

		
		if ( horizDistToVertAxisOrigin > maxWidth )
			maxWidth = horizDistToVertAxisOrigin
		else if( horizDistToVertAxisOrigin < minWidth )
			minWidth = horizDistToVertAxisOrigin
	}

	selectedSpawnPositions.sort( SortSpawnPositionsByVertDist )

	if ( numSelectedSpawnEnts < numSpawnsToReturn )
		numSpawnsToReturn = numSelectedSpawnEnts

	
	
	
	
	
	
	
	
	Assert( maxDesiredVertSpacingParam > minDesiredVertSpacingParam, "Max loottick distribution distance is smaller than min distribution! Fix it!" )

	float vertAxisSpawnRange     = furthestSpawnOriginToVertAxisOrigin - closestSpawnOriginToVertAxisOrigin
	float maxDesiredSpawnSpacing = ( vertAxisSpawnRange * 0.9 ) / numSpawnsToReturn		
	float minDesiredSpawnSpacing = minDesiredVertSpacingParam
	if ( maxDesiredSpawnSpacing > maxDesiredVertSpacingParam )
		maxDesiredSpawnSpacing = maxDesiredVertSpacingParam

	if ( maxDesiredSpawnSpacing < minDesiredVertSpacingParam )
		minDesiredSpawnSpacing = maxDesiredSpawnSpacing - 1

	float verticalDistanceTraveled = closestSpawnOriginToVertAxisOrigin			
	int numVertSplits              = 0
	int lastSafetyCheckedSpawnEnt  = 0
	array<float> generatedVertSplits	
	while( true )
	{
		float newVerticalDistanceTraveled = RandomFloatRange( minDesiredSpawnSpacing, maxDesiredSpawnSpacing )
		verticalDistanceTraveled += newVerticalDistanceTraveled

		if ( verticalDistanceTraveled > furthestSpawnOriginToVertAxisOrigin )
			break

		
		int numSpawnEntsBetweenLastAndCurrentSelection
		for( int i = lastSafetyCheckedSpawnEnt; i < numSelectedSpawnEnts; i++ )
		{
			float curVertDist = expect float( selectedSpawnPositions[ i ].vertDist )
			if ( curVertDist > verticalDistanceTraveled )
				break

			numSpawnEntsBetweenLastAndCurrentSelection = i - lastSafetyCheckedSpawnEnt
		}

		
		if ( numSpawnEntsBetweenLastAndCurrentSelection == 0 )
		{
			float vertDistMidpointToNext = FLT_MAX
			float nextSpawnEntVertDist   = expect float( selectedSpawnPositions[ lastSafetyCheckedSpawnEnt + 1 ].vertDist ) 
			if ( ( lastSafetyCheckedSpawnEnt + 2 ) < numSelectedSpawnEnts )
			{
				float spawnEntAfterNext_vertDist = expect float( selectedSpawnPositions[ lastSafetyCheckedSpawnEnt + 2 ].vertDist )
				vertDistMidpointToNext = ( spawnEntAfterNext_vertDist - nextSpawnEntVertDist ) * 0.5
			}

			float safetyBuffer 			= min( 128, vertDistMidpointToNext )
			lastSafetyCheckedSpawnEnt 	+= 1
			verticalDistanceTraveled 	= nextSpawnEntVertDist + safetyBuffer
		}
		else
			lastSafetyCheckedSpawnEnt += numSpawnEntsBetweenLastAndCurrentSelection

		numVertSplits++
		generatedVertSplits.append( verticalDistanceTraveled )
	}

	if ( verbosePrint )
		printt( "Num generated vert splits:", generatedVertSplits.len(), "num div selections:", numSpawnsToReturn )

	
	
	int numVertSplitsToUse = minint( numSpawnsToReturn, numVertSplits )
	generatedVertSplits.randomize()
	
	array<float> vertSplitsToUse = generatedVertSplits.slice( 0, numVertSplitsToUse )
	vertSplitsToUse.sort( SortLowestFloat )

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	array<entity> spawnSelections
	int idx_vertSplit
	float horizTarget = RandomFloatRange( minWidth, maxWidth )
	int curAxisBestSpawnEntChoice
	float curBestChoiceDistSQ = defaultGridHalfSize * defaultGridHalfSize

	for( int i = 0; i < numSelectedSpawnEnts; i++ )
	{
		entity spawnEnt        = expect entity( selectedSpawnPositions[ i ].ent )
		float spawnEntVertDist = expect float( selectedSpawnPositions[ i ].vertDist )
		float curVerticalSplit = vertSplitsToUse[ idx_vertSplit ]

		if ( ( spawnEntVertDist < curVerticalSplit ) && ( spawnEntVertDist - curVerticalSplit ) < minDesiredSpawnSpacing )
		{
			float spawnEntHorizDist = expect float( selectedSpawnPositions[ i ].horizDist )
			float vertDistDiff      = curVerticalSplit - spawnEntVertDist
			float horizDistDiff     = fabs( horizTarget - spawnEntHorizDist )
			float distSQ            = ( vertDistDiff * vertDistDiff ) + ( horizDistDiff * horizDistDiff )
			if ( distSQ < curBestChoiceDistSQ )
			{
				
				bool curBestChoiceIsLastAxisSelection = ( idx_vertSplit > 0 ) && ( spawnEnt == spawnSelections.top() )
				if ( ( idx_vertSplit == 0 ) || !curBestChoiceIsLastAxisSelection )
				{
					curBestChoiceDistSQ       = distSQ
					curAxisBestSpawnEntChoice = i
				}
			}

			int nextSpawnEntIdx      = i + 1
			bool moreSpawnEntsRemain = nextSpawnEntIdx < numSelectedSpawnEnts
			entity selectedEnt = expect entity( selectedSpawnPositions[ curAxisBestSpawnEntChoice ].ent )

			if ( moreSpawnEntsRemain )
			{
				float nextVertDist                = expect float( selectedSpawnPositions[ nextSpawnEntIdx ].vertDist )
				bool moreSpawnEntsInVerticalSplit = nextVertDist <= curVerticalSplit
				if ( !moreSpawnEntsInVerticalSplit )
				{
					if ( !spawnSelections.contains( selectedEnt ) )
					{
						spawnSelections.append( selectedEnt )
						idx_vertSplit++
					}

					
					bool shouldChooseNewHorizTarget = idx_vertSplit < numVertSplitsToUse
					if ( shouldChooseNewHorizTarget )
					{
						curBestChoiceDistSQ = defaultGridHalfSize * defaultGridHalfSize

						array<float> newHorizTargetChoices
						float selectedSpawnHorizPosition = expect float( selectedSpawnPositions[ curAxisBestSpawnEntChoice ].horizDist )
						float horizTargetLowEndStart     = selectedSpawnHorizPosition - minDesiredHorizSpacing

						if ( horizTargetLowEndStart > minWidth )
							newHorizTargetChoices.append( RandomFloatRange( minWidth, horizTargetLowEndStart ) )

						float horizTargetHighEndStart = selectedSpawnHorizPosition + minDesiredHorizSpacing
						if ( horizTargetHighEndStart < maxWidth )
							newHorizTargetChoices.append( RandomFloatRange( maxWidth, horizTargetHighEndStart ) )

						if ( newHorizTargetChoices.len() == 0 )
						{
							newHorizTargetChoices.append( RandomFloatRange( minWidth, maxWidth ) )
							Warning( "Warning! Had to select random horiz axis location for next loot tick spawn. minDesiredHorizDistributionDist (" + minDesiredHorizSpacing + ") too large, or loot bin area too narrow (" + ( maxWidth - minWidth ) + ")" )
						}

						
						horizTarget = newHorizTargetChoices.getrandom()

						
						i--
					}
					
					else
						break
				}
			}
			else if ( !moreSpawnEntsRemain && !spawnSelections.contains( selectedEnt ) )
				spawnSelections.append( selectedEnt )
		}
	}

	return spawnSelections
}

int function SortSpawnPositionsByVertDist( table a, table b )
{
	float vertDistA = expect float( a.vertDist )
	float vertDistB = expect float( b.vertDist )

	if ( vertDistA > vertDistB )
		return 1
	else if ( vertDistB > vertDistA )
		return -1

	return 0
}

bool function IsEqualVector( vector a, vector b )
{
	return DistanceSqr( a, b) <= FLT_EPSILON
}

bool function IsEqualFloat( float left, float right )
{
	return fabs( left - right ) < FLT_EPSILON
}

float function CalculateFloatArrayVarianceWithGivenPercentile( array<float> inArr, float percentile )
{
	array<float> arr = inArr
	arr.sort()

	
	int maxIndex = int( percentile * arr.len() )

	float average = 0
	for( int i = 0; i < maxIndex; i++ )
	{
		average += arr[i]
	}

	average /= maxIndex

	float sumOfSquares = 0
	for( int i = 0; i < maxIndex; i++ )
	{
		float deviationFromAvg = arr[i] - average
		sumOfSquares += ( deviationFromAvg * deviationFromAvg )
	}

	return sumOfSquares / maxIndex
}

float function CalculateIntArrayVarianceWithGivenPercentile( array<int> inArr, float percentile )
{
	array<int> arr = inArr
	arr.sort()

	
	int maxIndex = int( 0.9 * arr.len() )

	float average = 0
	for( int i = 0; i < maxIndex; i++ )
	{
		average += float( arr[i] )
	}

	average /= maxIndex

	float sumOfSquares = 0
	for( int i = 0; i < maxIndex; i++ )
	{
		float deviationFromAvg = ( float( arr[i] ) - average )
		sumOfSquares += ( deviationFromAvg * deviationFromAvg )
	}

	return sumOfSquares / maxIndex
}



float function MetersToInches( float meters )
{
	return( meters * METERS_TO_INCHES )
}

float function MetersToInchesSqr( float meters )
{
	float inches = MetersToInches( meters )
	return( inches * inches )
}

float function InchesToMeters( float inches )
{
	return( inches * INCHES_TO_METERS )
}



















bool function IsPlayerOneOfCharacters( entity player, array< string > charactersCheck )
{
	ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_Character() )
	string characterRef  = ItemFlavor_GetCharacterRef( character ).tolower()

	foreach ( characterCheck in charactersCheck )
	{
		if ( characterRef == characterCheck )
			return true
	}

	return false
}

bool function IsPlayerCharacter( entity player, string characterCheck )
{
	ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_Character() )
	string characterRef  = ItemFlavor_GetCharacterRef( character ).tolower()

	if ( characterRef != characterCheck )
		return false

	return true
}


bool function PlayerIsLinkedToDeathbox( entity player, entity deathbox )
{
	array<entity> linkedEntArray = player.GetLinkEntArray()
	foreach ( entity linkedEnt in linkedEntArray )
	{
		if ( linkedEnt.GetNetworkedClassName() != "prop_death_box" )
			continue

		if ( linkedEnt == deathbox )
			return true
	}

	return false
}


#if DEV
bool function DEV_ForceLoadAllEntityTypes()
{
	return GetCurrentPlaylistVarBool( "dev_force_load_all_entity_types", DEV_FORCE_LOAD_ALL_ENTITIES )
}
#endif

















bool function IsInBleedoutOrRevive( entity player )
{
	if( !player.IsPlayer() )
		return false

	bool bleedingOut = Bleedout_IsBleedingOut( player )
	bool reviveRelated = player.ContextAction_IsBeingRevived() || player.ContextAction_IsReviving()

	return( bleedingOut || reviveRelated )
}










float function GetScreenScaleFrac()
{
	UISize screenSize = GetScreenSize()
	float screenSizeXFrac =  screenSize.width / 1920.0
	float screenSizeYFrac =  screenSize.height / 1080.0
	return min(screenSizeXFrac, screenSizeYFrac)
}



float function GetNearestAspectRatio( int width, int height )
{
	float aspectRatio = width / float( height )

	if ( fabs( ASPECT_RATIO_16_BY_10 - aspectRatio ) < 0.1 )
		return aspectRatio
	else if ( fabs( ASPECT_RATIO_16_BY_9 - aspectRatio ) < 0.1 )
		return aspectRatio
	else if ( fabs( ASPECT_RATIO_21_BY_9 - aspectRatio ) < 0.1 )
		return aspectRatio 
	else if ( fabs( (16.0 * 3 / 9.0) - aspectRatio ) < 0.1 )
		return ASPECT_RATIO_16_BY_9
	else if ( fabs( (16.0 * 3 / 10.0) - aspectRatio ) < 0.1 )
		return ASPECT_RATIO_16_BY_10

	return aspectRatio
}















      