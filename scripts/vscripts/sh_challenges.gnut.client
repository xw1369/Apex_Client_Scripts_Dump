
global function ShChallenges_LevelInit_PreStats
global function ShChallenges_LevelInit_PostStats
global function GetAllChallenges
global function HasChallengeForCharacter
global function GetAllChallengesOfTimespan
global function Challenge_IsAutogen
global function Challenge_GetRequestedAutogenSlotFromFlavor
global function Challenge_GetScriptHookForAutogenChallenge
global function Challenge_GetTierCount
global function Challenge_LastTierIsInfinite
global function Challenge_GetCurrentTier
global function Challenge_GetActiveTier
global function Challenge_IsComplete
global function Challenge_IsAllComplete
global function Challenge_CountComplete
global function Challenge_GetTimeSpanKind
global function Challenge_IsBoostEnabled
global function Challenge_IsRerollEnabled
global function Challenge_GetGoalVal
global function Challenge_GetProgressPercent
global function Challenge_EitherOr_GetGoalVals
global function Challenge_GetBPStarsReward
global function Challenge_GetBattlepassLevelsReward
global function Challenge_GetRewards
global function Challenge_IsPremium
global function Challenge_IsEitherOr
global function Challenge_HasProgress
global function Challenge_GetProgressValue
global function Challenge_EitherOr_GetProgressValues
global function Challenge_GetSource
global function Challenge_GetStatRefs
global function Challenge_EitherOr_GetStatRefs
global function Challenge_CanRerollChallenge
global function Challenge_IsChallengesStateInititated
global function RegisterChallengeSource
global function Challenge_GetSortOrdinal
global function Challenge_IsAssigned
global function Challenge_GetGameModeTagColor
global function Challenge_GetGameModeTag
global function Challenge_GetGameMode
global function Challenge_EitherOr_GetGameModes
global function IsChallengeValidAsFavorite
global function Challenge_GetTierDataBlock
global function Challenge_GetPostGamePersistenceIndex
global function GetPlayerChallengesState
global function Challenge_GetCharacterItemFlavors
global function GetAssignedChallengesByTimeSpan
global function Challenge_IsMetaChallenge
global function MetaChallenge_GetStatRef
global function MetaChallenge_GetParentFlav
global function MetaChallenge_GetGoalVal
global function GetCompletedChallengeCount
#if DEV
global function PrintChallengePersistence
#endif


global function Challenge_IsNarrativeChallenge




global function Challenge_GetDescription
global function Challenge_EitherOr_GetDescriptions
global function SetRuiArgsForChallengeTier
global function SetRuiArgsForChallengeReward
global function GetChallengeRewardDisplayData
global function UpdateChallengeCategorySelection
global function IncrementCategorySelection
global function DecrementCategorySelection
global function SetSeasonColors
global function SetBattlePassLevelBadgeForLevel
global function SetRuiArgsForMythicSkinChallenge
global function IsFavoriteChallenge
global function GetFavoriteChallenges
global function IsEventCategory
global function GetActiveBuffetEventForCategory

#if DEV
global function DEV_DumpFavoritePersistenceData
#endif


#if DEV
global function DEV_RequestCompleteChallengeTier
global function DEV_GetAssignedChallengeData
global function DEV_GetChallengeTimeSpans
#endif






































global function ServerToClient_AssignedChallengesDidChange
global function ServerToClient_ChallengeDataDidChange
global function UpdateMinimapChallengeRui
global function UpdateClientCategorySelectionIndexFromUI
global function HasChallengeForWeapon





#if DEV
global function DEV_PrintAllChallenges
#endif







































global enum eChallengeCategory
{
	EVENT_00,
	EVENT_01,
	EVENT_02,
	EVENT_03,
	STORY_00,
	STORY_01,
	STORY_02,
	STORY_03,
	BEGINNER,
	DAILY,
	TOP_WEEKLY,
	REWARD_CAMPAIGN,
	EVENTSHOP_DAILY_CHALLENGE,
	EVENTSHOP_EVENT_CHALLENGE,
	FAVORITES,
	TEMP_UNLOCK,

	CHALLENGE_TILE,

}



const table<int, string> GAME_MODE_NAME =
{
	[eChallengeGameMode.ANY] = "#GAME_MODE_ANY",
	[eChallengeGameMode.BATTLE_ROYALE] = "#GAME_MODE_BR",
	[eChallengeGameMode.ARENAS] = "#GAME_MODE_ARENAS",
	[eChallengeGameMode.NON_MODE] = "", 
	[eChallengeGameMode.CONTROL] = "#GAME_MODE_CONTROL",
	[eChallengeGameMode.EXCEPT_BR] = "#GAME_MODE_EXCEPT_BR",
	[eChallengeGameMode.GUNGAME] = "#GAME_MODE_GUNGAME",
	[eChallengeGameMode.TREASURE_HUNT] = "#FREEDM_LOCKDOWN_MODE",
}


const table<int, string> GAME_MODE_TAG =
{
	[eChallengeGameMode.ANY] = "",
	[eChallengeGameMode.BATTLE_ROYALE] = "#GAMEMODE_TAG_BATTLE_ROYAL",
	[eChallengeGameMode.ARENAS] = "#GAMEMODE_TAG_ARENAS",
	[eChallengeGameMode.NON_MODE] = "", 
	[eChallengeGameMode.CONTROL] = "#GAMEMODE_TAG_CONTROL",
	[eChallengeGameMode.EXCEPT_BR] = "#GAMEMODE_TAG_EXCEPT_BR",
	[eChallengeGameMode.GUNGAME] = "#GAMEMODE_TAG_GUNGAME",
	[eChallengeGameMode.TREASURE_HUNT] = "#FREEDM_LOCKDOWN_TAG",
}

const table<int, vector> GAME_MODE_TAG_COLOR =
{
	[eChallengeGameMode.ANY] =  <0,0,0>,
	[eChallengeGameMode.BATTLE_ROYALE] = < 64, 148, 158 >,
	[eChallengeGameMode.ARENAS] = < 108,79,198 >,
	[eChallengeGameMode.NON_MODE] = <0,0,0>, 
	[eChallengeGameMode.CONTROL] = < 215,154,8 >,
	[eChallengeGameMode.EXCEPT_BR] = < 0,71,115 >,
	[eChallengeGameMode.GUNGAME] = < 50,150,50 >,
	[eChallengeGameMode.TREASURE_HUNT] = < 0,71,115 >,
}

global enum eChallegeDifficulty
{
	VERY_EASY,
	EASY,
	MEDIUM,
	HARD,
	VERY_HARD
}



global enum eChallengeTimeSpanKind
{
	BEGINNER,
	EVENTSHOP_DAILY_CHALLENGE, 
	EVENTSHOP_EVENT_CHALLENGE, 
	DAILY,
	SEASON_WEEKLY,
	SEASON_WEEKLY_RECURRING,
	EVENT,
	EVENT_SPECIAL,
	EVENT_SPECIAL_2,
	EVENT_HIDDEN, 
	REWARD_CAMPAIGN,
	MYTHIC,
	NARRATIVE,
	FAVORITE, 
}

global enum eChallengeRewardStyle
{
	
	ITEM_GENERAL = 1
	ITEM_BADGE = 2
	ITEM_WEAPON_SKIN = 3
}
global enum eTinyLabelPlacementStyle
{
	
	NONE = 0
	LEFT = 1
	CENTER = 2
	BOTTOM = 3
}





































global struct ChallengeRewardDisplayData
{
	ItemFlavor&       flav
	int               originalQuantity
	int               displayQuantity
	int               style
	int               rarityTier
	asset             icon
	ItemFlavor ornull badgeFlav
	int               badgeTier = -1
	string            tinyLabelText = ""
	int               tinyLabelPlacementStyle = eTinyLabelPlacementStyle.NONE
	bool			  isMythicSkin
}



struct ChallengeSortStruct
{
	
	float progressFrac,
	int week,
	int difficulty,
	string name,
	ItemFlavor& challengeFlav
}



global const string CHALLENGE_REROLL_SOUND = "UI_Menu_Challenge_ReRoll"


global const int PRIMARY_CHALLENGE_INDEX = 0
global const int ALT_CHALLENGE_INDEX = 1


global const bool BOTS_HAVE_CHALLENGES = false








const int MAX_UNOWNED_CHAR_CHALLENGE = 1
const array<int> DAILY_CHALLENGE_SET = [ eChallegeDifficulty.VERY_EASY, eChallegeDifficulty.EASY, eChallegeDifficulty.MEDIUM, eChallegeDifficulty.HARD, eChallegeDifficulty.VERY_HARD ]
const int NUM_DAILY_CHALLENGES = 5 
const int NUM_FAVORITE_CHALLENGES = NUM_DAILY_CHALLENGES 
const int NUM_WEEKLY_CHALLENGES_MAX = 11
const int NUM_CHALLENGE_WEEKS_MAX = 13
const int NUM_CHALLENGE_BUFFER_FOR_EVENTS = 32 
const int NUM_REWARD_CAMPAIGN_CHALLENGES_BUFFER = 50 
const int NUM_CHALLENGES_MAX = (NUM_WEEKLY_CHALLENGES_MAX * NUM_CHALLENGE_WEEKS_MAX) + NUM_DAILY_CHALLENGES + NUM_CHALLENGE_BUFFER_FOR_EVENTS + NUM_REWARD_CAMPAIGN_CHALLENGES_BUFFER
const int NUM_POST_GAME_CHALLENGES_MAX = 32


global const int MAX_REWARDS_PER_CHALLENGE_TIER = 4 


global const string CHALLENGE_TIMEZONE_OFFSET_PVAR_NAME = "challengeTimeZoneOffsetHours"

const int BASE_CHALLENGE_TIER = 0 
const asset BATTLE_COMPLETED_HEADER_IMAGE = $"rui/menu/battlepass/battle_pass_completed_header"


global struct ChallengeState
{
	int         persistenceIdx = -1
	ItemFlavor& flav
}




global struct PlayerChallengesState
{
	table<ItemFlavor, ChallengeState>   challengeStateMap
	array<ChallengeState ornull>        persistentArrayMirror
	bool statCallbacksRegistered = false
	bool challengesThreadCompleted = false
}



struct SeasonalInfoCache
{
	ItemFlavor ornull calEventOrNull
	ItemFlavor ornull battlePassOrNull
	int expirationTimestamp
}


struct StatRefMapChallengePair
{
	ItemFlavor& challenge
	bool	   statIsAlt
}


struct FileStruct_LifetimeLevel
{
	
	table<StatEntry, array<StatRefMapChallengePair> > statEntryChallengesMap

	table<ItemFlavor, ItemFlavor>        challengeSourceMap
	table<ItemFlavor, int>               challengeSortOrdinalMap
	SeasonalInfoCache currentSeason


		array<ItemFlavor> currentEvents
		array<ItemFlavor> currentStories













		PlayerChallengesState localPlayerChallengesState
		int                   _challengeCategorySelectionIndex
		array<ItemFlavor>     favoriteChallengeCache






	bool hasPlaylistChallengeOverrides = false

	int statsFetchMode = eStatFetchMode.DEFAULT

}
FileStruct_LifetimeLevel& fileLevel

global const array<int> CHALLENGE_REROLL_COSTS = [ 0, 2, 5, 10 ]






struct
{
	bool                    initialized = false
	BattlePassReward ornull nextBattlePassReward

        
	bool					hasCompletedEventEntirely = false
	bool					hasCompletedEventDailies = false
	bool					hasCompletedRegularDailies = false
} file


table<var, void functionref(var)> WORKAROUND_challengeButtonToFocusHandlerMap = {} 
table<var, void functionref(var)> WORKAROUND_challengeButtonToClickHandlerMap = {} 
table<var, void functionref(var)> WORKAROUND_challengeButtonToRightClickHandlerMap = {} 









void function ShChallenges_LevelInit_PreStats()
{
	FileStruct_LifetimeLevel newFileLevel
	fileLevel = newFileLevel

	AddCallback_OnItemFlavorRegistered( eItemType.challenge, Callback_OnChallengeRegistered )






		AddCreateCallback( "player", UpdateFavoriteChallengesCache )



		RegisterSignal( "ChallengeDataDidChange" )
		Remote_RegisterClientFunction( "ServerToClient_AssignedChallengesDidChange", "bool" )
		Remote_RegisterClientFunction( "ServerToClient_ChallengeDataDidChange", "bool" )
		Remote_RegisterUIFunction( "ServerToUI_FavoriteChallengeDidToggle", "int", 0, INT_MAX, "bool" )

		Remote_RegisterServerFunction( "ClientCallback_Challenge_SetTimeZoneOffsetHours", "int", -12, 13 )
		Remote_RegisterServerFunction( "ClientCallback_Challenge_ReRoll", "int", INT_MIN, INT_MAX )

		Remote_RegisterServerFunction( "DEV_ClientCallback_RequestCompleteChallengeTierByGUID", "int", 0, INT_MAX )

		Remote_RegisterServerFunction( "UICallback_ForceCompleteChallenge", "int", 0, INT_MAX )
		Remote_RegisterUIFunction( "ServerToUI_RefreshCompletedChallengeUI", "int", 0, INT_MAX )
































	BeginnerChallenges_Init()


	file.initialized = true
}




void function Callback_OnChallengeRegistered( ItemFlavor challenge )
{
























}




void function ShChallenges_LevelInit_PostStats()
{
#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return
#endif

	fileLevel.hasPlaylistChallengeOverrides = GetCurrentPlaylistVarBool( "has_playlist_challenge_overrides", false )

	RefreshCachedSeasonInfo()

		RefreshEventCache()


	foreach ( ItemFlavor challenge in GetAllChallenges() )
	{
		array<bool> fetchAltRefs = [ false ]
		if ( Challenge_IsEitherOr( challenge ) )
			fetchAltRefs.append( true )

		foreach ( bool isAlt in fetchAltRefs )
		{
			int tierCount = Challenge_GetTierCount( challenge )

			for ( int i = 0 ; i < tierCount ; i++ )
			{
				array<string> statRefs = Challenge_GetStatRefs( challenge, i, isAlt )
				foreach ( string statRef in statRefs )
				{
					if ( !IsValidStatEntryRef( statRef ) )
					{
						Assert( false, format( "Challenge '%s' tier %d refers to non-existent stat: '%s'", string(ItemFlavor_GetAsset( challenge )), i, statRef ) )
						continue
					}

					StatEntry stat = GetStatEntryByRef( statRef )

					if ( !stat.writeImmediately )
					{
						Assert( false, format( "Challenge '%s' refers to stat that does not have the PERSISTENCE_WRITE_IMMEDIATELY flag: '%s'", string(ItemFlavor_GetAsset( challenge )), statRef ) )
						continue
					}

					if ( Challenge_GetTimeSpanKind( challenge ) == eChallengeTimeSpanKind.EVENT_HIDDEN )
					{
						continue
					}

					int challengeGameMode = Challenge_GetGameMode( challenge, isAlt )
					if ( challengeGameMode != stat.gameMode ) 
					{
						Assert( false, format( "Challenge '%s' refers to stat that does not match the challenge game mode: '%s'", string(ItemFlavor_GetAsset( challenge )), statRef ) )
						continue
					}

					if ( !(stat in fileLevel.statEntryChallengesMap) )
						fileLevel.statEntryChallengesMap[ stat ] <- []
					StatRefMapChallengePair	pair
					pair.challenge = challenge
					pair.statIsAlt = isAlt
					fileLevel.statEntryChallengesMap[ stat ].append( pair )
				}

				if ( Challenge_GetGoalVal( challenge, i, isAlt ) <= 0 )
				{
					Assert( false, format( "Challenge '%s' has invalid goal val: %d", string(ItemFlavor_GetAsset( challenge )), Challenge_GetGoalVal( challenge, i ) ) )
					continue
				}
			}
		}
	}




}




























void function RegisterChallengeSource( ItemFlavor challengeFlav, ItemFlavor sourceFlav, int sortOrdinal )
{
	if ( challengeFlav in fileLevel.challengeSourceMap )
	{
		Warning( "Challenge %s source is ambiguous: %s, %s", string(ItemFlavor_GetAsset( challengeFlav )), string(ItemFlavor_GetAsset( fileLevel.challengeSourceMap[challengeFlav] )), string(ItemFlavor_GetAsset( sourceFlav )) )
		return
	}
	fileLevel.challengeSourceMap[challengeFlav] <- sourceFlav
	fileLevel.challengeSortOrdinalMap[challengeFlav] <- sortOrdinal
}


int function Challenge_GetSortOrdinal( ItemFlavor challengeFlav )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )

	if ( !( challengeFlav in fileLevel.challengeSortOrdinalMap ) )
	{
		Warning( "Challenge %i was not in challengeSortOrdinalMap! Did you forget to RegisterChallengeSource?", challengeFlav.guid )
		return 0
	}

	return fileLevel.challengeSortOrdinalMap[challengeFlav]
}







































































































void function ServerToClient_AssignedChallengesDidChange( bool didEventChallengesRefresh )
{
	InitPlayerChallengesStateFromPersistence( GetLocalClientPlayer(), fileLevel.localPlayerChallengesState )
	RunUIScript( "ClientToUI_AssignedChallengesDidChange" )
	ServerToClient_ChallengeDataDidChange( didEventChallengesRefresh )
}
















void function ServerToClient_ChallengeDataDidChange( bool didEventChallengesRefresh )
{
	
	
	if ( didEventChallengesRefresh )
		RefreshEventCache()

	RunUIScript( "ClientToUI_ChallengeDataDidChange", didEventChallengesRefresh )
	UpdateFavoriteChallengesCache( GetLocalClientPlayer() )
}















































































































































































































































































void function UpdateMinimapChallengeRui( array<var> ruiArray )
{
	if ( !IsConnected() )
		return

#if CHALLENGE_DEBUG
		ChallengeDbg( GetLocalClientPlayer(), "" )
#endif

	
	var titleRui           = ruiArray[0]
	array<var> rowRuiArray = clone ruiArray
	rowRuiArray.remove( 0 )

	entity player = GetLocalClientPlayer()

	int timestamp = GetUnixTimestamp()
	ItemFlavor ornull currentEvent

	int challengeCategory = GetChallengeDisplayCategory( true )

	if ( IsEventCategory( challengeCategory ) )
	{
		if ( IsEventCategory( challengeCategory ) )
			currentEvent = GetActiveBuffetEventForCategory( timestamp, challengeCategory )
		else
			currentEvent = GetActiveBuffetEventForIndex( timestamp, 0 )
	}

	
	array<ItemFlavor> challenges = GetChallengesByCategory( player, challengeCategory, currentEvent )
	if ( IsRewardCampaignChallengeCategory( challengeCategory ) )
	{
		challenges = RewardCampaign_GetCurrentTempUnlockChallenges( player )
	}

	if ( IsTempUnlockChallengeCategory( challengeCategory ) )
	{
		challenges = TempUnlock_GetCurrentCharacterUnlockChallenges( player )
	}

	if ( IsEventCategory( challengeCategory ) )
	{
		if ( currentEvent != null )
		{
			expect ItemFlavor( currentEvent )
			FilterOutMainChallengeIfValid( currentEvent, challenges )
		}
		else 
		{
			array< ItemFlavor > chalCopy = clone challenges
			foreach ( ItemFlavor chal in chalCopy )
			{
				if ( Challenge_GetGameMode( chal ) == eChallengeGameMode.NON_MODE )
				{
					challenges.fastremovebyvalue( chal )
					break
				}
			}
		}
	}
	else if ( challenges.len() > NUM_DAILY_CHALLENGES )
	{
		Assert( false, format( "too many challenges - %d - being sent to the Challenge box-row RUI", challenges.len() ) )
		challenges.resize( NUM_DAILY_CHALLENGES )
	}
	Assert( challenges.len() <= NUM_DAILY_CHALLENGES )

	UpdateChallengeCategorySelection( titleRui, true, true )
	UpdateChallengeRowsRuiRefreshWrapper( player, challenges, rowRuiArray )
}

void function UpdateChallengeRowsRuiRefreshWrapper( entity player, array<ItemFlavor> challenges, array<var> rowRuis = [] )
{
	fileLevel.statsFetchMode = eStatFetchMode.FORCE_NO_CACHE
	UpdateChallengeRowsRui( player, challenges, rowRuis )
	fileLevel.statsFetchMode = eStatFetchMode.DEFAULT
}


void function FilterOutMainChallengeIfValid( ItemFlavor currentEvent, array<ItemFlavor> challenges )
{
	BuffetEventModesAndChallengesData eventData = BuffetEvent_GetModesAndChallengesData( currentEvent )
	if ( eventData.mainChallengeFlav != null )
	{
		ItemFlavor main = expect ItemFlavor( eventData.mainChallengeFlav )
		int idx         = challenges.find( main )
		if ( idx >= 0 )
		{
			challenges.remove( idx )
		}
	}
}


array<ItemFlavor> function GetChallengesByCategory( entity player, int challengeCategory, ItemFlavor ornull currentEvent )
{
	bool hasActiveEvent = false
	if ( currentEvent != null )
	{
		expect ItemFlavor( currentEvent )
		hasActiveEvent = true
	}

	array<ItemFlavor> challenges
	if ( IsEventCategory( challengeCategory ) )
	{
		int timespan = IsEventShopChallengeCategory( challengeCategory ) ? eChallengeTimeSpanKind.EVENTSHOP_DAILY_CHALLENGE : eChallengeTimeSpanKind.EVENT
		challenges = GetAssignedChallengesByTimeSpan( player, timespan, -1, currentEvent )
	}
	else if ( IsStoryCategory( challengeCategory ) )
	{
		expect ItemFlavor( currentEvent )

		challenges = StoryEvent_GetCurrentChapterChallenges( player,  currentEvent )
	}
	else
	{
		switch( challengeCategory )
		{
			case eChallengeCategory.BEGINNER:
			{
				array<ItemFlavor> allBeginnerChallenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.BEGINNER )
				foreach ( ItemFlavor beginnerChallenge in allBeginnerChallenges )
				{
					if ( challenges.len() > 4 )
						break 




						if ( !Challenge_IsComplete( player, beginnerChallenge ) && !Challenge_IsMetaChallenge( beginnerChallenge ) )
						{
							challenges.append( beginnerChallenge )
						}

				}
				break
			}

			case eChallengeCategory.DAILY:
				challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.DAILY )
				break

			case eChallengeCategory.TOP_WEEKLY:
				challenges = GetWeeklyChallengesSortedByProgress( player )
				break

			case eChallengeCategory.FAVORITES:
				challenges = GetFavoriteChallenges( player )
				break

			case eChallengeCategory.EVENTSHOP_DAILY_CHALLENGE:
				challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENTSHOP_DAILY_CHALLENGE )
				break

			case eChallengeCategory.EVENTSHOP_EVENT_CHALLENGE:
				challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENTSHOP_EVENT_CHALLENGE )
				break

			case eChallengeCategory.REWARD_CAMPAIGN:
				challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.REWARD_CAMPAIGN )
				break

			case eChallengeCategory.TEMP_UNLOCK:
				array<ItemFlavor> tempUnlockEvents = TempUnlock_GetActiveEvents( GetUnixTimestamp() )
				foreach( ItemFlavor tempUnlockEvent in tempUnlockEvents )
				{
					
					challenges.extend( TempUnlock_GetCharacterUnlockChallenges( tempUnlockEvent ) )
				}
				break

			case eChallengeCategory.CHALLENGE_TILE:








				break

			unreachable
		}
	}

	return challenges
}



array<ItemFlavor> function GetWeeklyChallengesSortedByProgress( entity player )
{
	const NUM_CHALLENGES_TO_RETURN = NUM_DAILY_CHALLENGES

	array<ChallengeSortStruct> challengeSortArray

	PlayerChallengesState pcs = GetPlayerChallengesState( player )

	array<ItemFlavor> results
	foreach ( ItemFlavor challengeFlav, ChallengeState cs in pcs.challengeStateMap )
	{
		if ( Challenge_GetTimeSpanKind( challengeFlav ) == eChallengeTimeSpanKind.SEASON_WEEKLY )
		{
			if ( !IsChallengePlaylistEnabled( challengeFlav ) )
				continue

			if ( Challenge_IsComplete( player, challengeFlav ) )
				continue

			if ( Stats_CurrentModeSupportsCustomStats() && !Challenge_IsEitherOr( challengeFlav ) && Challenge_GetGameMode( challengeFlav ) == eChallengeGameMode.BATTLE_ROYALE )
				continue

			if ( !Stats_CurrentModeSupportsCustomStats() && !Challenge_IsEitherOr( challengeFlav ) && !Challenge_CanBeCompletedInBR( challengeFlav ) )
				continue

			int currentTier = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].currentTier" )
			int goalVal     = Challenge_GetGoalVal( challengeFlav, currentTier )

			int current            = 0
			array<string> statRefs = Challenge_GetStatRefs( challengeFlav, currentTier )
			foreach ( string statRef in statRefs )
			{
				Assert( IsValidStatEntryRef( statRef ) )
				StatEntry entry = GetStatEntryByRef( statRef )
				Assert( entry.type == eStatType.INT )
				current += GetStat_Int( player, entry, eStatGetWhen.CURRENT )
			}

			int marker = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarker" )

			float progressFrac = float(current - marker) / float(goalVal)

			if ( Challenge_IsEitherOr( challengeFlav ) && Stats_CurrentModeSupportsCustomStats() )
			{
				bool getAlt = true
				int markerAlt  = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarkerAlt" )
				int goalValAlt = Challenge_GetGoalVal( challengeFlav, currentTier, getAlt )
				int currentAlt = 0

				array<string> altRefs = Challenge_GetStatRefs( challengeFlav, currentTier, getAlt )
				foreach ( string statRef in altRefs )
				{
					Assert( IsValidStatEntryRef( statRef ) )
					StatEntry entry = GetStatEntryByRef( statRef )
					Assert( entry.type == eStatType.INT )
					currentAlt += GetStat_Int( player, entry, eStatGetWhen.CURRENT )
				}

				progressFrac = float(currentAlt - markerAlt) / float(goalValAlt)
			}

			int activeTier           = Challenge_GetCurrentTier( player, challengeFlav )

			ChallengeSortStruct sortStruct
			sortStruct.progressFrac  = progressFrac
			sortStruct.week          = Challenge_FindAssignedWeekOrder( player, challengeFlav )
			sortStruct.difficulty    = Challenge_GetDifficulty( challengeFlav )
			sortStruct.name          = Challenge_GetDescription( challengeFlav, activeTier )
			sortStruct.challengeFlav = challengeFlav

			challengeSortArray.append( sortStruct )
		}
	}
	challengeSortArray.sort( Challenge_SortByProgress )
#if DEV
		foreach ( ChallengeSortStruct sortStruct in challengeSortArray )
		{
			printt( DEV_ItemFlavor_GetCleanedAssetPath( sortStruct.challengeFlav ) + "\t" + sortStruct.progressFrac + "\t" + sortStruct.week )
		}
#endif

	array<ItemFlavor> topWeeklyChallenges = []
	int maxSize                           = minint( NUM_CHALLENGES_TO_RETURN, challengeSortArray.len() )

	string prevDescription
	for ( int index = 0; index < challengeSortArray.len(); index++ )
	{
		ItemFlavor challenge = challengeSortArray[ index ].challengeFlav
		int challengeTier    = Challenge_GetCurrentTier( player, challenge )
		string challengeDesc = Challenge_GetDescription( challenge, challengeTier )
		if ( challengeDesc == prevDescription )
		{
			
			continue
		}

		prevDescription = challengeDesc
		topWeeklyChallenges.append( challengeSortArray[ index ].challengeFlav )

		if ( topWeeklyChallenges.len() >= maxSize )
			break
	}

	return topWeeklyChallenges
}



int function Challenge_FindAssignedWeekOrder( entity player, ItemFlavor challengeFlav )
{
	int weekIndex = Challenge_GetWeekNumber( challengeFlav )

	for ( int i = 0 ; i < NUM_CHALLENGE_WEEKS_MAX ; i++ )
	{

			int groupIndex = player.GetPersistentVarAsInt( "weeklyGroupOrder[" + i + "]" )



		if ( groupIndex == weekIndex )
			return i
	}

	return -1    
}



int function Challenge_SortByProgress( ChallengeSortStruct a, ChallengeSortStruct b )
{
	
	if ( a.progressFrac < b.progressFrac )
		return 1
	else if ( a.progressFrac > b.progressFrac )
		return -1

	
	if ( a.week > b.week )
		return 1
	else if ( a.week < b.week )
		return -1

	
	if ( a.difficulty > b.difficulty )
		return 1
	else if ( a.difficulty < b.difficulty )
		return -1

	
	if ( a.name > b.name )
		return 1
	else if ( a.name < b.name )
		return -1

	return 0
}




















































































































































void function UpdateFavoriteChallengesCache( entity player )
{
	Assert( IsValid( player ) )

	if ( player != GetLocalClientPlayer() )
		return

	fileLevel.favoriteChallengeCache.clear()
	for ( int index = 0; index < NUM_FAVORITE_CHALLENGES; index++ )
	{
		SettingsAssetGUID challengeGUID = player.GetPersistentVarAsInt( format( "favoriteChallengeGUID[%d]", index ) )
		if ( !IsValidItemFlavorGUID( challengeGUID ) )
			continue

		ItemFlavor challengeFlav = GetItemFlavorByGUID( challengeGUID )

		if ( !IsChallengeValidAsFavorite( player, challengeFlav ) )
			continue

		fileLevel.favoriteChallengeCache.append( challengeFlav )
	}
}



bool function HasFavoriteChallenges()
{
	return fileLevel.favoriteChallengeCache.len() > 0
}



bool function IsFavoriteChallenge( ItemFlavor challengeFlav )
{
	entity player = GetLocalClientPlayer()
	return fileLevel.favoriteChallengeCache.contains( challengeFlav )
}



array<ItemFlavor> function GetFavoriteChallenges( entity player )
{
	const NUM_CHALLENGES_TO_RETURN = NUM_DAILY_CHALLENGES

	array<ChallengeSortStruct> challengeSortArray
	PlayerChallengesState pcs                = GetPlayerChallengesState( player )
	array<ItemFlavor> favoriteChallengeArray = fileLevel.favoriteChallengeCache

	foreach ( ItemFlavor challengeFlav in favoriteChallengeArray )
	{
		if ( !IsChallengeValidAsFavorite( player, challengeFlav ) )
			continue

		int currentTier     = Challenge_GetCurrentTier( player, challengeFlav )
		int currentProgress = Challenge_GetProgressValue( player, challengeFlav, currentTier )
		int goalProgress    = Challenge_GetGoalVal( challengeFlav, currentTier )

		ChallengeSortStruct sortStruct
		sortStruct.progressFrac  = float(currentProgress) / float(goalProgress)
		sortStruct.difficulty    = Challenge_GetDifficulty( challengeFlav )
		sortStruct.name          = Challenge_GetDescription( challengeFlav, currentTier )
		sortStruct.challengeFlav = challengeFlav

		challengeSortArray.append( sortStruct )
	}

	challengeSortArray.sort( Challenge_SortByProgress )

	array<ItemFlavor> topFavoriteChallenges = []
	int maxSize                             = minint( NUM_CHALLENGES_TO_RETURN, challengeSortArray.len() )

	for ( int index = 0; index < challengeSortArray.len(); index++ )
	{
		topFavoriteChallenges.append( challengeSortArray[ index ].challengeFlav )

		if ( topFavoriteChallenges.len() >= maxSize )
			break
	}

	return topFavoriteChallenges
}



bool function IsChallengeValidAsFavorite( entity player, ItemFlavor challengeFlav )
{
	if ( !Challenge_IsAssigned( player, challengeFlav ) )
		return false
	if ( Challenge_IsComplete( player, challengeFlav ) )
		return false
	if ( !IsChallengePlaylistEnabled( challengeFlav ) )
		return false

	return true
}


#if DEV
array<string> function DEV_GetChallengeTimeSpans()
{
	array<string> timeSpans = []
	foreach ( string key, int timeSpan in eChallengeTimeSpanKind )
		timeSpans.append( key )

	return timeSpans
}
#endif

#if DEV
array<ChallengeDebugDataStruct> function DEV_GetAssignedChallengeData( int timeSpan )
{
	entity lcPlayer = GetLocalClientPlayer()
	array<ItemFlavor> allChallenges = []
	if ( timeSpan == eChallengeTimeSpanKind.FAVORITE )
	{
		allChallenges = GetFavoriteChallenges( lcPlayer )
	}
	else if ( timeSpan != eChallengeTimeSpanKind.SEASON_WEEKLY )
	{
		allChallenges = GetAssignedChallengesByTimeSpan( lcPlayer, timeSpan )
	}
	else
	{
		ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull
		Assert( activeBattlePass != null )
		expect ItemFlavor( activeBattlePass )

		int numWeeks = GetNumBattlePassChallengesWeeks( activeBattlePass )
		array< ItemFlavor > weeklyChallenges = []
		for ( int week = 1; week <= numWeeks; week++ )
			weeklyChallenges.extend( GetBattlePassChallenges( activeBattlePass, eChallengeTimeSpanKind.SEASON_WEEKLY, week ) )

		foreach ( challenge in weeklyChallenges )
		{
			if ( Challenge_IsAssigned( lcPlayer, challenge ) )
				allChallenges.append( challenge )
		}
	}

	array<ChallengeDebugDataStruct> challengeDebugData = []
	foreach ( challenge in allChallenges )
	{
		ChallengeDebugDataStruct challengeData
		challengeData.guid 	   = challenge.guid
		challengeData.category = Challenge_GetTimeSpanKind( challenge )
		challengeData.ref      = ItemFlavor_GetHumanReadableRefForPIN_Slow( challenge )
		
		int goal            = Challenge_GetGoalVal( challenge, 0 )
		int progress        = Challenge_GetProgressValue( lcPlayer, challenge, 0 )
		array<string> stats = Challenge_GetStatRefs( challenge, 0 )
		challengeData.debugInfo = format( "Progress: %d / %d | Stat: %s",
											progress,
											goal,
											stats[0] )
		challengeData.complete = ( goal == progress )
		challengeDebugData.append( challengeData )
	}

	return challengeDebugData
}
#endif

#if DEV
void function DEV_DumpFavoritePersistenceData()
{
	entity player = GetLocalClientPlayer()

	printt( "PERSISTENCE" )
	for ( int index = 0; index < NUM_FAVORITE_CHALLENGES; index++ )
	{
		SettingsAssetGUID challengeGUID = player.GetPersistentVarAsInt( format( "favoriteChallengeGUID[%d]", index ) )
		printt( "\t", index, "challengeGUID", challengeGUID )

		if ( !IsValidItemFlavorGUID( challengeGUID ) )
		{
			printt( "\t\t-------" )
			continue
		}

		ItemFlavor challengeFlav = GetItemFlavorByGUID( challengeGUID )

		bool assigned        = Challenge_IsAssigned( player, challengeFlav )
		bool playlistEnabled = IsChallengePlaylistEnabled( challengeFlav )
		bool complete        = assigned ? Challenge_IsComplete( player, challengeFlav ) : false

		printt( index, "\tchallengeFlav", DEV_ItemFlavor_GetCleanedAssetPath( challengeFlav ), assigned, playlistEnabled, complete )
	}
	printt( "\tCASHE" )
	foreach ( int index, ItemFlavor challengeFlav in fileLevel.favoriteChallengeCache )
	{
		bool assigned        = Challenge_IsAssigned( player, challengeFlav )
		bool playlistEnabled = IsChallengePlaylistEnabled( challengeFlav )
		bool complete        = assigned ? Challenge_IsComplete( player, challengeFlav ) : false

		printt( "\t", index, "\tchallengeFlav", DEV_ItemFlavor_GetCleanedAssetPath( challengeFlav ), assigned, playlistEnabled, complete )
	}
}
#endif




























array<int> function GetChallengeCategoryIDArray( bool hideStories = false )
{
	array<int> categoryIDtoStringArray = []





		array<ItemFlavor> allBeginnerChallenges = GetAssignedChallengesByTimeSpan( GetLocalClientPlayer(), eChallengeTimeSpanKind.BEGINNER )
		if ( allBeginnerChallenges.len() > 0 && BeginnerChallenges_GetPlayerCompletedChallengeCount( GetLocalClientPlayer() ) < allBeginnerChallenges.len() )
			categoryIDtoStringArray.append( eChallengeCategory.BEGINNER )

	
	int eventIdx = eChallengeCategory.EVENT_00
	foreach ( event in fileLevel.currentEvents )
	{
		Assert( IsEventCategory( eventIdx ) )
		categoryIDtoStringArray.append( eventIdx++ )
	}

	if ( EventShop_CurrentActiveEventShopHasDailyChallenges() )
	{
		categoryIDtoStringArray.append( eChallengeCategory.EVENTSHOP_DAILY_CHALLENGE )
	}

	if ( EventShop_CurrentActiveEventShopHasEventChallenges() )
	{
		ItemFlavor ornull activeEventShop = EventShop_GetCurrentActiveEventShop()
		if ( EventShop_GetShowEventChallengesInLobby( expect ItemFlavor(activeEventShop) ) )
		{
			categoryIDtoStringArray.append( eChallengeCategory.EVENTSHOP_EVENT_CHALLENGE )
		}
	}

	ItemFlavor ornull activeRewardCampaign = RewardCampaign_GetActiveRewardCampaign()
	if ( activeRewardCampaign != null )
	{
		expect ItemFlavor( activeRewardCampaign )

		array<ItemFlavor> collectionFlavs = RewardCampaign_GetChallengeCollections( activeRewardCampaign )
		foreach( collectionFlav in collectionFlavs )
		{
			ChallengeCollection activeCollection = ChallengeCollection_GetByGUID( collectionFlav.guid )
			if ( ChallengeCollection_HasChallenges( activeCollection ) )
			{
				categoryIDtoStringArray.append( eChallengeCategory.REWARD_CAMPAIGN )
			}
		}












	}














	array<ItemFlavor> tempUnlockChallenges = TempUnlock_GetCurrentCharacterUnlockChallenges( GetLocalClientPlayer() )
	if ( tempUnlockChallenges.len() > 0 )
	{
		categoryIDtoStringArray.append( eChallengeCategory.TEMP_UNLOCK )
	}

	
	if( !hideStories )
	{
		int storyIdx = eChallengeCategory.STORY_00
		foreach ( story in fileLevel.currentStories )
		{
			if( StoryEvent_GetShowInChallengeBoxBool( story ) )
			{
				Assert( IsStoryCategory( storyIdx ) )
				categoryIDtoStringArray.append( storyIdx++ )
			}
		}
	}

	bool hasFavorites = HasFavoriteChallenges()
	if ( hasFavorites )
		categoryIDtoStringArray.append( eChallengeCategory.FAVORITES )

	categoryIDtoStringArray.extend( [ eChallengeCategory.DAILY, eChallengeCategory.TOP_WEEKLY ] )

	return categoryIDtoStringArray
}

void function UpdateChallengeCategorySelection( var rui, bool longName = false, bool hideStories = false )
{
	
	if ( !IsConnected() )
		return

	array<int> categoryIDtoStringArray = GetChallengeCategoryIDArray( hideStories )
	int selectionSlots                 = categoryIDtoStringArray.len()
	

	int newSelectionIndex = ClampInt( fileLevel._challengeCategorySelectionIndex, 0, selectionSlots )
	fileLevel._challengeCategorySelectionIndex = newSelectionIndex

	string category = GetCategoryStringFromType( categoryIDtoStringArray[ newSelectionIndex ], longName )
	RuiSetInt( rui, "selectionSlots", selectionSlots )    
	RuiSetInt( rui, "selectionID", newSelectionIndex ) 
	RuiSetString( rui, "selectionText", category ) 


		RuiSetBool( rui, "isObserver", GetLocalClientPlayer().IsObserver() && GetLocalClientPlayer().GetTeam() == TEAM_SPECTATOR )













































































































}




































void function UpdateClientCategorySelectionIndexFromUI( int selectionIndex )
{
	fileLevel._challengeCategorySelectionIndex = selectionIndex
}































int function GetCategorySelectionSize( bool hideStories = false )
{
	array<int> categoryArray = GetChallengeCategoryIDArray( hideStories )
	return categoryArray.len()
}



void function IncrementCategorySelection(  bool hideStories = false, var button = null )
{
	if ( !IsConnected() )
		return

	int newSelection = (fileLevel._challengeCategorySelectionIndex + 1) % GetCategorySelectionSize( hideStories )
	fileLevel._challengeCategorySelectionIndex = newSelection
}



void function DecrementCategorySelection( bool hideStories = false, var button = null )
{
	if ( !IsConnected() )
		return

	int newSelection = (GetCategorySelectionSize( hideStories ) + fileLevel._challengeCategorySelectionIndex - 1) % GetCategorySelectionSize( hideStories )
	fileLevel._challengeCategorySelectionIndex = newSelection
}



int function GetChallengeDisplayCategory( bool hideStories = false )
{
	
	array<int> categoryIDtoStringArray = GetChallengeCategoryIDArray( hideStories )
	Assert( fileLevel._challengeCategorySelectionIndex < categoryIDtoStringArray.len() )

	if ( fileLevel._challengeCategorySelectionIndex >= categoryIDtoStringArray.len() )
		fileLevel._challengeCategorySelectionIndex = 0

	return categoryIDtoStringArray[ fileLevel._challengeCategorySelectionIndex ]
}



string function GetCategoryStringFromType( int categoryID, bool longName = false )
{
	string appendStr = longName ? "_CHALLENGES" : ""

	if ( IsEventCategory( categoryID ) )
	{
		return "#CATEGORY_EVENT" + appendStr
	}
	else if ( IsStoryCategory( categoryID ) )
	{
		return "#CATEGORY_STORY" + appendStr
	}
	else
	{
		switch( categoryID )
		{
			case eChallengeCategory.BEGINNER:
				return "#CATEGORY_BEGINNER" + appendStr
				break

			case eChallengeCategory.DAILY:
				return "#CATEGORY_DAILY" + appendStr
				break

			case eChallengeCategory.TOP_WEEKLY:
				return "#CATEGORY_TOP_WEEKLY" + appendStr
				break

			case eChallengeCategory.FAVORITES:
				return "#CATEGORY_FAVORITES" + appendStr
				break

			case eChallengeCategory.EVENTSHOP_DAILY_CHALLENGE:
				return "#CATEGORY_REWARD_SHOP_DAILY" + appendStr
				break

			case eChallengeCategory.EVENTSHOP_EVENT_CHALLENGE:
				return "#CATEGORY_REWARD_SHOP_EVENT" + appendStr
				break

			case eChallengeCategory.REWARD_CAMPAIGN:
				return "#UNLOCK_LEGENDS" + appendStr

			case eChallengeCategory.TEMP_UNLOCK:
				return "#UNLOCK_LEGEND"

			case eChallengeCategory.CHALLENGE_TILE:
				return "#CATEGORY_EVENT" + appendStr

		}
	}

	unreachable
}



void function SetSeasonColors( var rui )
{
	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull season = fileLevel.currentSeason.calEventOrNull

	if ( season != null )
	{
		expect ItemFlavor( season )

		RuiSetFloat3( rui, "seasonColor", Season_GetTabBGSelectedCol( season ) )
	}
}






























































































































































































































































































































































































































































































































PlayerChallengesState function GetPlayerChallengesState( entity player = null )
{
	player = AssertLocalOrServerValidPlayer( player )



		return fileLevel.localPlayerChallengesState

}



void function InitPlayerChallengesStateFromPersistence( entity player, PlayerChallengesState pcs )
{
	if ( !IsValid( player ) )
		return

#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return
#endif

	foreach ( ChallengeState ornull cs in pcs.persistentArrayMirror )
	{
		if ( cs == null )
			continue
		expect ChallengeState(cs)
		cs.persistenceIdx = -1
		ItemFlavor badItemFlav
		cs.flav = badItemFlav
	}
	pcs.persistentArrayMirror.clear()
	pcs.persistentArrayMirror.resize( NUM_CHALLENGES_MAX, null )
	pcs.challengeStateMap.clear()





	for ( int persistentArrayIdx = 0 ; persistentArrayIdx < NUM_CHALLENGES_MAX ; persistentArrayIdx++ )
	{
		int guid                        = player.GetPersistentVarAsInt( "challenges[" + persistentArrayIdx + "].guid" )
		ItemFlavor ornull challengeFlav = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )
		if ( challengeFlav == null )
		{
			if ( guid > 0 )
			{








			}
			continue
		}
		expect ItemFlavor( challengeFlav )

		ChallengeState cs
		cs.persistenceIdx                             = persistentArrayIdx
		cs.flav                                       = challengeFlav
		pcs.challengeStateMap[cs.flav] <- cs
		pcs.persistentArrayMirror[persistentArrayIdx] = cs
	}





}



bool function Challenge_IsChallengesStateInititated( entity player )
{





	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	return pcs.challengeStateMap.len() > 0
}






































































































































































































































































































































































































































ItemFlavor function OverrideChallengeIfNecessary( ItemFlavor challenge, entity player )
{
	if ( Kepler_IsPlayerInVariant( player, eKeplerScenario.BATTLEPASS_DAILIES_CHALLENGE_21_0, "set-a" ) )
	{
		if ( Challenge_GetDifficulty( challenge ) == eChallegeDifficulty.EASY )
		{
			return GetItemFlavorByAsset( $"settings/itemflav/challenge/s21exp/play_game_x_legends_any_mode_set_b.rpak"  )
			
			
		} 
	}
	return challenge
}


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#if DEV
void function DEV_RequestCompleteChallengeTier( int guid )
{
	Remote_ServerCallFunction( "DEV_ClientCallback_RequestCompleteChallengeTierByGUID", guid )
}
#endif






































#if DEV
void function PrintChallengePersistence( entity player )
{
	printt( "---------------------------" )
	printt( "CHALLENGES PERSISTENCE DUMP" )
	printt( "---------------------------" )
	printt( "" )
	printt( "dailyExpirationTime:", player.GetPersistentVarAsInt( "dailyExpirationTime" ) )
	printt( "weeklyRecurringLastResetWeek:", player.GetPersistentVarAsInt( "weeklyRecurringLastResetWeek" ) )
	for ( int i = 0 ; i < NUM_CHALLENGE_WEEKS_MAX ; i++ )
		printt( "    ", player.GetPersistentVarAsInt( "weeklyGroupOrder[" + i + "]" ) )
	printt( "" )
	printt( "  Assigned Challenges" )
	printt( "" )

	for ( int i = 0 ; i < NUM_CHALLENGES_MAX ; i++ )
	{
		int guid                    = player.GetPersistentVarAsInt( "challenges[" + i + "].guid" )
		ItemFlavor ornull challenge = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )

		if ( IsValid( challenge ) )
		{
			printt( "   ", i, DEV_ItemFlavor_GetCleanedAssetPath( expect ItemFlavor( challenge ) ) )
			printt( "       marker:", player.GetPersistentVarAsInt( "challenges[" + i + "].statMarker" ) )
			if ( Challenge_IsEitherOr( expect ItemFlavor( challenge ) ) )
				printt( "       marker:", player.GetPersistentVarAsInt( "challenges[" + i + "].statMarkerAlt" ) )
			printt( "       currentTier:", player.GetPersistentVarAsInt( "challenges[" + i + "].currentTier" ) )
		}
		else
		{
			printt( "   ", i, guid )
		}
	}

	printt( "" )
	printt( "  Post Game Challenges" )
	printt( "" )

	printt( "  postgameGrindStartTier:", player.GetPersistentVarAsInt( "postgameGrindStartTier" ) )
	printt( "  postgameGrindStartValue:", player.GetPersistentVarAsInt( "postgameGrindStartValue" ) )

	printt( "" )
	printt( "  Post Game Challenges Any Progress" )
	printt( "" )

	for ( int i = 0 ; i < NUM_CHALLENGES_MAX ; i++ )
	{
		int guid = player.GetPersistentVarAsInt( "postGameChallengesProgress[" + i + "].guid" )
		if ( guid > 0 )
		{
			ItemFlavor ornull challenge = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )
			if ( IsValid( challenge ) )
			{
				printt( "   ", i, DEV_ItemFlavor_GetCleanedAssetPath( expect ItemFlavor( challenge ) ) )
				printt( "       tierMatchStart:", player.GetPersistentVarAsInt( "postGameChallengesProgress[" + i + "].tierMatchStart" ) )
				printt( "       progressMatchStart:", player.GetPersistentVarAsInt( "postGameChallengesProgress[" + i + "].progressMatchStart" ) )
			}
		}
		else
		{
			printt( "   ", i, guid )
		}
	}


	printt( "" )
	printt( "--------------------------" )
	printt( "-- END PERSISTENCE DUMP --" )
	printt( "--------------------------" )
}
#endif



#if DEV
void function DEV_PrintAllChallenges( bool assigned = false, bool currentBPOnly = true )
{
	
	array<ItemFlavor> allChallenges = GetAllChallenges()
	string challengeDump = ""


	if ( assigned )
	{
		allChallenges.clear()
		foreach ( int timeSpan in eChallengeTimeSpanKind )
		{
			if ( timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY )
				continue

			allChallenges.extend( GetAssignedChallengesByTimeSpan( GetLocalClientPlayer(), timeSpan ) )
		}
	}
	else if ( currentBPOnly )




	{
		allChallenges.clear()
		if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
			RefreshCachedSeasonInfo()

		ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull
		if ( activeBattlePass == null )
			return

		expect ItemFlavor( activeBattlePass )

		int group = -1 
		allChallenges.extend( GetBattlePassChallenges( activeBattlePass, eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING, group ) )
		allChallenges.extend( GetBattlePassChallenges( activeBattlePass, eChallengeTimeSpanKind.DAILY, group ) )

		int numWeeks = GetNumBattlePassChallengesWeeks( activeBattlePass )
		for ( int week = 1; week <= numWeeks; week++ )
			allChallenges.extend( GetBattlePassChallenges( activeBattlePass, eChallengeTimeSpanKind.SEASON_WEEKLY, week ) )
	}

	array<string> ref            = []
	array<string> desc           = []
	array<string> xpReward       = []
	array<string> type           = []
	array<string> difficulty     = []
	array<string> gamemode       = []
	array<string> statref        = []
	array<string> matchReq       = []

	int refLen            = 0
	int descLen           = 0
	int xpRewardLen       = 0
	int typeLen           = 0
	int diffLen           = 0
	int modeLen           = 0

	challengeDump += ( "------- ALL CHALLENGES -------\n" )
	foreach ( ItemFlavor challenge in allChallenges )
	{
		if ( !GetCurrentPlaylistVarBool( format( "%s_enabled", ItemFlavor_GetGUIDString( challenge ) ), true ) )
			continue

		string _type = GetEnumString( "eChallengeTimeSpanKind", Challenge_GetTimeSpanKind( challenge ) )

		if ( _type.len() > 16 )
			_type = _type.slice(0, 16)

		int tierCount = Challenge_GetTierCount( challenge )
		for ( int i = 0 ; i < tierCount ; i++ )
		{
			string _ref  = (i == 0) ? DEV_ItemFlavor_GetCleanedAssetPath( challenge ) : ""


				string _desc = Challenge_GetDescription( challenge, i )



			_desc = replace( _desc, "`1", "" )
			_desc = replace( _desc, "`0", "" )
			_desc = replace( _desc, "\n", " " )
			if ( tierCount > 1 )
				_desc = (i + 1) + ") " + _desc

			if ( _desc.len() > 64 )
				_desc = _desc.slice(0, 64) + "..."

			if ( Challenge_IsEitherOr( challenge ) )
			{
				if ( _desc.len() > 30 )
					_desc = _desc.slice(0, 30) + "..."


					string _descAlt = Challenge_GetDescription( challenge, i, true )



				_descAlt = replace( _desc, "`1", "" )
				_descAlt = replace( _desc, "`0", "" )
				_descAlt = replace( _desc, "\n", " " )
				if ( tierCount > 1 )
					_descAlt = (i + 1) + ") " + _descAlt

				if ( _descAlt.len() > 30 )
					_descAlt = _descAlt.slice(0, 30) + "..."

				_desc = _desc + " OR " + _descAlt
			}

			int stars = Challenge_GetBPStarsReward( challenge, i )
			string _xpReward
			if ( stars == 0 ) 
				_xpReward       = format( "1BP LVL" )
			else if ( stars == 1 )
				_xpReward       = format( "%d  STAR", Challenge_GetBPStarsReward( challenge, i ) )
			else if ( stars > 1 && stars < 10 )
				_xpReward       = format( "%d  STARS", Challenge_GetBPStarsReward( challenge, i ) )
			else if ( stars >= 10 )
				_xpReward       = format( "%d STARS", Challenge_GetBPStarsReward( challenge, i ) )

			string _diff = ""
			int _diffInt = Challenge_GetDifficulty( challenge )
			foreach ( key, val in eChallegeDifficulty )
			{
				if ( val == _diffInt )
					_diff = key
			}


				string _mode = Localize( GAME_MODE_NAME[Challenge_GetGameMode( challenge )] )




			if ( Challenge_IsEitherOr( challenge ) )
			{

					string _modeAlt = Localize( GAME_MODE_NAME[Challenge_GetGameMode( challenge, true )] )





				Assert ( _mode != _modeAlt, string(ItemFlavor_GetAsset( challenge )) + " uses the SAME game mode - " + _mode + " - for both halves of Either/Or. This is not yet supported." )
				Assert ( _mode.tolower().find("any") == -1 && _modeAlt.tolower().find("any") == -1, string(ItemFlavor_GetAsset( challenge )) + " uses 'ANY' mode for one half. This is not yet supported." )

				if ( _mode.len() > 6 )
					_mode = _mode.slice(0, 6)

				if ( _modeAlt.len() > 6 )
					_modeAlt = _modeAlt.slice(0, 6)

				_mode = _mode + " OR " + _modeAlt
			}

			array<string> statRefs = Challenge_GetStatRefs( challenge, i )
			string _stat = statRefs[0]
			if ( _stat.find( "SAID" ) != -1 )
			{
				int saidPos  = _stat.find( "SAID" )
				string start = _stat.slice( 0, saidPos )
				string end   = _stat.slice( saidPos + GUID_SAMPLE_STRING.len() )
				_stat = start + "x" + statRefs.len() + end
			}
			_stat = _stat.slice( 6 ) 

				if ( Challenge_IsEitherOr( challenge ) )
				{
					array<string> statRefsAlt = Challenge_GetStatRefs( challenge, i, true )
					string _statAlt = statRefsAlt[0]
					if ( _statAlt.find( "SAID" ) != -1 )
					{
						int saidPos  = _statAlt.find( "SAID" )
						string start = _statAlt.slice( 0, saidPos )
						string end   = _statAlt.slice( saidPos + GUID_SAMPLE_STRING.len() )
						_statAlt = start + "x" + statRefsAlt.len() + end
					}
					_statAlt = _statAlt.slice( 6 ) 

					_stat = _stat + " OR " + _statAlt
				}

			string _matchreq = "       "
			if ( Challenge_IsSingleMatch( challenge, i ) )
				_matchreq = "SINGLE "

			ref.append( _ref )
			desc.append( _desc )
			xpReward.append( _xpReward )
			type.append( i == 0 ? _type : "" )
			difficulty.append( _diff )
			gamemode.append( _mode )
			statref.append( _stat )
			matchReq.append( _matchreq )


			if ( _ref.len() > refLen )
				refLen = _ref.len()
			if ( _desc.len() > descLen )
				descLen = _desc.len()
			if ( _xpReward.len() > xpRewardLen )
				xpRewardLen = _xpReward.len()
			if ( _type.len() > typeLen )
				typeLen = _type.len()
			if ( _diff.len() > diffLen )
				diffLen = _diff.len()
			if ( _mode.len() > modeLen )
				modeLen = _mode.len()
		}
	}

	Assert( desc.len() == ref.len() && xpReward.len() == ref.len() && type.len() == ref.len() )

	ref.insert( 0, "ITEM FLAVOR NAME" )
	desc.insert( 0, "DESCRIPTION" )
	xpReward.insert( 0, "STARS" )
	type.insert( 0, "TYPE" )
	difficulty.insert( 0, "DIFFICULTY" )
	gamemode.insert( 0, "MODE" )
	statref.insert( 0, "STATREF" )
	matchReq.insert( 0, "MTCHRQ" )

	int weeklyCounter = 1 
	int weeklyNum = 1 
	for ( int i = 0 ; i < ref.len() ; i++ )
	{
		string _ref            = ref[i]
		string _desc           = desc[i]
		string _xpReward       = xpReward[i]
		string _type           = type[i]
		string _diff           = difficulty[i]
		string _mode           = gamemode[i]
		string _stat           = statref[i]
		string _matchreq	   = matchReq[i]

		if ( _type == "SEASON_WEEKLY" )
		{
			if ( weeklyNum > NUM_WEEKLY_CHALLENGES_MAX )
			{
				weeklyNum = 1
				weeklyCounter++
			}

			if ( weeklyNum == 1 )
			{
				challengeDump += ( format( "WEEK #%d\n", weeklyCounter ) )
			}

			weeklyNum++

		}

		while( _ref.len() < refLen )
			_ref += " "
		while( _desc.len() < descLen )
			_desc += " "
		while( _xpReward.len() < xpRewardLen )
			_xpReward += " "
		while( _type.len() < typeLen )
			_type += " "
		while( _diff.len() < diffLen )
			_diff += " "
		while( _mode.len() < modeLen )
			_mode += " "

		challengeDump += ( format( "%s  %s  %s  %s  %s  %s  %s  %s\n", _ref, _desc, _xpReward, _type, _diff, _mode, _matchreq, _stat ) )
	}

	challengeDump += ( "------------------------------\n" )
	challengeDump += ( "  Total Challenges:" + string( allChallenges.len() ) + "\n" )
	challengeDump += ( "------------------------------\n" )

	DEV_PrintChallengeDataToFile( challengeDump )
}

void function DEV_PrintChallengeDataToFile( string out )
{
	const string DEBUG_OUTPUT_PATH = "../../dumps/" 
	printt( "Dumping Challenge data to depot/r5dev/dumps/challenge_data_dump.txt" )
	DevTextBufferClear()
	DevTextBufferWrite( out )
	DevTextBufferDumpToFile( DEBUG_OUTPUT_PATH + "challenge_data_dump.txt" )
	DevTextBufferClear()
}
#endif



array<ItemFlavor> function GetAssignedChallengesByTimeSpan( entity player, int timeSpan, int weekIndex = -1, ItemFlavor ornull specificEvent = null )
{
	Assert( timeSpan >= 0 && timeSpan < eChallengeTimeSpanKind.len() )
	Assert( (timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY) == (weekIndex > 0) )

	PlayerChallengesState pcs = GetPlayerChallengesState( player )

	array<ItemFlavor> results
	foreach ( ItemFlavor challengeFlav, ChallengeState cs in pcs.challengeStateMap )
	{
		if ( Challenge_GetTimeSpanKind( challengeFlav ) == timeSpan )
		{
			if ( !IsChallengePlaylistEnabled( challengeFlav ) )
				continue

			if ( timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY && Challenge_GetWeekNumber( challengeFlav ) != weekIndex )
				continue

			if ( timeSpan == eChallengeTimeSpanKind.EVENT && specificEvent != null )
			{
				expect ItemFlavor( specificEvent )
				int[1] OUT_nextRefreshUnixTime

				if( ItemFlavor_GetType( specificEvent ) == eItemType.calevent_story_challenges )
				{
					if( !StoryEvent_GetCurrentChapterChallenges( player, specificEvent ).contains( challengeFlav ) )
						continue
				}
				else
				{
					if ( !BuffetEvent_GetDailyChallenges_TEMP( specificEvent ).contains( challengeFlav ) &&
						 !BuffetEvent_GetCurrentChallenges_EXCLUDING_DAILIES( specificEvent, OUT_nextRefreshUnixTime ).contains( challengeFlav ) )
						continue
				}
			}

			results.append( challengeFlav )
		}
	}
	return results
}

bool function IsChallengePlaylistEnabled( ItemFlavor challengeFlav )
{
	if ( fileLevel.hasPlaylistChallengeOverrides == false )
		return true

	return GetCurrentPlaylistVarBool( format( "%s_enabled", ItemFlavor_GetGUIDString( challengeFlav ) ), true )
}























































































void function UpdateChallengeRowsRui( entity player, array<ItemFlavor> challenges, array<var> rowRuis = [] )
{
	
	Assert( challenges.len() <= NUM_DAILY_CHALLENGES, "total:" + challenges.len() + " Are Event Challenges set to show a set of more than 5 challenges in the lobby?" )

	foreach ( int rowIdx, var rui in rowRuis )
	{
		if ( challenges.len() <= rowIdx )
		{
			
			RuiSetBool( rui, "isVisible", false )
			continue
		}

		RuiSetBool( rui, "isVisible", true )


			
			RuiSetInt( rui, "rowIndex", rowIdx )


		ItemFlavor challenge     = challenges[ rowIdx ]

		int tierCount            = Challenge_GetTierCount( challenge ) 
		int activeTier           = Challenge_GetCurrentTier( player, challenge ) 
		bool isChallengeComplete = Challenge_IsComplete( player, challenge )     
		if ( isChallengeComplete )
			activeTier = tierCount - 1 
		bool challengeIsInfinite = Challenge_LastTierIsInfinite( challenge )    

		int maxRewardIcons      = MAX_REWARDS_PER_CHALLENGE_TIER 

		int gameMode
		string description
		int progress
		int goal

		bool isEitherOrChallenge = Challenge_IsEitherOr( challenge )


		if( isEitherOrChallenge )
		{
			array<int> gameModes = Challenge_EitherOr_GetGameModes( challenge )
			array<string> descriptions = Challenge_EitherOr_GetDescriptions( challenge )
			array<int> progression = Challenge_EitherOr_GetProgressValues( player, challenge )
			array<int> goals = Challenge_EitherOr_GetGoalVals( challenge )

			bool playerIsPlayingBR = Stats_CurrentModeIsSurvival()
			int challengeIndexToUse = 0
			foreach( int idx, int data in gameModes)
			{
				string tag = Challenge_GetGameModeTag( data )
				if( ( tag != GAME_MODE_TAG[eChallengeGameMode.BATTLE_ROYALE] && !playerIsPlayingBR ) ||
					( tag == GAME_MODE_TAG[eChallengeGameMode.BATTLE_ROYALE] && playerIsPlayingBR )
				)
				{
					challengeIndexToUse = idx
				}
			}

			gameMode = gameModes[challengeIndexToUse]
			description = descriptions[challengeIndexToUse]
			progress = progression[challengeIndexToUse]
			goal = goals[challengeIndexToUse]
		}
		else
		{
			gameMode = Challenge_GetGameMode( challenge )
			description = Challenge_GetDescription( challenge, activeTier )
			progress = Challenge_GetProgressDisplayValue( player, challenge, activeTier )
			goal = Challenge_GetGoalDisplayVal( challenge, activeTier )
		}

		SetSeasonColors( rui ) 

		vector rewardColor = <1, 1, 1> 
		int timeSpan       = Challenge_GetTimeSpanKind( challenge )
		if ( timeSpan == eChallengeTimeSpanKind.EVENT )
		{
			ItemFlavor eventFlav = Challenge_GetSource( challenge )
			rewardColor = BuffetEvent_GetRewardIconCol( eventFlav )
		}
		RuiSetFloat3( rui, "rewardColor", rewardColor )

		RuiSetString( rui, "challengeTierDesc", description )

#if DEV
			bool doDebug = (InputIsButtonDown( KEY_LSHIFT ) && InputIsButtonDown( KEY_LCONTROL )) || (InputIsButtonDown( BUTTON_TRIGGER_LEFT_FULL ) && InputIsButtonDown( BUTTON_B ))
			if ( doDebug )
			{
				printt( "#challenge --", DEV_ItemFlavor_GetCleanedAssetPath( challenge ) )
				RuiSetString( rui, "challengeTierDesc", DEV_ItemFlavor_GetCleanedAssetPath( challenge ) + " | " + activeTier )
			}
#endif


		RuiSetInt( rui, "challengeTierProgress", progress )
		RuiSetInt( rui, "challengeTierGoal", goal )
		RuiSetBool( rui, "challengeCompleted", isChallengeComplete )

		RuiSetString( rui, "challengeModeTag", Challenge_GetGameModeTag( gameMode ) )
		RuiSetFloat3( rui, "challengeModeTagColor", Challenge_GetGameModeTagColor( gameMode ) )

		bool showDiagonalWeapons                  = false 
		bool shouldUseBadgeRuis                   = false 
		array<ChallengeRewardDisplayData> rewards = GetChallengeRewardDisplayData( challenge, activeTier, showDiagonalWeapons, shouldUseBadgeRuis, false )
		if ( rewards.len() >= maxRewardIcons )
			Warning( "Too many rewards for one challenge: " + string(ItemFlavor_GetAsset( challenge )) )

		for ( int rewardIdx = 0; rewardIdx < maxint( rewards.len(), maxRewardIcons ); rewardIdx++ )
		{
			string ruiArgPrefix = "challengeTierReward" + rewardIdx
			if ( rewardIdx < rewards.len() )
				SetRuiArgsForChallengeReward( rui, ruiArgPrefix, rewards[ rewardIdx ] )
			else
				SetRuiArgsForChallengeReward( rui, ruiArgPrefix, null )
		}
	}
}

















































































































































































































































































































































void function UpdateChallengeBoxBPLevelBadge( entity player, var rui )
{
	EHI playerEHI                      = ToEHI( player )
	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull

	if ( activeBattlePass != null && rui != null )
	{
		expect ItemFlavor( activeBattlePass )

		int currentBattlePassXP  = GetPlayerBattlePassXPProgress( playerEHI, activeBattlePass, false )
		int battlePassLevel      = GetBattlePassLevelForXP( activeBattlePass, currentBattlePassXP ) + 1
		bool battlePassCompleted = battlePassLevel >= (GetBattlePassMaxLevelIndex( activeBattlePass ) + 1)

		SetBattlePassLevelBadgeForLevel( player, rui, activeBattlePass, battlePassLevel, battlePassCompleted )
	}
}
void function SetBattlePassLevelBadgeForLevel( entity player, var rui, ItemFlavor activeBattlePass, int battlePassLevel, bool battlePassCompleted )
{
	RuiDestroyNestedIfAlive( rui, "headerBadgeHandle" )

	EHI playerEHI                        = ToEHI( player )
	ItemFlavor headerBadge               = GetBattlePassProgressBadge( activeBattlePass )
	int ornull overrideDataIntegerOrNull = battlePassLevel

	ItemFlavor dummy
	CreateNestedGladiatorCardBadge( rui, "headerBadgeHandle", playerEHI, headerBadge, 0, dummy, overrideDataIntegerOrNull )

	RuiSetBool( rui, "battlePassCompleted", battlePassCompleted )

	if ( battlePassCompleted )
		RuiSetImage( rui, "headerImage", BATTLE_COMPLETED_HEADER_IMAGE )
	else
		RuiSetImage( rui, "headerImage", $"" )
}



void function UpdateChallengeBoxHeaderBPProgress( entity player, var rui )
{
	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull

	if ( activeBattlePass != null )
	{
		expect ItemFlavor( activeBattlePass )

		if ( BattlePass_UseStarsToProgress( activeBattlePass ) )
		{
			ItemFlavor ornull starChallenge = GetBattlePassRecurringStarChallenge( activeBattlePass )

			if ( starChallenge != null )
			{
				expect ItemFlavor( starChallenge )

				if ( Challenge_IsAssigned( player, starChallenge ) )
				{
					SetSeasonColors( rui )

					int tier     = Challenge_GetCurrentTier( player, starChallenge )
					int progress = Challenge_GetProgressValue( player, starChallenge, tier )
					RuiSetInt( rui, "bpStarCount", progress )
					RuiSetBool( rui, "showBPProgress", true )
				}
			}
		}
	}
}












































































































































































































































































































































































































































bool function Challenge_CanRerollChallenge( ItemFlavor challenge )
{
	bool isRerollEnabled = Challenge_IsRerollEnabled( challenge ) 
	if ( !isRerollEnabled )
		return false

	
	if ( Challenge_GetTimeSpanKind( challenge ) != eChallengeTimeSpanKind.DAILY )
		return false

	
	if ( Challenge_GetDifficulty( challenge ) == eChallegeDifficulty.VERY_EASY )
		return false

	array<ItemFlavor> dailyChallengePool = clone GetAllChallengesOfTimespan( eChallengeTimeSpanKind.DAILY )
	array<ItemFlavor> rerollPool

	int diff = Challenge_GetDifficulty( challenge )

	foreach ( ch in dailyChallengePool )
	{
		if ( Challenge_GetDifficulty( ch ) == diff )
			rerollPool.append( ch )
	}

	if ( rerollPool.len() <= 1 )
		return false

	return true
}


void function SetRuiArgsForChallengeTier( var rui, string ruiArgPrefix, ItemFlavor challenge, int ornull displayTierIdx, int maxRewardIcons, int maxExtraRewardIcons, bool isEitherOrChallenge = false )
{
	
	

	entity player = GetLocalClientPlayer()
	string p      = ruiArgPrefix

	int challengeTierCount   = Challenge_GetTierCount( challenge )
	bool challengeIsInfinite = Challenge_LastTierIsInfinite( challenge )
	int currentTierIdx       = Challenge_GetCurrentTier( player, challenge )
	if ( displayTierIdx == null )
		displayTierIdx = currentTierIdx
	expect int(displayTierIdx)
	displayTierIdx = ClampInt( displayTierIdx, 0, challengeTierCount - 1 )

	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull season = fileLevel.currentSeason.calEventOrNull

	array<string> descriptions
	array<int> progression
	array<int> goals

	if ( isEitherOrChallenge )
	{
		descriptions = Challenge_EitherOr_GetDescriptions( challenge )
		progression = Challenge_EitherOr_GetProgressValues( player, challenge )
		goals = Challenge_EitherOr_GetGoalVals( challenge )
	}
	else
	{
		descriptions.append( Challenge_GetDescription( challenge, displayTierIdx ) )
		progression.append( Challenge_GetProgressDisplayValue( player, challenge, displayTierIdx ) )
		goals.append( Challenge_GetGoalDisplayVal( challenge, displayTierIdx )  )
	}

	
	
	
	

	foreach( int idx, string description in descriptions)
	{
		string modifier = ( idx > 0 ) ? "Alt": ""
		RuiSetString( rui, p + modifier + "TierDesc", description )
	}

	foreach( int idx, int progress in progression)
	{
		string modifier = ( idx > 0 ) ? "Alt": ""
		RuiSetInt( rui, p + modifier + "TierProgress", progress )
	}

	foreach( int idx, int goal in goals)
	{
		string modifier = ( idx > 0 ) ? "Alt": ""
		RuiSetInt( rui, p + modifier + "TierGoal", goal )
	}

	RuiSetInt( rui, p + "TiersCount", challengeTierCount )
	RuiSetBool( rui, p + "IsInfinite", challengeIsInfinite )
	RuiSetInt( rui, p + "ActiveTierIdx", currentTierIdx )
	RuiSetBool( rui, p + "Completed", Challenge_IsComplete( player, challenge ) )
	SetSeasonColors( rui )

	bool showDiagonalWeapons                  = false
	bool shouldUseBadgeRuis                   = false
	array<ChallengeRewardDisplayData> rewards = GetChallengeRewardDisplayData( challenge, displayTierIdx, showDiagonalWeapons, shouldUseBadgeRuis, true )

	int bestRarityTier = -1
	for ( int rewardIdx = 0; rewardIdx < maxint( rewards.len(), maxRewardIcons ); rewardIdx++ )
	{
		if ( rewardIdx < rewards.len() )
		{
			ChallengeRewardDisplayData crdd = rewards[rewardIdx]
			bestRarityTier = maxint( bestRarityTier, crdd.rarityTier )
			if ( rewardIdx >= maxRewardIcons )
			{
				if ( maxRewardIcons > 0 )
					Warning( "Too many rewards for one challenge tier. RUI will not display reward with icon: %s", string(crdd.icon) )
				continue 
			}

			SetRuiArgsForChallengeReward( rui, format( "%sTierReward%d", p, rewardIdx ), crdd )

			continue 
		}
		else if ( rewardIdx >= maxRewardIcons )
			continue 

		
		SetRuiArgsForChallengeReward( rui, format( "%sTierReward%d", p, rewardIdx ), null )
	}

	RuiSetInt( rui, p + "TierBestRarityTier", bestRarityTier )
}

void function SetRuiArgsForChallengeReward( var rui, string ruiArgPrefix, ChallengeRewardDisplayData ornull crdd )
{
	
	string p = ruiArgPrefix

	RuiDestroyNestedIfAlive( rui, format( "%sUi", p ) )

	if ( crdd == null )
	{
		RuiSetInt( rui, format( "%sStyle", p ), -1 )
		RuiSetInt( rui, format( "%sRarityTier", p ), -1 )
		RuiSetImage( rui, format( "%sIcon", p ), $"" )
		RuiSetString( rui, format( "%sTinyLabelText", p ), "" )
		RuiSetInt( rui, format( "%sTinyLabelPlacementStyle", p ), -1 )
		return
	}
	expect ChallengeRewardDisplayData(crdd)
	RuiSetInt( rui, format( "%sStyle", p ), crdd.style )
	RuiSetInt( rui, format( "%sRarityTier", p ), crdd.rarityTier )
	RuiSetImage( rui, format( "%sIcon", p ), crdd.icon )
	if ( crdd.badgeFlav != null )
	{
		CreateNestedGladiatorCardBadge( rui, format( "%sUi", p ), LocalClientEHI(),
			expect ItemFlavor(crdd.badgeFlav), -1, null, crdd.badgeTier, false ) 
	}
	RuiSetString( rui, format( "%sTinyLabelText", p ), crdd.tinyLabelText )
	RuiSetInt( rui, format( "%sTinyLabelPlacementStyle", p ), crdd.tinyLabelPlacementStyle )

	RuiSetBool( rui, "showMythicIndicator", crdd.isMythicSkin )
	if ( crdd.isMythicSkin )
		RuiSetInt( rui, "activeMythicTier", crdd.badgeTier )
}

void function SetRuiArgsForMythicSkinChallenge( var rui, int activeTier )
{
	RuiSetInt( rui, "activeMythicTier", activeTier )
}

array<ChallengeRewardDisplayData> function GetChallengeRewardDisplayData( ItemFlavor challenge, int tierIdx, bool showDiagonalWeapons, bool shouldUseBadgeRuis, bool tinyLabelToTheLeft )
{
	array<ChallengeRewardDisplayData> displayData = []

	ItemFlavorBag rewards = Challenge_GetRewards( challenge, tierIdx )

	if ( Challenge_GetTimeSpanKind( challenge ) == eChallengeTimeSpanKind.EVENTSHOP_DAILY_CHALLENGE )
	{
		foreach ( int itemIndex, ItemFlavor flav in rewards.flavors )
		{
			ChallengeRewardDisplayData data
			data.flav = flav
			data.originalQuantity = rewards.quantities[itemIndex]
			data.displayQuantity = data.originalQuantity
			data.style = eChallengeRewardStyle.ITEM_GENERAL
			data.rarityTier = ItemFlavor_GetQuality( flav, eRarityTier.COMMON )
			data.icon = CustomizeMenu_GetRewardButtonImage( flav )
			data.tinyLabelPlacementStyle = tinyLabelToTheLeft ? eTinyLabelPlacementStyle.LEFT : eTinyLabelPlacementStyle.CENTER
			data.tinyLabelText = Localize( "#PLUS_N", FormatAndLocalizeNumber( "1", float( data.displayQuantity ), false ) )

			displayData.append( data )
		}

		return displayData
	}

	foreach ( int itemIdx, ItemFlavor flav in rewards.flavors )
	{
		ChallengeRewardDisplayData crdd
		crdd.flav                    = flav
		crdd.originalQuantity        = rewards.quantities[itemIdx]
		crdd.displayQuantity         = crdd.originalQuantity
		crdd.style                   = eChallengeRewardStyle.ITEM_GENERAL
		crdd.rarityTier              = ItemFlavor_GetQuality( flav, eRarityTier.COMMON )
		crdd.icon                    = CustomizeMenu_GetRewardButtonImage( flav )
		crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.NONE

		if ( ItemFlavor_GetType( flav ) == eItemType.voucher )
		{
			bool foundQuantity = false
			if ( Voucher_GetEffectStatRef( flav ) != null && Voucher_GetEffectStatAmount( flav ) > 0 )
			{
				crdd.tinyLabelPlacementStyle = tinyLabelToTheLeft ? eTinyLabelPlacementStyle.LEFT : eTinyLabelPlacementStyle.CENTER
			}

			if ( Voucher_GetEffectBattlepassStars( flav ) > 0 )
			{
				crdd.displayQuantity *= Voucher_GetEffectBattlepassStars( flav )
				if ( tinyLabelToTheLeft )
				{
					crdd.tinyLabelText           = Localize( "#PLUS_N", FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false ) )
					crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.LEFT
				}
				else
				{
					crdd.tinyLabelText           = FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false )
					crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.CENTER
				}
			}

			if ( Voucher_GetEffectBattlepassLevels( flav ) > 0 )
			{
				if ( !foundQuantity )
				{
					foundQuantity = true
					crdd.displayQuantity *= Voucher_GetEffectBattlepassLevels( flav )
					crdd.icon     = $"rui/menu/challenges/challenges_icon_levelup"

					
					crdd.tinyLabelPlacementStyle = tinyLabelToTheLeft ? eTinyLabelPlacementStyle.LEFT : eTinyLabelPlacementStyle.NONE
					crdd.tinyLabelText           = tinyLabelToTheLeft ? Localize( "#PLUS_N", FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false ) ) : ""
				}
				else
				{
					Warning( "Challenge reward voucher gives multiple kinds of points -- this isn't yet supported properly!" )
				}
			}

			if ( Voucher_GetEffectAccountXP( flav ) > 0 )
			{
				if ( !foundQuantity )
				{
					foundQuantity = true
					crdd.displayQuantity *= Voucher_GetEffectAccountXP( flav )

					if ( tinyLabelToTheLeft )
					{
						crdd.tinyLabelText           = Localize( "#PLUS_N", FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false ) )
						crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.LEFT
					}
					else
					{
						crdd.tinyLabelText           = FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false )
						crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.CENTER
					}
				}
				else
				{
					Warning( "Challenge reward voucher gives multiple kinds of points -- this isn't yet supported properly!" )
				}
			}

			if ( Voucher_GetEffectStatRef( flav ) != null && Voucher_GetEffectStatAmount( flav ) != 0 )
			{
				if ( !foundQuantity )
				{
					foundQuantity = true
					crdd.displayQuantity *= Voucher_GetEffectStatAmount( flav )

					asset voucherImage = ItemFlavor_GetIcon( flav )
					if ( voucherImage != $"" )
						crdd.icon = voucherImage
				}
				else
				{
					Warning( "Challenge reward voucher gives multiple kinds of points -- this isn't yet supported properly!" )
				}
			}
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.weapon_skin )
		{
			if ( showDiagonalWeapons )
			{
				crdd.style = eChallengeRewardStyle.ITEM_WEAPON_SKIN
				crdd.icon  = WeaponItemFlavor_GetHudIcon( WeaponSkin_GetWeaponFlavor( flav ) )
			}
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.gladiator_card_badge )
		{
			if ( shouldUseBadgeRuis )
			{
				crdd.style     = eChallengeRewardStyle.ITEM_BADGE
				crdd.icon      = $""
				crdd.badgeFlav = flav
			}

			
			int badgeTier = 0
			for ( int prevTierIdx = 0; prevTierIdx < tierIdx; prevTierIdx++ )
			{
				ItemFlavorBag prevTierRewards = Challenge_GetRewards( challenge, prevTierIdx )
				if ( prevTierRewards.flavors.contains( flav ) )
					badgeTier++
			}

			crdd.badgeTier = badgeTier
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.account_currency || ItemFlavor_GetType( flav ) == eItemType.apex_coins )
		{
			
			crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.BOTTOM
			crdd.tinyLabelText           = FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false )
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.character_skin )
		{
			crdd.isMythicSkin = Challenge_GetTimeSpanKind( challenge ) == eChallengeTimeSpanKind.MYTHIC
			if ( crdd.isMythicSkin )
				crdd.badgeTier = tierIdx + 1
		}

		if ( crdd.tinyLabelText == "" )
			crdd.tinyLabelText = crdd.displayQuantity > 1 ? FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false ) : ""

		displayData.append( crdd )
	}

	











	return displayData
}




















































































































































































































string function Challenge_GetDescription( ItemFlavor challenge, int tier, bool getAlt = false )
{
	int tierCount = Challenge_GetTierCount( challenge )
	Assert( tier >= 0 && tier < tierCount , "Tier: " + tier + ", tierCount: " + tierCount )

	int challengeGoal = Challenge_GetGoalVal( challenge, tier, getAlt )

	var tierData = Challenge_GetTierDataBlock( challenge, tier )

	string challengeDisplay = FormatAndLocalizeNumber( "1", float( Challenge_GetGoalDisplayVal( challenge, tier, getAlt ) ), true )

	string tierDescription = getAlt ? GetSettingsBlockString( tierData, "descriptionAlt" ) : GetSettingsBlockString( tierData, "description" )
	if ( getAlt && tierDescription == "" )
		tierDescription = GetSettingsBlockString( tierData, "description" )

	string ornull result = null

	array<ItemFlavor> characterFlavors = Challenge_GetCharacterItemFlavors( challenge, tier )

	switch ( characterFlavors.len() )
	{
		case 0:
			result = Localize( tierDescription, challengeDisplay )
			break

		case 1:
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ) )
			break

		case 2:
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[1] ) )  )
			break

		case 3:
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[1] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[2] ) )  )
			break

		case 4:
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[1] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[2] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[3] ) )  )
			break

		default:
			Assert( false, "Invalid number of character flavors referened in challenge " + string(ItemFlavor_GetAsset( challenge )) + " tier " + tier )
			break
	}

	Assert( result != null )
	return expect string(result)
}










































































































































































































































































































bool function IsChallengeTierComplete( entity player, ItemFlavor challenge, int tier, bool getAlt = false )
{
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challenge ) )

	int goalVal  = Challenge_GetGoalVal( challenge, tier, getAlt ? true : false )
	int progress = Challenge_GetProgressValue( player, challenge, tier, getAlt ? true : false )
	return progress >= goalVal
}




































































































































array<ItemFlavor> function GetAllChallenges()
{
	
	return GetAllItemFlavorsOfType( eItemType.challenge )
}



bool function HasChallengeForCharacter( entity player, ItemFlavor character )
{
	foreach ( ItemFlavor challenge in GetAllChallenges() )
	{
		if( !Challenge_IsAssigned( player, challenge ) )
			continue

		if( Challenge_GetTierCount( challenge ) <= 0 || Challenge_IsComplete(player, challenge) )
			continue

		array<ItemFlavor> charPrereq = Challenge_GetCharacterItemFlavors( challenge, 0 )

		foreach ( char in charPrereq )
		{
			if( char == character )
				return true
		}
	}

	return false
}




bool function HasChallengeForWeapon( entity player, array<string> lootTags )
{
	foreach ( ItemFlavor challenge in GetAllChallenges() )
	{
		if( !Challenge_IsAssigned( player, challenge ) )
			continue

		if( Challenge_GetTierCount( challenge ) <= 0 || Challenge_IsComplete(player, challenge) )
			continue

		int currentTier = Challenge_GetCurrentTier( player, challenge )

		array<string> statRefs = Challenge_GetStatRefs( challenge, currentTier, false )

		foreach ( string statRef in statRefs )
		{
			foreach ( string lootTag in lootTags )
			{
				if( statRef.find( lootTag ) >= 0 )
					return true
			}

		}
	}

	return false
}




array<ItemFlavor> function GetAllChallengesOfTimespan( int timeSpan, int weekIndex = -1 )
{
	Assert( timeSpan >= 0 && timeSpan < eChallengeTimeSpanKind.len() )
	Assert( (timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY) == (weekIndex > 0) )

	array<ItemFlavor> results = []

	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	
	if ( fileLevel.currentSeason.battlePassOrNull == null && timeSpan != eChallengeTimeSpanKind.MYTHIC )
		return results

	switch ( timeSpan )
	{
		case eChallengeTimeSpanKind.BEGINNER:
		case eChallengeTimeSpanKind.EVENT:
		case eChallengeTimeSpanKind.MYTHIC:
			foreach ( ItemFlavor challenge in GetAllChallenges() )
			{
				if ( Challenge_GetTimeSpanKind( challenge ) == timeSpan )
				{
					if ( IsChallengePlaylistEnabled( challenge ) )
						results.append( challenge )
				}
			}
			break

		case eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING:

				ItemFlavor ornull npp = NPP_GetNPP()
				if ( npp != null )
				{
					expect ItemFlavor( npp )
					ItemFlavor cardChallenge = expect ItemFlavor( NPP_GetBattlePassRecurringCardChallenge( npp ) )

					results.append( cardChallenge )
				}

		case eChallengeTimeSpanKind.SEASON_WEEKLY:
		case eChallengeTimeSpanKind.DAILY:
			ItemFlavor pass = expect ItemFlavor( fileLevel.currentSeason.battlePassOrNull )
			foreach ( challenge in GetBattlePassChallenges( pass, timeSpan, weekIndex ) )
			{
				if ( IsChallengePlaylistEnabled( challenge ) )
					results.append( challenge )
			}
			break
	}

	return results
}













































































































































































































































































































































































#if DEV
string function AddPadding( string str, int minWidth = 8 )
{
	int len = str.len()
	while ( len < minWidth )
	{
		str = str + " "
		len++
	}
	return str
}
#endif


int function Challenge_GetCurrentTier( entity player, ItemFlavor flavor )
{
#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return 0
#endif
	
	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	Assert( flavor in pcs.challengeStateMap, "Called Challenge_GetCurrentTier for challenge " + string(ItemFlavor_GetAsset( flavor )) + " but it was not assigned to the player " + string(player) )

	if ( !Challenge_IsAssigned( player, flavor ) )
	{
		
		return 0
	}

	ChallengeState cs = pcs.challengeStateMap[flavor]
	return player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].currentTier" )
}



int function Challenge_GetActiveTier( entity player, ItemFlavor flavor )
{
	if ( Challenge_IsComplete( player, flavor ) )
	{
		return Challenge_GetTierCount( flavor ) - 1
	}
	return Challenge_GetCurrentTier( player , flavor )
}



bool function Challenge_IsAssigned( entity player, ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	return (flavor in pcs.challengeStateMap)
}




bool function Challenge_IsComplete( entity player, ItemFlavor flavor )
{
	int currentTier = Challenge_GetCurrentTier( player, flavor )
	int tierCount   = Challenge_GetTierCount( flavor )
	Assert( currentTier <= tierCount, "Player has a higher current tier than should be possible for Challenge " + string(ItemFlavor_GetAsset( flavor )) )
	return (currentTier == tierCount)
}



bool function Challenge_IsAllComplete( entity player, array< ItemFlavor > challengeFlavs )
{
	foreach ( ItemFlavor challenge in challengeFlavs )
	{
		if ( !Challenge_IsComplete( player, challenge ) )
		{
			return false
		}
	}

	return true
}



int function Challenge_CountComplete( entity player, array< ItemFlavor > challenges )
{
	int count = 0
	foreach ( ItemFlavor challenge in challenges )
	{
		if ( Challenge_IsComplete( player, challenge ) )
		{
			count += 1
		}
	}

	return count
}



bool function Challenge_IsAutogen( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "autoGenerateStatBacker" )
}



int function Challenge_GetRequestedAutogenSlotFromFlavor( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( Challenge_IsAutogen( flavor ) )

	string key = GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "autogenSlot" )
	Assert( key in eAutogenStatSlots, format( "Challenge %s has invalid autogen slot: %s", string( ItemFlavor_GetAsset( flavor ) ), key ) )

	return eAutogenStatSlots[ key ]
}



int function Challenge_GetScriptHookForAutogenChallenge( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( Challenge_IsAutogen( flavor ) )

	string key = GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "autogenScriptHook" )
	Assert( key in eAutogenStatHooks, format( "Challenge %s has invalid autogen script hook: %s", string( ItemFlavor_GetAsset( flavor ) ), key ) )

	return eAutogenStatHooks[ key ]
}



int function Challenge_GetTierCount( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	var settingsBlock = ItemFlavor_GetSettingsBlock( flavor )
	return GetSettingsArraySize( GetSettingsBlockArray( settingsBlock, "tiers" ) )
}




int function Challenge_GetTimeSpanKind( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	string key = GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "timeSpan" )
	Assert( key in eChallengeTimeSpanKind, format( "Challenge %s has invalid time span kind: %s", string(ItemFlavor_GetAsset( flavor )), key ) )
	return eChallengeTimeSpanKind[key]
}



bool function Challenge_IsBoostEnabled( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "isBoostEnabled" )
}



bool function Challenge_IsRerollEnabled( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "isRerollEnabled" )
}



bool function Challenge_IsSingleMatch( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockString( tierData, "matchRequirement" ) == "inSingleMatch"
}




array<ItemFlavor> function Challenge_GetCharacterItemFlavors( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierBlock = Challenge_GetTierDataBlock( flavor, tier )

	array<ItemFlavor> characters = []
	var charactersArray          = GetSettingsBlockArray( tierBlock, "characters" )
	foreach ( var characterBlock in IterateSettingsArray( charactersArray ) )
	{
		asset characterAsset = GetSettingsBlockAsset( characterBlock, "flavor" )
		if ( IsValidItemFlavorSettingsAsset( characterAsset ) )
			characters.append( GetItemFlavorByAsset( characterAsset ) )
	}

	return characters
}




int function Challenge_GetGoalVal( ItemFlavor flavor, int tier, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	if ( Challenge_IsMetaChallenge( flavor ) )
	{
		return MetaChallenge_GetGoalVal( flavor )
	}

	if ( fileLevel.hasPlaylistChallengeOverrides )
	{
		int override = getAlt ? GetCurrentPlaylistVarInt( format( "%s_goal_alt_%i", ItemFlavor_GetGUIDString( flavor ), tier ), -1 ) :
			GetCurrentPlaylistVarInt( format( "%s_goal_%i", ItemFlavor_GetGUIDString( flavor ), tier ), -1 )
		if ( override > -1 )
			return override
	}

	var tierData = Challenge_GetTierDataBlock( flavor, tier )
	if ( getAlt )
		return GetSettingsBlockInt( tierData, "goalValAlt" )

	return GetSettingsBlockInt( tierData, "goalVal" )
}


float function Challenge_GetProgressPercent( entity player, ItemFlavor challenge, int tier, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( challenge ) == eItemType.challenge )
	int currentProgress    = Challenge_GetProgressValue( player, challenge, tier, getAlt )
	int goal               = Challenge_GetGoalVal( challenge, tier, getAlt )
	if ( goal == 0 )
	{
		Assert( false, format( "Challenge %i has a zero goalVal!", goal ) )
		return 0
	}
	return float( currentProgress ) / float( goal )
}


int function Challenge_GetGoalDisplayVal( ItemFlavor flavor, int tier, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	int val = Challenge_GetGoalVal( flavor, tier, getAlt )

	var tierData                 = Challenge_GetTierDataBlock( flavor, tier )
	bool displaySecondsAsMinutes = GetSettingsBlockBool( tierData, "convertSecondsToMinutesDisplay" )

	int challengeDisplay = displaySecondsAsMinutes ? int(float( val ) / 60.0) : val

	return challengeDisplay
}



string function Challenge_GetGRXRewardSequenceRef( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "grxRewardSequenceRef" )
}



bool function Challenge_ShouldTrackProgressInLobby( ItemFlavor challengeFlav )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( challengeFlav ), "trackProgressInLobby" )
}




int function Challenge_GetBPStarsReward( ItemFlavor challengeFlav, int tierIdx )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )

	int total             = 0
	ItemFlavorBag rewards = Challenge_GetRewards( challengeFlav, tierIdx )
	foreach ( int rewardIdx, ItemFlavor rewardFlav in rewards.flavors )
	{
		if ( ItemFlavor_GetType( rewardFlav ) != eItemType.voucher )
			continue

		int points = Voucher_GetEffectBattlepassStars( rewardFlav )
		if ( points <= 0 )
			continue

		total += points * rewards.quantities[rewardIdx]
	}
	return total
}



int function Challenge_GetBattlepassLevelsReward( ItemFlavor challengeFlav, int tierIdx )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )

	int total             = 0
	ItemFlavorBag rewards = Challenge_GetRewards( challengeFlav, tierIdx )
	foreach ( int rewardIdx, ItemFlavor rewardFlav in rewards.flavors )
	{
		if ( ItemFlavor_GetType( rewardFlav ) != eItemType.voucher )
			continue

		int levels = Voucher_GetEffectBattlepassLevels( rewardFlav )
		if ( levels <= 0 )
			continue

		total += levels * rewards.quantities[rewardIdx]
	}
	return total
}




ItemFlavorBag function Challenge_GetRewards( ItemFlavor challengeFlav, int tier )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challengeFlav ) )

	var tierData = Challenge_GetTierDataBlock( challengeFlav, tier )

	ItemFlavorBag rewards
	foreach ( int rewardIdx, var rewardData in IterateSettingsArray( GetSettingsBlockArray( tierData, "rewards" ) ) )
	{
		asset rewardAsset = GetSettingsBlockAsset( rewardData, "flavor" )
		if ( !IsValidItemFlavorSettingsAsset( rewardAsset ) )
		{
			Warning( "Skipping item reward #%d of challenge '%s' because the asset is not a valid item flavor: '%s'", rewardIdx, string(ItemFlavor_GetAsset( challengeFlav )), string(rewardAsset) )
			continue
		}

		rewards.flavors.append( GetItemFlavorByAsset( rewardAsset ) )
		rewards.quantities.append( GetSettingsBlockInt( rewardData, "quantity" ) )
	}
	return rewards
}




bool function Challenge_LastTierIsInfinite( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "lastTierIsInfinite" )
}




bool function Challenge_MaxOneTierPerMatch( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "maxOneTierPerMatch" )
}

















































int function Challenge_GetWeekNumber( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsInt( ItemFlavor_GetAsset( flavor ), "weekNumber" )
}


bool function Challenge_HasProgress( entity player, ItemFlavor challengeFlav )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	int currentTier        = Challenge_GetCurrentTier( player, challengeFlav )
	int currentProgress    = Challenge_GetProgressValue( player, challengeFlav, currentTier )
	int goal               = Challenge_GetGoalVal( challengeFlav, currentTier )

	
	if ( currentTier != 0 || currentProgress > 0 )
	{
		return true
	}

	if ( Challenge_IsEitherOr( challengeFlav ) && Challenge_GetProgressValue( player, challengeFlav, currentTier, true ) > 0 )
	{
		return true
	}

	return false
}



int function Challenge_GetProgressValue( entity player, ItemFlavor challengeFlav, int tier, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challengeFlav ) )

#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return 0
#endif

	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	Assert( challengeFlav in pcs.challengeStateMap, "Called Challenge_GetActiveTier for challenge " + string(ItemFlavor_GetAsset( challengeFlav )) + " but it was not assigned to the player " + player )

	if ( !Challenge_IsAssigned( player, challengeFlav ) )
	{
		
		return 0
	}

	ChallengeState cs = pcs.challengeStateMap[challengeFlav]

	int goalVal = Challenge_GetGoalVal( challengeFlav, tier, getAlt )

	int currentTier = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].currentTier" )

	
	if ( tier < currentTier )
		return goalVal

	
	if ( tier > currentTier )
		return 0

	int current            = 0
	array<string> statRefs = Challenge_GetStatRefs( challengeFlav, tier, getAlt )
	foreach ( string statRef in statRefs )
	{
		Assert( IsValidStatEntryRef( statRef ) )
		StatEntry entry = GetStatEntryByRef( statRef )
		Assert( entry.type == eStatType.INT )

	current += GetStat_Int( player, entry, eStatGetWhen.CURRENT, fileLevel.statsFetchMode )



	}

	int marker = getAlt ? player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarkerAlt" ) :
		player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarker" )

	if ( GetCurrentPlaylistVarBool( "challenge_absValueFix", true ) )
	{
		if ( Challenge_ShouldUseAbsoluteValue( challengeFlav, tier ) )
		{
			marker = 0
		}
	}

	int progress = current - marker

	if ( progress < 0 )
		return 0

	if ( progress > goalVal )
		return goalVal

	return progress
}













int function Challenge_GetProgressDisplayValue( entity player, ItemFlavor challengeFlav, int tier )
{
	int val = Challenge_GetProgressValue( player, challengeFlav, tier )

	var tierData                 = Challenge_GetTierDataBlock( challengeFlav, tier )
	bool displaySecondsAsMinutes = GetSettingsBlockBool( tierData, "convertSecondsToMinutesDisplay" )

	int challengeDisplay = displaySecondsAsMinutes ? int(float( val ) / 60.0) : val

	return challengeDisplay
}



ItemFlavor function Challenge_GetSource( ItemFlavor challengeFlav )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	return fileLevel.challengeSourceMap[challengeFlav]
}




var function Challenge_GetTierDataBlock( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var settingsBlock      = ItemFlavor_GetSettingsBlock( flavor )
	var tierDataBlockArray = GetSettingsBlockArray( settingsBlock, "tiers" )

	return GetSettingsArrayElem( tierDataBlockArray, tier )
}



int function Challenge_GetPostGamePersistenceIndex( entity player, int challengeGUID )
{
	for ( int pIdx = 0; pIdx < NUM_CHALLENGES_MAX; pIdx++ )
	{
		string pKey = format( "postGameChallengesProgress[%i].guid", pIdx )
		if ( player.GetPersistentVarAsInt( pKey ) == challengeGUID )
		{
			return pIdx
		}
	}

	Warning( format( "Could not find challenge with guid '%i' in persistence postGameChallengesProgress", challengeGUID ) )
	return -1
}



array<string> function Challenge_GetStatRefs( ItemFlavor flavor, int tier, bool getAlt = false )
{
	array<string> statRefs  = []

	if ( Challenge_IsMetaChallenge( flavor ) )
	{
		string metaChallengeStatRef = format( "stats.%s", MetaChallenge_GetStatRef( flavor ) )
		if ( metaChallengeStatRef != "" )
		{
			statRefs.append( metaChallengeStatRef )
			return statRefs 
		}
	}


	if ( Challenge_IsNarrativeChallenge( flavor ) )
	{
		string statRefName = NarrativeChallenge_GetStatRef( flavor )
		string narrativeChallengeStatRef = format( "stats.%s", statRefName )
		if ( statRefName != "" )
		{
			statRefs.append( narrativeChallengeStatRef )
			return statRefs
		}
	}


	if ( ItemFlavor_ChallengesHaveMetaData() )
	{
		Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

		table<string, string> ornull metaData = ItemFlavor_GetMetaData( flavor )
		expect table<string, string>(metaData)
		int tierCount = int(metaData[ CHALLENGE_TIER_COUNT ])

		Assert( tier >= 0 && tier < tierCount )

		int statCount = int(metaData[ format( CHALLENGE_TIER_STAT_COUNT, tier ) ])

		for ( int i = 0; i < statCount; i++ )
		{
			if ( getAlt )
				statRefs.append( metaData[ format( CHALLENGE_TIER_STAT_ALT_REF, tier, i ) ] )
			else
				statRefs.append( metaData[ format( CHALLENGE_TIER_STAT_REF, tier, i ) ] )
		}
	}
	else
	{
		Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
		Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

		var tierData = Challenge_GetTierDataBlock( flavor, tier )

		string specifiedStatRef = getAlt ? GetSettingsBlockString( tierData, "statRefAlt" ) : GetSettingsBlockString( tierData, "statRef" )

		if ( specifiedStatRef.find( "%char%" ) > -1 )
		{
			array<ItemFlavor> characterFlavors = Challenge_GetCharacterItemFlavors( flavor, tier )
			Assert( characterFlavors.len() > 0, format( "Challenge %s tier %i uses char stat ref but doesn't have a character flavor associated with it", string(ItemFlavor_GetAsset( flavor )), tier ) )
			foreach ( ItemFlavor character in characterFlavors )
			{
				statRefs.append( replace( specifiedStatRef, "%char%", ItemFlavor_GetGUIDString( character ) ) )
			}
		}
		else
		{
			statRefs.append( specifiedStatRef )
		}
	}

	return statRefs
}



int function Challenge_GetDifficulty( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	string key = GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "difficulty" )
	Assert( key in eChallegeDifficulty, format( "Challenge %s has invalid difficulty kind: %s", string(ItemFlavor_GetAsset( flavor )), key ) )
	return eChallegeDifficulty[key]
}



int function Challenge_GetGameMode( ItemFlavor flavor, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	string key = getAlt ? GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "modeAlt" ) :
		GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "mode" )

	Assert( key in eChallengeGameMode, format( "Challenge %s has invalid mode kind: %s", string(ItemFlavor_GetAsset( flavor )), key ) )
	return eChallengeGameMode[key]
}



string function Challenge_GetGameModeTag( int key )
{
	if ( key in GAME_MODE_TAG )
		return GAME_MODE_TAG[ key ]

	return ""
}



vector function Challenge_GetGameModeTagColor( int key )
{
	if ( key in GAME_MODE_TAG_COLOR )
		return GAME_MODE_TAG_COLOR[ key ]

	return < 0, 0, 0 >
}



bool function Challenge_IsBitfieldType( ItemFlavor challengeFlav, int tier )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challengeFlav ) )

	var tierData = Challenge_GetTierDataBlock( challengeFlav, tier )

	return GetSettingsBlockString( tierData, "progressAccrual" ) == "bitfieldStyle"
}



bool function Challenge_ShouldStartAtZero( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockString( tierData, "progressAccrual" ) == "startAtZero"
}



bool function Challenge_ShouldUseAbsoluteValue( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockString( tierData, "progressAccrual" ) == "absoluteVal"
}



bool function Challenge_ShouldAddProgressFromPrevTier( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockString( tierData, "progressAccrual" ) == "addProgressFromPrevTier"
}




bool function Challenge_IsPremium( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "isPremium" )
}



bool function Challenge_IsEitherOr( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "isEitherOr" )
}


















int function GetCompletedChallengeCount( entity player, array<ItemFlavor> challenges )
{
	int count = 0

	foreach ( ItemFlavor challenge in challenges )
	{
		int maxTier = Challenge_GetTierCount( challenge ) - 1
		Assert( maxTier >= 0 )

		
		if ( !Challenge_IsAssigned( player, challenge ) )
		{
			Warning( "GetCompletedChallengeCount found an unassigned challenge. These should have been filtered out before this function." )
			continue
		}

		
		if ( maxTier < 0 )
			continue

		if ( IsChallengeTierComplete( player, challenge, maxTier ) || ( Challenge_IsEitherOr( challenge ) && IsChallengeTierComplete( player, challenge, maxTier, true ) ) )
			count++
	}

	return count
}






























void function ChallengeDbg( entity player, string label, ... )
{
	table stackInfos = expect table(getstackinfos( 2 ))
	string str       = format( "[ChallengeDbg %s %s %s %d %s] %s",
		expect string(stackInfos.src),
		SERVER ? "SV" : CLIENT ? "CL" : UI ? "UI" : "??",
		expect string(stackInfos.func),
		expect int(stackInfos.line),
		string(player),
		label
	)
	for ( int argIdx = 0; argIdx < vargc; argIdx += 2 )
	{
		if ( argIdx > 0 )
			str += "; "

		string key = expect string(vargv[argIdx + 0])
		var val    = vargv[argIdx + 1]
		str += key
		str += "= "
		str += string(val)
	}
	str += "\n"
	print( str )
	SpamLog( str )
}

bool function IsCalendarCategory( int challengeCategory )
{
	return ( challengeCategory == eChallengeCategory.DAILY ) || ( challengeCategory == eChallengeCategory.TOP_WEEKLY )
}

bool function IsPreferredCalendarCategory( int challengeCategory )
{
	if ( !IsCalendarCategory( challengeCategory ) )
		return false

	int preferredCalendar = file.hasCompletedRegularDailies ? eChallengeCategory.TOP_WEEKLY : eChallengeCategory.DAILY

	return ( challengeCategory == preferredCalendar )
}

bool function IsBeginnerCategory( int challengeCategory )
{
	return ( challengeCategory == eChallengeCategory.BEGINNER )
}

bool function IsEventCategory( int challengeCategory )
{
	switch ( challengeCategory )
	{
		case eChallengeCategory.EVENT_00:
		case eChallengeCategory.EVENT_01:
		case eChallengeCategory.EVENT_02:
		case eChallengeCategory.EVENT_03:
			return true
	}

	return false
}

bool function IsStoryCategory( int challengeCategory )
{
	switch ( challengeCategory )
	{
		case eChallengeCategory.STORY_00:
		case eChallengeCategory.STORY_01:
		case eChallengeCategory.STORY_02:
		case eChallengeCategory.STORY_03:
			return true
	}

	return false
}

bool function IsTempUnlockChallengeCategory( int challengeCategory )
{
	return challengeCategory == eChallengeCategory.TEMP_UNLOCK
}

bool function IsRewardCampaignChallengeCategory( int challengeCategory )
{
	return challengeCategory == eChallengeCategory.REWARD_CAMPAIGN
}


bool function IsChallengeTileCategory( int challengeCategory )
{
	return challengeCategory == eChallengeCategory.CHALLENGE_TILE
}


bool function IsEventShopChallengeCategory( int challengeCategory )
{
	return challengeCategory == eChallengeCategory.EVENTSHOP_DAILY_CHALLENGE || challengeCategory == eChallengeCategory.EVENTSHOP_EVENT_CHALLENGE
}

bool function IsEventShopEventChallengeCategory( int challengeCategory )
{
	return challengeCategory == eChallengeCategory.EVENTSHOP_EVENT_CHALLENGE
}

ItemFlavor ornull function GetActiveBuffetEventForCategory( int t, int currCat )
{
	return GetActiveBuffetEventForIndex( t, currCat - eChallengeCategory.EVENT_00 )
}

ItemFlavor ornull function GetActiveStoryEventForCategory( int t, int currCat )
{
	return GetActiveStoryEventForIndex( t, currCat - eChallengeCategory.STORY_00 )
}

void function RefreshCachedSeasonInfo()
{
	fileLevel.currentSeason.calEventOrNull = GetActiveSeason( GetUnixTimestamp() )
	fileLevel.currentSeason.battlePassOrNull = GetActiveBattlePass()
	if ( fileLevel.currentSeason.calEventOrNull != null )
		fileLevel.currentSeason.expirationTimestamp = CalEvent_GetFinishUnixTime( expect ItemFlavor( fileLevel.currentSeason.calEventOrNull ) )
}


void function RefreshEventCache()
{
	int timestamp = GetUnixTimestamp()

	fileLevel.currentEvents  = GetActiveBuffetEventArray( timestamp )
	fileLevel.currentStories = GetActiveStoryEventArray( timestamp )










}



array<int> function Challenge_EitherOr_GetGoalVals( ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )

	array<int> goalVals = [ 0, 0 ]

	goalVals[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetGoalVal( flavor, 0 )
	goalVals[ ALT_CHALLENGE_INDEX ] = Challenge_GetGoalVal( flavor, 0, true )

	return goalVals
}



array<int> function Challenge_EitherOr_GetProgressValues( entity player, ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )

	array<int> progressValues = [ 0, 0 ]

	progressValues[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetProgressValue( player, flavor, 0 )
	progressValues[ ALT_CHALLENGE_INDEX ] = Challenge_GetProgressValue( player, flavor, 0, true )

	return progressValues
}



array< array<string> > function Challenge_EitherOr_GetStatRefs( ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )
	array<string> empty = []
	array< array<string> > statRefs = [ empty, empty ]

	statRefs[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetStatRefs( flavor, 0 )
	statRefs[ ALT_CHALLENGE_INDEX ] = Challenge_GetStatRefs( flavor, 0, true )

	return statRefs
}



array<int> function Challenge_EitherOr_GetGameModes( ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )

	array<int> gameModes = [ 0, 0 ]

	gameModes[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetGameMode( flavor )
	gameModes[ ALT_CHALLENGE_INDEX ] = Challenge_GetGameMode( flavor, true )

	return gameModes
}



array<string> function Challenge_EitherOr_GetDescriptions( ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )

	array<string> descriptions = [ "", "" ]

	descriptions[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetDescription( flavor, 0 )
	descriptions[ ALT_CHALLENGE_INDEX ] = Challenge_GetDescription( flavor, 0, true )

	return descriptions
}



bool function Challenge_CanBeCompletedInBR( ItemFlavor flavor )
{
	if ( Challenge_IsEitherOr( flavor ) )
		return true

	if ( Challenge_GetGameMode( flavor) == eChallengeGameMode.BATTLE_ROYALE )
		return true

	if ( Challenge_GetGameMode( flavor) == eChallengeGameMode.ANY )
		return true

	if ( Challenge_GetGameMode( flavor) == eChallengeGameMode.NON_MODE )
		return true

	return false

}




void function SpecialEventChallengeToolTipSetup( var button, ItemFlavor challenge, ToolTipData toolTipData )
{
	
	
	
	
	

	
	
	
	
	

	
	
	
	
	

	
	
	
	
	

	
	
	
	
	
}


bool function Challenge_IsMetaChallenge( ItemFlavor challengeFlav )
{
	asset challengeAsset = ItemFlavor_GetAsset( challengeFlav )
	return GetGlobalSettingsBool( challengeAsset, "isMetaChallenge" )
}



string function MetaChallenge_GetStatRef( ItemFlavor challengeFlav )
{
	if ( Challenge_IsMetaChallenge( challengeFlav ) )
	{
		ItemFlavor parentFlav = MetaChallenge_GetParentFlav( challengeFlav )
		string statRef = format( "metaChallenge_%s", ItemFlavor_GetGUIDString( parentFlav ) )
		return statRef

	}
	Assert( false, format( "%s is not a metachallenge!", ItemFlavor_GetGUIDString( challengeFlav ) ) )
	return ""
}



ItemFlavor function MetaChallenge_GetParentFlav( ItemFlavor challengeFlav )
{
	asset challengeAsset = ItemFlavor_GetAsset( challengeFlav )
	string parentType = GetGlobalSettingsString( challengeAsset, "typeOfMetaChallenge" )
	asset parentAsset
	switch ( parentType )
	{
		case "CHALLENGE_SET":
			parentAsset = GetGlobalSettingsAsset( challengeAsset, "challengeSet" )
			break
		case "CHALLENGE_COLLECTION":
			parentAsset = GetGlobalSettingsAsset( challengeAsset, "challengeCollection" )
			break
		case "REWARD_CAMPAIGN":
			parentAsset = GetGlobalSettingsAsset( challengeAsset, "rewardCampaign" )
			break
		default:
			Assert( false, "Invalid parent type for meta challenge!" )
	}

	Assert( parentAsset != $"", format( "The parent challengeSet, challengeCollection, or rewardCampaign was not set for metaChallenge %s", ItemFlavor_GetGUIDString( challengeFlav ) ) ) 
	ItemFlavor parentFlav = GetItemFlavorByAsset( parentAsset )
	return parentFlav
}



int function MetaChallenge_GetGoalVal( ItemFlavor challengeFlav )
{
	Assert ( Challenge_IsMetaChallenge( challengeFlav ) )
	ItemFlavor parentFlav = MetaChallenge_GetParentFlav( challengeFlav )

	switch ( ItemFlavor_GetType( parentFlav ) )
	{
		case eItemType.challenge_set:
			ChallengeSet set = ChallengeSet_GetByGUID( parentFlav.guid )
			return set.challenges.len()
		case eItemType.challenge_collection:
			ChallengeCollection col = ChallengeCollection_GetByGUID( parentFlav.guid )
			return col.challengeSets.len()
		case eItemType.calevent_reward_campaign:
			int numChallenges = RewardCampaign_GetChildChallenges( parentFlav ).len()
			return numChallenges
	}
	Assert( false, format( "Invalid meta challenge goal for %i", challengeFlav.guid ) )

	var tierData = Challenge_GetTierDataBlock( challengeFlav, 0 )
	return GetSettingsBlockInt( tierData, "goalVal" )
}



bool function Challenge_IsNarrativeChallenge( ItemFlavor challengeFlav, bool DEV_IS_NARRATIVE = false)
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	return Challenge_GetTimeSpanKind( challengeFlav ) == eChallengeTimeSpanKind.NARRATIVE
}
                                