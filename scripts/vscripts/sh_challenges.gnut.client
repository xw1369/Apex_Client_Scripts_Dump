
global function ShChallenges_LevelInit_PreStats
global function ShChallenges_LevelInit_PostStats
global function GetAllChallenges
global function GetAllChallengesOfTimespan
global function Challenge_GetTierCount
global function Challenge_LastTierIsInfinite
global function Challenge_GetCurrentTier
global function Challenge_IsComplete
global function Challenge_IsAllComplete
global function Challenge_GetTimeSpanKind
global function Challenge_IsBoostEnabled
global function Challenge_GetGoalVal
global function Challenge_EitherOr_GetGoalVals
global function Challenge_GetBPStarsReward
global function Challenge_GetBattlepassLevelsReward
global function Challenge_GetRewards
global function Challenge_IsPremium
global function Challenge_IsEitherOr
global function Challenge_GetProgressValue
global function Challenge_EitherOr_GetProgressValues
global function Challenge_GetSource
global function Challenge_GetStatRefs
global function Challenge_EitherOr_GetStatRefs
global function Challenge_CanRerollChallenge
global function Challenge_IsChallengesStateInititated
global function DoesPlayerHaveChallenge
global function RegisterChallengeSource
global function RegisterChallengeFromAsset
global function Challenge_IsAssigned
global function Challenge_GetGameModeTagColor
global function Challenge_GetGameModeTag
global function Challenge_GetGameMode
global function Challenge_EitherOr_GetGameModes
global function IsChallengeValidAsFavorite
global function Challenge_GetTierDataBlock
global function Challenge_GetPostGamePersistenceIndex
global function GetPlayerChallengesState
global function Challenge_GetCharacterItemFlavors
global function GetAssignedChallengesByTimeSpan
global function Challenge_IsMetaChallenge
global function MetaChallenge_GetStatRef
global function MetaChallenge_GetParentFlav
global function MetaChallenge_GetGoalVal
#if DEV
global function PrintChallengePersistence
#endif



global function Challenge_GetDescription
global function Challenge_EitherOr_GetDescriptions
global function SetRuiArgsForChallengeTier
global function SetRuiArgsForChallengeReward
global function GetChallengeRewardDisplayData
global function UpdateChallengeCategorySelection
global function IncrementCategorySelection
global function DecrementCategorySelection
global function SetSeasonColors
global function SetBattlePassLevelBadgeForLevel
global function SetRuiArgsForMythicSkinChallenge
global function IsFavoriteChallenge

#if DEV
global function DEV_DumpFavoritePersistenceData
#endif


#if DEV
global function DEV_RequestCompleteChallengeTier
global function DEV_GetAssignedChallengeData
global function DEV_GetChallengeTimeSpans
#endif






































global function ServerToClient_AssignedChallengesDidChange
global function ServerToClient_AssignedChallengesDidChange_FromEventsRefresh
global function ServerToClient_ChallengeDataDidChange
global function UpdateMinimapChallengeRui
global function UpdateClientCategorySelectionIndexFromUI





#if DEV
global function DEV_PrintAllChallenges
#endif




































enum eChallengeCategory
{
	EVENT_00,
	EVENT_01,
	EVENT_02,
	EVENT_03,
	STORY_00,
	STORY_01,
	STORY_02,
	STORY_03,
	BEGINNER,
	DAILY,
	TOP_WEEKLY,
	REWARD_CAMPAIGN,
	EVENTSHOP_DAILY_CHALLENGE,
	EVENTSHOP_EVENT_CHALLENGE,
	FAVORITES,
}



const table<int, string> GAME_MODE_NAME =
{
	[eChallengeGameMode.ANY] = "#GAME_MODE_ANY",
	[eChallengeGameMode.BATTLE_ROYALE] = "#GAME_MODE_BR",
	[eChallengeGameMode.ARENAS] = "#GAME_MODE_ARENAS",
	[eChallengeGameMode.NON_MODE] = "", 
	[eChallengeGameMode.CONTROL] = "#GAME_MODE_CONTROL",
	[eChallengeGameMode.EXCEPT_BR] = "#GAME_MODE_EXCEPT_BR",
	[eChallengeGameMode.GUNGAME] = "#GAME_MODE_GUNGAME",
}


const table<int, string> GAME_MODE_TAG =
{
	[eChallengeGameMode.ANY] = "",
	[eChallengeGameMode.BATTLE_ROYALE] = "#GAMEMODE_TAG_BATTLE_ROYAL",
	[eChallengeGameMode.ARENAS] = "#GAMEMODE_TAG_ARENAS",
	[eChallengeGameMode.NON_MODE] = "", 
	[eChallengeGameMode.CONTROL] = "#GAMEMODE_TAG_CONTROL",
	[eChallengeGameMode.EXCEPT_BR] = "#GAMEMODE_TAG_EXCEPT_BR",
	[eChallengeGameMode.GUNGAME] = "#GAMEMODE_TAG_GUNGAME",
}

const table<int, vector> GAME_MODE_TAG_COLOR =
{
	[eChallengeGameMode.ANY] =  <0,0,0>,
	[eChallengeGameMode.BATTLE_ROYALE] = < 64, 148, 158 >,
	[eChallengeGameMode.ARENAS] = < 108,79,198 >,
	[eChallengeGameMode.NON_MODE] = <0,0,0>, 
	[eChallengeGameMode.CONTROL] = < 215,154,8 >,
	[eChallengeGameMode.EXCEPT_BR] = < 0,71,115 >,
	[eChallengeGameMode.GUNGAME] = < 50,150,50 >,
}

global enum eChallegeDifficulty
{
	VERY_EASY,
	EASY,
	MEDIUM,
	HARD,
	VERY_HARD
}



global enum eChallengeTimeSpanKind
{
	BEGINNER,
	EVENTSHOP_DAILY_CHALLENGE, 
	EVENTSHOP_EVENT_CHALLENGE, 
	DAILY,
	SEASON_WEEKLY,
	SEASON_WEEKLY_RECURRING,
	EVENT,
	EVENT_SPECIAL,
	EVENT_SPECIAL_2,
	EVENT_HIDDEN, 
	REWARD_CAMPAIGN,
	MYTHIC,
	FAVORITE, 
}

global enum eChallengeRewardStyle
{
	
	ITEM_GENERAL = 1
	ITEM_BADGE = 2
	ITEM_WEAPON_SKIN = 3
}
global enum eTinyLabelPlacementStyle
{
	
	NONE = 0
	LEFT = 1
	CENTER = 2
	BOTTOM = 3
}





































global struct ChallengeRewardDisplayData
{
	ItemFlavor&       flav
	int               originalQuantity
	int               displayQuantity
	int               style
	int               rarityTier
	asset             icon
	ItemFlavor ornull badgeFlav
	int               badgeTier = -1
	string            tinyLabelText = ""
	int               tinyLabelPlacementStyle = eTinyLabelPlacementStyle.NONE
	bool			  isMythicSkin
}



struct ChallengeSortStruct
{
	
	float progressFrac,
	int week,
	int difficulty,
	ItemFlavor& challengeFlav
}



const string CHALLENGE_REROLL_SOUND = "UI_Menu_Challenge_ReRoll"


global const int PRIMARY_CHALLENGE_INDEX = 0
global const int ALT_CHALLENGE_INDEX = 1


global const bool BOTS_HAVE_CHALLENGES = false








const int MAX_UNOWNED_CHAR_CHALLENGE = 1
const array<int> DAILY_CHALLENGE_SET = [ eChallegeDifficulty.VERY_EASY, eChallegeDifficulty.EASY, eChallegeDifficulty.MEDIUM, eChallegeDifficulty.HARD, eChallegeDifficulty.VERY_HARD ]
const int NUM_DAILY_CHALLENGES = 5 
const int NUM_FAVORITE_CHALLENGES = NUM_DAILY_CHALLENGES 
const int NUM_WEEKLY_CHALLENGES_MAX = 11
const int NUM_CHALLENGE_WEEKS_MAX = 13
const int NUM_CHALLENGE_BUFFER_FOR_EVENTS = 32 
const int NUM_REWARD_CAMPAIGN_CHALLENGES_BUFFER = 50 
const int NUM_CHALLENGES_MAX = (NUM_WEEKLY_CHALLENGES_MAX * NUM_CHALLENGE_WEEKS_MAX) + NUM_DAILY_CHALLENGES + NUM_CHALLENGE_BUFFER_FOR_EVENTS + NUM_REWARD_CAMPAIGN_CHALLENGES_BUFFER
const int NUM_POST_GAME_CHALLENGES_MAX = 32


global const int MAX_REWARDS_PER_CHALLENGE_TIER = 4 


const int BASE_CHALLENGE_TIER = 0 
const asset BATTLE_COMPLETED_HEADER_IMAGE = $"rui/menu/battlepass/battle_pass_completed_header"


global struct ChallengeState
{
	int         persistenceIdx = -1
	ItemFlavor& flav
}




global struct PlayerChallengesState
{
	table<ItemFlavor, ChallengeState>   challengeStateMap
	array<ChallengeState ornull>        persistentArrayMirror
	bool statCallbacksRegistered = false
	bool challengesThreadCompleted = false
}



struct SeasonalInfoCache
{
	ItemFlavor ornull calEventOrNull
	ItemFlavor ornull battlePassOrNull
	int expirationTimestamp
}


struct StatRefMapChallengePair
{
	ItemFlavor& challenge
	bool	   statIsAlt
}


struct FileStruct_LifetimeLevel
{
	
	table<StatEntry, array<StatRefMapChallengePair> > statEntryChallengesMap

	table<ItemFlavor, ItemFlavor>        challengeSourceMap
	table<ItemFlavor, int>               challengeSortOrdinalMap
	SeasonalInfoCache currentSeason
	array<ItemFlavor> currentStories
	array<ItemFlavor> currentEvents
	array<ItemFlavor> currentEventShops
	array<ItemFlavor> currentRewardCampaigns







		PlayerChallengesState localPlayerChallengesState
		int                   _challengeCategorySelectionIndex
		array<ItemFlavor>     favoriteChallengeCache






	bool hasPlaylistChallengeOverrides = false

	bool forceNoCache = false

}
FileStruct_LifetimeLevel& fileLevel

global const array<int> CHALLENGE_REROLL_COSTS = [ 0, 2, 5, 10 ]






struct
{
	bool                    initialized = false
	BattlePassReward ornull nextBattlePassReward

        
	bool					hasCompletedEventEntirely = false
	bool					hasCompletedEventDailies = false
	bool					hasCompletedRegularDailies = false
} file


table<var, void functionref(var)> WORKAROUND_challengeButtonToFocusHandlerMap = {} 
table<var, void functionref(var)> WORKAROUND_challengeButtonToClickHandlerMap = {} 
table<var, void functionref(var)> WORKAROUND_challengeButtonToRightClickHandlerMap = {} 









void function ShChallenges_LevelInit_PreStats()
{
	FileStruct_LifetimeLevel newFileLevel
	fileLevel = newFileLevel

	AddCallback_OnItemFlavorRegistered( eItemType.challenge, OnChallengeRegistered )






		AddCreateCallback( "player", UpdateFavoriteChallengesCache )



		RegisterSignal( "ChallengeDataDidChange" )
		Remote_RegisterClientFunction( "ServerToClient_AssignedChallengesDidChange" )
		Remote_RegisterClientFunction( "ServerToClient_AssignedChallengesDidChange_FromEventsRefresh" )
		Remote_RegisterClientFunction( "ServerToClient_ChallengeDataDidChange", "bool" )

		Remote_RegisterServerFunction( "ClientCallback_Challenge_ReRoll", "int", INT_MIN, INT_MAX )

		Remote_RegisterServerFunction( "ClientCallback_MarkStoryPrologueCompleted", "int", 0, INT_MAX )
		Remote_RegisterServerFunction( "ClientCallback_SetStoryAboutActiveChapterSeen", "int", 0, INT_MAX )

		Remote_RegisterServerFunction( "DEV_ClientCallback_RequestCompleteChallengeTierByGUID", "int", 0, INT_MAX )
































	BeginnerChallenges_Init()


	file.initialized = true
}

ItemFlavor ornull function RegisterChallengeFromAsset( asset challengeAsset )
{
	
	var settingsBlock = GetSettingsBlockForAsset( challengeAsset )
	var tierDataArray = GetSettingsBlockArray( settingsBlock, "tiers" )
	for ( int i = 0 ; i < GetSettingsArraySize( tierDataArray ) ; i++ )
	{
		var tierBlock       = GetSettingsArrayElem( tierDataArray, i )
		var charactersArray = GetSettingsBlockArray( tierBlock, "characters" )
		foreach ( var characterBlock in IterateSettingsArray( charactersArray ) )
		{
			asset characterAsset = GetSettingsBlockAsset( characterBlock, "flavor" )
			if ( !IsValidItemFlavorSettingsAsset( characterAsset ) )
			{
				Warning( "Skipping challenge %s because character %s is not registered", string(challengeAsset), string(characterAsset) )
				continue
			}
		}
	}

	
	ItemFlavor ornull challenge = RegisterItemFlavorFromSettingsAsset( challengeAsset )

	return challenge
}




void function ShChallenges_LevelInit_PostStats()
{
#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return
#endif

	fileLevel.hasPlaylistChallengeOverrides = GetCurrentPlaylistVarBool( "has_playlist_challenge_overrides", false )

	int timestamp = GetUnixTimestamp()

	RefreshCachedSeasonInfo()

	fileLevel.currentStories = GetActiveStoryEventArray( timestamp )
	fileLevel.currentEvents  = GetActiveBuffetEventArray( timestamp )

	ItemFlavor ornull activeEventShop = EventShop_GetCurrentActiveEventShop()
	if( activeEventShop != null )
	{
		expect ItemFlavor( activeEventShop )
		fileLevel.currentEventShops = [ activeEventShop ]
	}

	ItemFlavor ornull activeRewardCampaign = RewardCampaign_GetActiveRewardCampaign()
	if( activeRewardCampaign != null )
	{
		expect ItemFlavor( activeRewardCampaign )
		fileLevel.currentRewardCampaigns = [ activeRewardCampaign ]
	}

	if ( fileLevel.currentStories.len() == 0 )
	{
		foreach ( string cat, int idx in eChallengeCategory )
		{
			if ( ! IsStoryCategory( idx ) )
				continue

			ItemFlavor ornull activeStory = GetActiveStoryEventForCategory( timestamp, idx )
			if ( activeStory != null )
				fileLevel.currentStories.append( expect ItemFlavor( activeStory ) )
		}
	}

	if ( fileLevel.currentEvents.len() == 0 )
	{
		foreach ( string cat, int idx in eChallengeCategory )
		{
			if ( ! IsEventCategory( idx ) )
				continue

			ItemFlavor ornull activeBuffet = GetActiveBuffetEventForCategory( timestamp, idx )
			if ( activeBuffet != null )
				fileLevel.currentEvents.append( expect ItemFlavor( activeBuffet ) )
		}
	}

	foreach ( ItemFlavor challenge in GetAllChallenges() )
	{
		array<bool> fetchAltRefs = [ false ]
		if ( Challenge_IsEitherOr( challenge ) )
			fetchAltRefs.append( true )

		foreach ( bool isAlt in fetchAltRefs )
		{
			int tierCount = Challenge_GetTierCount( challenge )

			for ( int i = 0 ; i < tierCount ; i++ )
			{
				array<string> statRefs = Challenge_GetStatRefs( challenge, i, isAlt )
				foreach ( string statRef in statRefs )
				{
					if ( !IsValidStatEntryRef( statRef ) )
					{
						Assert( false, format( "Challenge '%s' tier %d refers to non-existent stat: '%s'", string(ItemFlavor_GetAsset( challenge )), i, statRef ) )
						continue
					}

					StatEntry stat = GetStatEntryByRef( statRef )

					
					
					
					
					

					if ( Challenge_GetTimeSpanKind( challenge ) == eChallengeTimeSpanKind.EVENT_HIDDEN )
					{
						continue
					}

					int challengeGameMode = Challenge_GetGameMode( challenge, isAlt )
					if ( challengeGameMode != stat.gameMode ) 
					{
						Assert( false, format( "Challenge '%s' refers to stat that does not match the challenge game mode: '%s'", string(ItemFlavor_GetAsset( challenge )), statRef ) )
						continue
					}

					if ( !(stat in fileLevel.statEntryChallengesMap) )
						fileLevel.statEntryChallengesMap[ stat ] <- []
					StatRefMapChallengePair	pair
					pair.challenge = challenge
					pair.statIsAlt = isAlt
					fileLevel.statEntryChallengesMap[ stat ].append( pair )
				}

				if ( Challenge_GetGoalVal( challenge, i, isAlt ) <= 0 )
				{
					Assert( false, format( "Challenge '%s' has invalid goal val: %d", string(ItemFlavor_GetAsset( challenge )), Challenge_GetGoalVal( challenge, i ) ) )
					continue
				}
			}
		}
	}




}




























void function RegisterChallengeSource( ItemFlavor challengeFlav, ItemFlavor sourceFlav, int sortOrdinal )
{
	if ( challengeFlav in fileLevel.challengeSourceMap )
	{
		Warning( "Challenge %s source is ambiguous: %s, %s", string(ItemFlavor_GetAsset( challengeFlav )), string(ItemFlavor_GetAsset( fileLevel.challengeSourceMap[challengeFlav] )), string(ItemFlavor_GetAsset( sourceFlav )) )
		return
	}
	fileLevel.challengeSourceMap[challengeFlav] <- sourceFlav
	fileLevel.challengeSortOrdinalMap[challengeFlav] <- sortOrdinal
}




















































void function OnChallengeRegistered( ItemFlavor challenge )
{
	
}
























































void function ServerToClient_AssignedChallengesDidChange()
{
	ServerToClient_AssignedChallengesDidChange_Common( false )
}




void function ServerToClient_AssignedChallengesDidChange_FromEventsRefresh()
{
	ServerToClient_AssignedChallengesDidChange_Common( true )
}




void function ServerToClient_AssignedChallengesDidChange_Common( bool didEventChallengesRefresh )
{
	InitPlayerChallengesStateFromPersistence( GetLocalClientPlayer(), fileLevel.localPlayerChallengesState )
	RunUIScript( "ClientToUI_AssignedChallengesDidChange" )

	ServerToClient_ChallengeDataDidChange( didEventChallengesRefresh )
}














void function ServerToClient_ChallengeDataDidChange( bool didEventChallengesRefresh )
{
	RunUIScript( "ClientToUI_ChallengeDataDidChange", didEventChallengesRefresh )
	UpdateFavoriteChallengesCache( GetLocalClientPlayer() )
}

































































































































































































































































void function UpdateMinimapChallengeRui( array<var> ruiArray )
{
	if ( !IsConnected() )
		return

#if CHALLENGE_DEBUG
		ChallengeDbg( GetLocalClientPlayer(), "" )
#endif

	
	var titleRui           = ruiArray[0]
	array<var> rowRuiArray = clone ruiArray
	rowRuiArray.remove( 0 )

	entity player = GetLocalClientPlayer()

	int timestamp = GetUnixTimestamp()
	ItemFlavor ornull currentEvent

	int challengeCategory = GetChallengeDisplayCategory( true )

	if ( IsEventCategory( challengeCategory ) )
	{
		if ( IsEventCategory( challengeCategory ) )
			currentEvent = GetActiveBuffetEventForCategory( timestamp, challengeCategory )
		else
			currentEvent = GetActiveBuffetEventForIndex( timestamp, 0 )
	}

	array<ItemFlavor> challenges = GetChallengesByCategory( player, challengeCategory, currentEvent )
	if ( IsRewardCampaignChallengeCategory( challengeCategory ) )
	{
		challenges = RewardCampaign_GetCurrentTempUnlockChallenges( player )
	}

	if ( IsEventCategory( challengeCategory ) )
	{
		if ( currentEvent != null )
		{
			expect ItemFlavor( currentEvent )
			FilterOutMainChallengeIfValid( currentEvent, challenges )
		}
		else 
		{
			array< ItemFlavor > chalCopy = clone challenges
			foreach ( ItemFlavor chal in chalCopy )
			{
				if ( Challenge_GetGameMode( chal ) == eChallengeGameMode.NON_MODE )
				{
					challenges.fastremovebyvalue( chal )
					break
				}
			}
		}
	}
	else if ( challenges.len() > NUM_DAILY_CHALLENGES )
	{
		Assert( false, format( "too many challenges - %d - being sent to the Challenge box-row RUI", challenges.len() ) )
		challenges.resize( NUM_DAILY_CHALLENGES )
	}
	Assert( challenges.len() <= NUM_DAILY_CHALLENGES )

	UpdateChallengeCategorySelection( titleRui, true, true )
	UpdateChallengeRowsRuiRefreshWrapper( player, challenges, rowRuiArray )
}

void function UpdateChallengeRowsRuiRefreshWrapper( entity player, array<ItemFlavor> challenges, array<var> rowRuis = [] )
{
	fileLevel.forceNoCache = true
	UpdateChallengeRowsRui( player, challenges, rowRuis )
	fileLevel.forceNoCache = false
}


void function FilterOutMainChallengeIfValid( ItemFlavor currentEvent, array<ItemFlavor> challenges )
{
	BuffetEventModesAndChallengesData eventData = BuffetEvent_GetModesAndChallengesData( currentEvent )
	if ( eventData.mainChallengeFlav != null )
	{
		ItemFlavor main = expect ItemFlavor( eventData.mainChallengeFlav )
		int idx         = challenges.find( main )
		if ( idx >= 0 )
		{
			challenges.remove( idx )
		}
	}
}


array<ItemFlavor> function GetChallengesByCategory( entity player, int challengeCategory, ItemFlavor ornull currentEvent )
{
	bool hasActiveEvent = false
	if ( currentEvent != null )
	{
		expect ItemFlavor( currentEvent )
		hasActiveEvent = true
	}

	array<ItemFlavor> challenges
	if ( IsEventCategory( challengeCategory ) )
	{
		int timespan = IsEventShopChallengeCategory( challengeCategory ) ? eChallengeTimeSpanKind.EVENTSHOP_DAILY_CHALLENGE : eChallengeTimeSpanKind.EVENT
		challenges = GetAssignedChallengesByTimeSpan( player, timespan, -1, currentEvent )
	}
	else if ( IsStoryCategory( challengeCategory ) )
	{
		expect ItemFlavor( currentEvent )

		challenges = StoryEvent_GetCurrentChapterChallenges( player,  currentEvent )
	}
	else
	{
		switch( challengeCategory )
		{
			case eChallengeCategory.BEGINNER:
			{
				array<ItemFlavor> allBeginnerChallenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.BEGINNER )
				foreach ( ItemFlavor beginnerChallenge in allBeginnerChallenges )
				{
					if ( challenges.len() > 4 )
						break 




						if ( !Challenge_IsComplete( player, beginnerChallenge ) )
						{
							challenges.append( beginnerChallenge )
						}

				}
				break
			}

			case eChallengeCategory.DAILY:
				challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.DAILY )
				break

			case eChallengeCategory.TOP_WEEKLY:
				challenges = GetWeeklyChallengesSortedByProgress( player )
				break

			case eChallengeCategory.FAVORITES:
				challenges = GetFavoriteChallenges( player )
				break

			case eChallengeCategory.EVENTSHOP_DAILY_CHALLENGE:
				challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENTSHOP_DAILY_CHALLENGE )
				break

			case eChallengeCategory.EVENTSHOP_EVENT_CHALLENGE:
				challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.EVENTSHOP_EVENT_CHALLENGE )
				break

			case eChallengeCategory.REWARD_CAMPAIGN:
				challenges = GetAssignedChallengesByTimeSpan( player, eChallengeTimeSpanKind.REWARD_CAMPAIGN )
				break

				unreachable
		}
	}

	return challenges
}



array<ItemFlavor> function GetWeeklyChallengesSortedByProgress( entity player )
{
	const NUM_CHALLENGES_TO_RETURN = NUM_DAILY_CHALLENGES

	array<ChallengeSortStruct> challengeSortArray

	PlayerChallengesState pcs = GetPlayerChallengesState( player )

	array<ItemFlavor> results
	foreach ( ItemFlavor challengeFlav, ChallengeState cs in pcs.challengeStateMap )
	{
		if ( Challenge_GetTimeSpanKind( challengeFlav ) == eChallengeTimeSpanKind.SEASON_WEEKLY )
		{
			if ( !IsChallengePlaylistEnabled( challengeFlav ) )
				continue

			if ( Challenge_IsComplete( player, challengeFlav ) )
				continue

			if ( Stats_CurrentModeSupportsCustomStats() && !Challenge_IsEitherOr( challengeFlav ) && Challenge_GetGameMode( challengeFlav ) == eChallengeGameMode.BATTLE_ROYALE )
				continue

			if ( !Stats_CurrentModeSupportsCustomStats() && !Challenge_IsEitherOr( challengeFlav ) && !Challenge_CanBeCompletedInBR( challengeFlav ) )
				continue

			int currentTier = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].currentTier" )
			int goalVal     = Challenge_GetGoalVal( challengeFlav, currentTier )

			int current            = 0
			array<string> statRefs = Challenge_GetStatRefs( challengeFlav, currentTier )
			foreach ( string statRef in statRefs )
			{
				Assert( IsValidStatEntryRef( statRef ) )
				StatEntry entry = GetStatEntryByRef( statRef )
				Assert( entry.type == eStatType.INT )
				current += GetStat_Int( player, entry, eStatGetWhen.CURRENT )
			}

			int marker = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarker" )

			float progressFrac = float(current - marker) / float(goalVal)

			if ( Challenge_IsEitherOr( challengeFlav ) && Stats_CurrentModeSupportsCustomStats() )
			{
				bool getAlt = true
				int markerAlt  = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarkerAlt" )
				int goalValAlt = Challenge_GetGoalVal( challengeFlav, currentTier, getAlt )
				int currentAlt = 0

				array<string> altRefs = Challenge_GetStatRefs( challengeFlav, currentTier, getAlt )
				foreach ( string statRef in altRefs )
				{
					Assert( IsValidStatEntryRef( statRef ) )
					StatEntry entry = GetStatEntryByRef( statRef )
					Assert( entry.type == eStatType.INT )
					currentAlt += GetStat_Int( player, entry, eStatGetWhen.CURRENT )
				}

				progressFrac = float(currentAlt - markerAlt) / float(goalValAlt)
			}

			ChallengeSortStruct sortStruct
			sortStruct.progressFrac  = progressFrac
			sortStruct.week          = Challenge_FindAssignedWeekOrder( player, challengeFlav )
			sortStruct.difficulty    = Challenge_GetDifficulty( challengeFlav )
			sortStruct.challengeFlav = challengeFlav

			challengeSortArray.append( sortStruct )
		}
	}
	challengeSortArray.sort( Challenge_SortByProgress )
#if DEV
		foreach ( ChallengeSortStruct sortStruct in challengeSortArray )
		{
			printt( DEV_ItemFlavor_GetCleanedAssetPath( sortStruct.challengeFlav ) + "\t" + sortStruct.progressFrac + "\t" + sortStruct.week )
		}
#endif

	array<ItemFlavor> topWeeklyChallenges = []
	int maxSize                           = minint( NUM_CHALLENGES_TO_RETURN, challengeSortArray.len() )

	string prevDescription
	for ( int index = 0; index < challengeSortArray.len(); index++ )
	{
		ItemFlavor challenge = challengeSortArray[ index ].challengeFlav
		int challengeTier    = Challenge_GetCurrentTier( player, challenge )
		string challengeDesc = Challenge_GetDescription( challenge, challengeTier )
		if ( challengeDesc == prevDescription )
		{
			
			continue
		}

		prevDescription = challengeDesc
		topWeeklyChallenges.append( challengeSortArray[ index ].challengeFlav )

		if ( topWeeklyChallenges.len() >= maxSize )
			break
	}

	return topWeeklyChallenges
}



int function Challenge_FindAssignedWeekOrder( entity player, ItemFlavor challengeFlav )
{
	int weekIndex = Challenge_GetWeekNumber( challengeFlav )

	for ( int i = 0 ; i < NUM_CHALLENGE_WEEKS_MAX ; i++ )
	{

			int groupIndex = player.GetPersistentVarAsInt( "weeklyGroupOrder[" + i + "]" )



		if ( groupIndex == weekIndex )
			return i
	}

	return -1    
}



int function Challenge_SortByProgress( ChallengeSortStruct a, ChallengeSortStruct b )
{
	
	if ( a.progressFrac < b.progressFrac )
		return 1
	else if ( a.progressFrac > b.progressFrac )
		return -1

	
	if ( a.week > b.week )
		return 1
	else if ( a.week < b.week )
		return -1

	
	if ( a.difficulty > b.difficulty )
		return 1
	else if ( a.difficulty < b.difficulty )
		return -1

	return 0
}























































void function UpdateFavoriteChallengesCache( entity player )
{
	Assert( IsValid( player ) )

	if ( player != GetLocalClientPlayer() )
		return

	fileLevel.favoriteChallengeCache.clear()
	for ( int index = 0; index < NUM_FAVORITE_CHALLENGES; index++ )
	{
		SettingsAssetGUID challengeGUID = player.GetPersistentVarAsInt( format( "favoriteChallengeGUID[%d]", index ) )
		if ( !IsValidItemFlavorGUID( challengeGUID ) )
			continue

		ItemFlavor challengeFlav = GetItemFlavorByGUID( challengeGUID )

		if ( !IsChallengeValidAsFavorite( player, challengeFlav ) )
			continue

		fileLevel.favoriteChallengeCache.append( challengeFlav )
	}
}



bool function HasFavoriteChallenges()
{
	return fileLevel.favoriteChallengeCache.len() > 0
}



bool function IsFavoriteChallenge( ItemFlavor challengeFlav )
{
	entity player = GetLocalClientPlayer()
	return fileLevel.favoriteChallengeCache.contains( challengeFlav )
}



array<ItemFlavor> function GetFavoriteChallenges( entity player )
{
	const NUM_CHALLENGES_TO_RETURN = NUM_DAILY_CHALLENGES

	array<ChallengeSortStruct> challengeSortArray
	PlayerChallengesState pcs                = GetPlayerChallengesState( player )
	array<ItemFlavor> favoriteChallengeArray = fileLevel.favoriteChallengeCache

	foreach ( ItemFlavor challengeFlav in favoriteChallengeArray )
	{
		if ( !IsChallengeValidAsFavorite( player, challengeFlav ) )
			continue

		int currentTier     = Challenge_GetCurrentTier( player, challengeFlav )
		int currentProgress = Challenge_GetProgressValue( player, challengeFlav, currentTier )
		int goalProgress    = Challenge_GetGoalVal( challengeFlav, currentTier )

		ChallengeSortStruct sortStruct
		sortStruct.progressFrac  = float(currentProgress) / float(goalProgress)
		sortStruct.difficulty    = Challenge_GetDifficulty( challengeFlav )
		sortStruct.challengeFlav = challengeFlav

		challengeSortArray.append( sortStruct )
	}

	challengeSortArray.sort( Challenge_SortByProgress )

	array<ItemFlavor> topFavoriteChallenges = []
	int maxSize                             = minint( NUM_CHALLENGES_TO_RETURN, challengeSortArray.len() )

	for ( int index = 0; index < challengeSortArray.len(); index++ )
	{
		topFavoriteChallenges.append( challengeSortArray[ index ].challengeFlav )

		if ( topFavoriteChallenges.len() >= maxSize )
			break
	}

	return topFavoriteChallenges
}



bool function IsChallengeValidAsFavorite( entity player, ItemFlavor challengeFlav )
{
	if ( !Challenge_IsAssigned( player, challengeFlav ) )
		return false
	if ( Challenge_IsComplete( player, challengeFlav ) )
		return false
	if ( !IsChallengePlaylistEnabled( challengeFlav ) )
		return false

	return true
}


#if DEV
array<string> function DEV_GetChallengeTimeSpans()
{
	array<string> timeSpans = []
	foreach ( string key, int timeSpan in eChallengeTimeSpanKind )
		timeSpans.append( key )

	return timeSpans
}
#endif

#if DEV
array<ChallengeDebugDataStruct> function DEV_GetAssignedChallengeData( int timeSpan )
{
	entity lcPlayer = GetLocalClientPlayer()
	array<ItemFlavor> allChallenges = []
	if ( timeSpan == eChallengeTimeSpanKind.FAVORITE )
	{
		allChallenges = GetFavoriteChallenges( lcPlayer )
	}
	else if ( timeSpan != eChallengeTimeSpanKind.SEASON_WEEKLY )
	{
		allChallenges = GetAssignedChallengesByTimeSpan( lcPlayer, timeSpan )
	}
	else
	{
		ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull
		Assert( activeBattlePass != null )
		expect ItemFlavor( activeBattlePass )

		int numWeeks = GetNumBattlePassChallengesWeeks( activeBattlePass )
		array< ItemFlavor > weeklyChallenges = []
		for ( int week = 1; week <= numWeeks; week++ )
			weeklyChallenges.extend( GetBattlePassChallenges( activeBattlePass, eChallengeTimeSpanKind.SEASON_WEEKLY, week ) )

		foreach ( challenge in weeklyChallenges )
		{
			if ( Challenge_IsAssigned( lcPlayer, challenge ) )
				allChallenges.append( challenge )
		}
	}

	array<ChallengeDebugDataStruct> challengeDebugData = []
	foreach ( challenge in allChallenges )
	{
		ChallengeDebugDataStruct challengeData
		challengeData.guid 	   = challenge.guid
		challengeData.category = Challenge_GetTimeSpanKind( challenge )
		challengeData.ref      = ItemFlavor_GetHumanReadableRefForPIN_Slow( challenge )
		
		int goal            = Challenge_GetGoalVal( challenge, 0 )
		int progress        = Challenge_GetProgressValue( lcPlayer, challenge, 0 )
		array<string> stats = Challenge_GetStatRefs( challenge, 0 )
		challengeData.debugInfo = format( "Progress: %d / %d | Stat: %s",
											progress,
											goal,
											stats[0] )
		challengeData.complete = ( goal == progress )
		challengeDebugData.append( challengeData )
	}

	return challengeDebugData
}
#endif

#if DEV
void function DEV_DumpFavoritePersistenceData()
{
	entity player = GetLocalClientPlayer()

	printt( "PERSISTENCE" )
	for ( int index = 0; index < NUM_FAVORITE_CHALLENGES; index++ )
	{
		SettingsAssetGUID challengeGUID = player.GetPersistentVarAsInt( format( "favoriteChallengeGUID[%d]", index ) )
		printt( "\t", index, "challengeGUID", challengeGUID )

		if ( !IsValidItemFlavorGUID( challengeGUID ) )
		{
			printt( "\t\t-------" )
			continue
		}

		ItemFlavor challengeFlav = GetItemFlavorByGUID( challengeGUID )

		bool assigned        = Challenge_IsAssigned( player, challengeFlav )
		bool playlistEnabled = IsChallengePlaylistEnabled( challengeFlav )
		bool complete        = assigned ? Challenge_IsComplete( player, challengeFlav ) : false

		printt( index, "\tchallengeFlav", DEV_ItemFlavor_GetCleanedAssetPath( challengeFlav ), assigned, playlistEnabled, complete )
	}
	printt( "\tCASHE" )
	foreach ( int index, ItemFlavor challengeFlav in fileLevel.favoriteChallengeCache )
	{
		bool assigned        = Challenge_IsAssigned( player, challengeFlav )
		bool playlistEnabled = IsChallengePlaylistEnabled( challengeFlav )
		bool complete        = assigned ? Challenge_IsComplete( player, challengeFlav ) : false

		printt( "\t", index, "\tchallengeFlav", DEV_ItemFlavor_GetCleanedAssetPath( challengeFlav ), assigned, playlistEnabled, complete )
	}
}
#endif




























array<int> function GetChallengeCategoryIDArray( bool hideStories = false )
{
	array<int> categoryIDtoStringArray = []






	
	int eventIdx = eChallengeCategory.EVENT_00
	foreach ( event in fileLevel.currentEvents )
	{
		Assert( IsEventCategory( eventIdx ) )
		categoryIDtoStringArray.append( eventIdx++ )
	}

	if ( EventShop_CurrentActiveEventShopHasDailyChallenges() )
	{
		categoryIDtoStringArray.append( eChallengeCategory.EVENTSHOP_DAILY_CHALLENGE )
	}

	if ( EventShop_CurrentActiveEventShopHasEventChallenges() )
	{
		ItemFlavor ornull activeEventShop = EventShop_GetCurrentActiveEventShop()
		if ( EventShop_GetShowEventChallengesInLobby( expect ItemFlavor(activeEventShop) ) )
		{
			categoryIDtoStringArray.append( eChallengeCategory.EVENTSHOP_EVENT_CHALLENGE )
		}
	}

	ChallengeCollection ornull activeCollection = ChallengeCollection_GetActiveCollection()
	if ( activeCollection != null )
	{
		expect ChallengeCollection( activeCollection )
		if ( ChallengeCollection_HasChallenges( activeCollection ) )
		{
			categoryIDtoStringArray.append( eChallengeCategory.REWARD_CAMPAIGN )
		}
	}

	
	if( !hideStories )
	{
		int storyIdx = eChallengeCategory.STORY_00
		foreach ( story in fileLevel.currentStories )
		{
			if( StoryEvent_GetShowInChallengeBoxBool( story ) )
			{
				Assert( IsStoryCategory( storyIdx ) )
				categoryIDtoStringArray.append( storyIdx++ )
			}
		}
	}

	bool hasFavorites = HasFavoriteChallenges()
	if ( hasFavorites )
		categoryIDtoStringArray.append( eChallengeCategory.FAVORITES )

	categoryIDtoStringArray.extend( [ eChallengeCategory.DAILY, eChallengeCategory.TOP_WEEKLY ] )

	return categoryIDtoStringArray
}

void function UpdateChallengeCategorySelection( var rui, bool longName = false, bool hideStories = false )
{
	
	if ( !IsConnected() )
		return

	array<int> categoryIDtoStringArray = GetChallengeCategoryIDArray( hideStories )
	int selectionSlots                 = categoryIDtoStringArray.len()
	

	int newSelectionIndex = ClampInt( fileLevel._challengeCategorySelectionIndex, 0, selectionSlots )
	fileLevel._challengeCategorySelectionIndex = newSelectionIndex

	string category = GetCategoryStringFromType( categoryIDtoStringArray[ newSelectionIndex ], longName )
	RuiSetInt( rui, "selectionSlots", selectionSlots )    
	RuiSetInt( rui, "selectionID", newSelectionIndex ) 
	RuiSetString( rui, "selectionText", category ) 


		RuiSetBool( rui, "isObserver", GetLocalClientPlayer().IsObserver() && GetLocalClientPlayer().GetTeam() == TEAM_SPECTATOR )























































































}




































void function UpdateClientCategorySelectionIndexFromUI( int selectionIndex )
{
	fileLevel._challengeCategorySelectionIndex = selectionIndex
}































int function GetCategorySelectionSize( bool hideStories = false )
{
	array<int> categoryArray = GetChallengeCategoryIDArray( hideStories )
	return categoryArray.len()
}



void function IncrementCategorySelection(  bool hideStories = false, var button = null )
{
	if ( !IsConnected() )
		return

	int newSelection = (fileLevel._challengeCategorySelectionIndex + 1) % GetCategorySelectionSize( hideStories )
	fileLevel._challengeCategorySelectionIndex = newSelection
}



void function DecrementCategorySelection( bool hideStories = false, var button = null )
{
	if ( !IsConnected() )
		return

	int newSelection = (GetCategorySelectionSize( hideStories ) + fileLevel._challengeCategorySelectionIndex - 1) % GetCategorySelectionSize( hideStories )
	fileLevel._challengeCategorySelectionIndex = newSelection
}



int function GetChallengeDisplayCategory( bool hideStories = false )
{
	
	array<int> categoryIDtoStringArray = GetChallengeCategoryIDArray( hideStories )
	Assert( fileLevel._challengeCategorySelectionIndex < categoryIDtoStringArray.len() )

	if ( fileLevel._challengeCategorySelectionIndex >= categoryIDtoStringArray.len() )
		fileLevel._challengeCategorySelectionIndex = 0

	return categoryIDtoStringArray[ fileLevel._challengeCategorySelectionIndex ]
}



string function GetCategoryStringFromType( int categoryID, bool longName = false )
{
	string appendStr = longName ? "_CHALLENGES" : ""

	if ( IsEventCategory( categoryID ) )
	{
		return "#CATEGORY_EVENT" + appendStr
	}
	else if ( IsStoryCategory( categoryID ) )
	{
		return "#CATEGORY_STORY" + appendStr
	}
	else
	{
		switch( categoryID )
		{
			case eChallengeCategory.BEGINNER:
				return "#CATEGORY_BEGINNER" + appendStr
				break

			case eChallengeCategory.DAILY:
				return "#CATEGORY_DAILY" + appendStr
				break

			case eChallengeCategory.TOP_WEEKLY:
				return "#CATEGORY_TOP_WEEKLY" + appendStr
				break

			case eChallengeCategory.FAVORITES:
				return "#CATEGORY_FAVORITES" + appendStr
				break

			case eChallengeCategory.EVENTSHOP_DAILY_CHALLENGE:
				return "#CATEGORY_REWARD_SHOP_DAILY" + appendStr
				break

			case eChallengeCategory.EVENTSHOP_EVENT_CHALLENGE:
				return "#CATEGORY_REWARD_SHOP_EVENT" + appendStr
				break

			case eChallengeCategory.REWARD_CAMPAIGN:
				return "#UNLOCK_LEGENDS" + appendStr
				break
		}
	}

	unreachable
}



void function SetSeasonColors( var rui )
{
	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull season = fileLevel.currentSeason.calEventOrNull

	if ( season != null )
	{
		expect ItemFlavor( season )

		RuiSetFloat3( rui, "seasonColor", Season_GetTabBGSelectedCol( season ) )
	}
}






















































































































































































































































































































































































































































































PlayerChallengesState function GetPlayerChallengesState( entity player = null )
{
	player = AssertLocalOrServerValidPlayer( player )



		return fileLevel.localPlayerChallengesState

}



void function InitPlayerChallengesStateFromPersistence( entity player, PlayerChallengesState pcs )
{
	if ( !IsValid( player ) )
		return

#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return
#endif

	foreach ( ChallengeState ornull cs in pcs.persistentArrayMirror )
	{
		if ( cs == null )
			continue
		expect ChallengeState(cs)
		cs.persistenceIdx = -1
		ItemFlavor badItemFlav
		cs.flav = badItemFlav
	}
	pcs.persistentArrayMirror.clear()
	pcs.persistentArrayMirror.resize( NUM_CHALLENGES_MAX, null )
	pcs.challengeStateMap.clear()





	for ( int persistentArrayIdx = 0 ; persistentArrayIdx < NUM_CHALLENGES_MAX ; persistentArrayIdx++ )
	{
		int guid                        = player.GetPersistentVarAsInt( "challenges[" + persistentArrayIdx + "].guid" )
		ItemFlavor ornull challengeFlav = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )
		if ( challengeFlav == null )
		{
			if ( guid > 0 )
			{








			}
			continue
		}
		expect ItemFlavor( challengeFlav )

		ChallengeState cs
		cs.persistenceIdx                             = persistentArrayIdx
		cs.flav                                       = challengeFlav
		pcs.challengeStateMap[cs.flav] <- cs
		pcs.persistentArrayMirror[persistentArrayIdx] = cs
	}





}



bool function Challenge_IsChallengesStateInititated( entity player )
{





	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	return pcs.challengeStateMap.len() > 0
}































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#if DEV
void function DEV_RequestCompleteChallengeTier( int guid )
{
	Remote_ServerCallFunction( "DEV_ClientCallback_RequestCompleteChallengeTierByGUID", guid )
}
#endif






































#if DEV
void function PrintChallengePersistence( entity player )
{
	printt( "---------------------------" )
	printt( "CHALLENGES PERSISTENCE DUMP" )
	printt( "---------------------------" )
	printt( "" )
	printt( "dailyExpirationTime:", player.GetPersistentVarAsInt( "dailyExpirationTime" ) )
	printt( "weeklyRecurringLastResetWeek:", player.GetPersistentVarAsInt( "weeklyRecurringLastResetWeek" ) )
	for ( int i = 0 ; i < NUM_CHALLENGE_WEEKS_MAX ; i++ )
		printt( "    ", player.GetPersistentVarAsInt( "weeklyGroupOrder[" + i + "]" ) )
	printt( "" )
	printt( "  Assigned Challenges" )
	printt( "" )

	for ( int i = 0 ; i < NUM_CHALLENGES_MAX ; i++ )
	{
		int guid                    = player.GetPersistentVarAsInt( "challenges[" + i + "].guid" )
		ItemFlavor ornull challenge = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )

		if ( IsValid( challenge ) )
		{
			printt( "   ", i, DEV_ItemFlavor_GetCleanedAssetPath( expect ItemFlavor( challenge ) ) )
			printt( "       marker:", player.GetPersistentVarAsInt( "challenges[" + i + "].statMarker" ) )
			if ( Challenge_IsEitherOr( expect ItemFlavor( challenge ) ) )
				printt( "       marker:", player.GetPersistentVarAsInt( "challenges[" + i + "].statMarkerAlt" ) )
			printt( "       currentTier:", player.GetPersistentVarAsInt( "challenges[" + i + "].currentTier" ) )
		}
		else
		{
			printt( "   ", i, guid )
		}
	}

	printt( "" )
	printt( "  Post Game Challenges" )
	printt( "" )

	printt( "  postgameGrindStartTier:", player.GetPersistentVarAsInt( "postgameGrindStartTier" ) )
	printt( "  postgameGrindStartValue:", player.GetPersistentVarAsInt( "postgameGrindStartValue" ) )

	printt( "" )
	printt( "  Post Game Challenges Any Progress" )
	printt( "" )

	for ( int i = 0 ; i < NUM_CHALLENGES_MAX ; i++ )
	{
		int guid = player.GetPersistentVarAsInt( "postGameChallengesProgress[" + i + "].guid" )
		if ( guid > 0 )
		{
			ItemFlavor ornull challenge = GetItemFlavorOrNullByGUID( guid, eItemType.challenge )
			if ( IsValid( challenge ) )
			{
				printt( "   ", i, DEV_ItemFlavor_GetCleanedAssetPath( expect ItemFlavor( challenge ) ) )
				printt( "       tierMatchStart:", player.GetPersistentVarAsInt( "postGameChallengesProgress[" + i + "].tierMatchStart" ) )
				printt( "       progressMatchStart:", player.GetPersistentVarAsInt( "postGameChallengesProgress[" + i + "].progressMatchStart" ) )
			}
		}
		else
		{
			printt( "   ", i, guid )
		}
	}


	printt( "" )
	printt( "--------------------------" )
	printt( "-- END PERSISTENCE DUMP --" )
	printt( "--------------------------" )
}
#endif



#if DEV
void function DEV_PrintAllChallenges( bool assigned = false, bool currentBPOnly = true )
{
	
	array<ItemFlavor> allChallenges = GetAllChallenges()
	string challengeDump = ""


	if ( assigned )
	{
		allChallenges.clear()
		foreach ( int timeSpan in eChallengeTimeSpanKind )
		{
			if ( timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY )
				continue

			allChallenges.extend( GetAssignedChallengesByTimeSpan( GetLocalClientPlayer(), timeSpan ) )
		}
	}
	else if ( currentBPOnly )




	{
		allChallenges.clear()
		if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
			RefreshCachedSeasonInfo()

		ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull
		if ( activeBattlePass == null )
			return

		expect ItemFlavor( activeBattlePass )

		int group = -1 
		allChallenges.extend( GetBattlePassChallenges( activeBattlePass, eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING, group ) )
		allChallenges.extend( GetBattlePassChallenges( activeBattlePass, eChallengeTimeSpanKind.DAILY, group ) )

		int numWeeks = GetNumBattlePassChallengesWeeks( activeBattlePass )
		for ( int week = 1; week <= numWeeks; week++ )
			allChallenges.extend( GetBattlePassChallenges( activeBattlePass, eChallengeTimeSpanKind.SEASON_WEEKLY, week ) )
	}

	array<string> ref            = []
	array<string> desc           = []
	array<string> xpReward       = []
	array<string> type           = []
	array<string> difficulty     = []
	array<string> gamemode       = []
	array<string> statref        = []
	array<string> matchReq       = []

	int refLen            = 0
	int descLen           = 0
	int xpRewardLen       = 0
	int typeLen           = 0
	int diffLen           = 0
	int modeLen           = 0

	challengeDump += ( "------- ALL CHALLENGES -------\n" )
	foreach ( ItemFlavor challenge in allChallenges )
	{
		if ( !GetCurrentPlaylistVarBool( format( "%s_enabled", ItemFlavor_GetGUIDString( challenge ) ), true ) )
			continue

		string _type = GetEnumString( "eChallengeTimeSpanKind", Challenge_GetTimeSpanKind( challenge ) )

		if ( _type.len() > 16 )
			_type = _type.slice(0, 16)

		int tierCount = Challenge_GetTierCount( challenge )
		for ( int i = 0 ; i < tierCount ; i++ )
		{
			string _ref  = (i == 0) ? DEV_ItemFlavor_GetCleanedAssetPath( challenge ) : ""


				string _desc = Challenge_GetDescription( challenge, i )



			_desc = replace( _desc, "`1", "" )
			_desc = replace( _desc, "`0", "" )
			_desc = replace( _desc, "\n", " " )
			if ( tierCount > 1 )
				_desc = (i + 1) + ") " + _desc

			if ( _desc.len() > 64 )
				_desc = _desc.slice(0, 64) + "..."

			if ( Challenge_IsEitherOr( challenge ) )
			{
				if ( _desc.len() > 30 )
					_desc = _desc.slice(0, 30) + "..."


					string _descAlt = Challenge_GetDescription( challenge, i, true )



				_descAlt = replace( _desc, "`1", "" )
				_descAlt = replace( _desc, "`0", "" )
				_descAlt = replace( _desc, "\n", " " )
				if ( tierCount > 1 )
					_descAlt = (i + 1) + ") " + _descAlt

				if ( _descAlt.len() > 30 )
					_descAlt = _descAlt.slice(0, 30) + "..."

				_desc = _desc + " OR " + _descAlt
			}

			int stars = Challenge_GetBPStarsReward( challenge, i )
			string _xpReward
			if ( stars == 0 ) 
				_xpReward       = format( "1BP LVL" )
			else if ( stars == 1 )
				_xpReward       = format( "%d  STAR", Challenge_GetBPStarsReward( challenge, i ) )
			else if ( stars > 1 && stars < 10 )
				_xpReward       = format( "%d  STARS", Challenge_GetBPStarsReward( challenge, i ) )
			else if ( stars >= 10 )
				_xpReward       = format( "%d STARS", Challenge_GetBPStarsReward( challenge, i ) )

			string _diff = ""
			int _diffInt = Challenge_GetDifficulty( challenge )
			foreach ( key, val in eChallegeDifficulty )
			{
				if ( val == _diffInt )
					_diff = key
			}


				string _mode = Localize( GAME_MODE_NAME[Challenge_GetGameMode( challenge )] )




			if ( Challenge_IsEitherOr( challenge ) )
			{

					string _modeAlt = Localize( GAME_MODE_NAME[Challenge_GetGameMode( challenge, true )] )





				Assert ( _mode != _modeAlt, string(ItemFlavor_GetAsset( challenge )) + " uses the SAME game mode - " + _mode + " - for both halves of Either/Or. This is not yet supported." )
				Assert ( _mode.tolower().find("any") == -1 && _modeAlt.tolower().find("any") == -1, string(ItemFlavor_GetAsset( challenge )) + " uses 'ANY' mode for one half. This is not yet supported." )

				if ( _mode.len() > 6 )
					_mode = _mode.slice(0, 6)

				if ( _modeAlt.len() > 6 )
					_modeAlt = _modeAlt.slice(0, 6)

				_mode = _mode + " OR " + _modeAlt
			}

			array<string> statRefs = Challenge_GetStatRefs( challenge, i )
			string _stat = statRefs[0]
			if ( _stat.find( "SAID" ) != -1 )
			{
				int saidPos  = _stat.find( "SAID" )
				string start = _stat.slice( 0, saidPos )
				string end   = _stat.slice( saidPos + GUID_SAMPLE_STRING.len() )
				_stat = start + "x" + statRefs.len() + end
			}
			_stat = _stat.slice( 6 ) 

				if ( Challenge_IsEitherOr( challenge ) )
				{
					array<string> statRefsAlt = Challenge_GetStatRefs( challenge, i, true )
					string _statAlt = statRefsAlt[0]
					if ( _statAlt.find( "SAID" ) != -1 )
					{
						int saidPos  = _statAlt.find( "SAID" )
						string start = _statAlt.slice( 0, saidPos )
						string end   = _statAlt.slice( saidPos + GUID_SAMPLE_STRING.len() )
						_statAlt = start + "x" + statRefsAlt.len() + end
					}
					_statAlt = _statAlt.slice( 6 ) 

					_stat = _stat + " OR " + _statAlt
				}

			Assert ( ! ( Challenge_IsStreak( challenge, i ) && Challenge_IsSingleMatch( challenge, i ) ), "Somehow we have an impossible combination of a Streak & Single-Match Challenge for " + string(ItemFlavor_GetAsset( challenge )) + " Tier " + string(i) )
			string _matchreq = "       "
			if ( Challenge_IsStreak( challenge, i ) )
				_matchreq = "STREAK "
			else if ( Challenge_IsSingleMatch( challenge, i ) )
				_matchreq = "SINGLE "

			ref.append( _ref )
			desc.append( _desc )
			xpReward.append( _xpReward )
			type.append( i == 0 ? _type : "" )
			difficulty.append( _diff )
			gamemode.append( _mode )
			statref.append( _stat )
			matchReq.append( _matchreq )


			if ( _ref.len() > refLen )
				refLen = _ref.len()
			if ( _desc.len() > descLen )
				descLen = _desc.len()
			if ( _xpReward.len() > xpRewardLen )
				xpRewardLen = _xpReward.len()
			if ( _type.len() > typeLen )
				typeLen = _type.len()
			if ( _diff.len() > diffLen )
				diffLen = _diff.len()
			if ( _mode.len() > modeLen )
				modeLen = _mode.len()
		}
	}

	Assert( desc.len() == ref.len() && xpReward.len() == ref.len() && type.len() == ref.len() )

	ref.insert( 0, "ITEM FLAVOR NAME" )
	desc.insert( 0, "DESCRIPTION" )
	xpReward.insert( 0, "STARS" )
	type.insert( 0, "TYPE" )
	difficulty.insert( 0, "DIFFICULTY" )
	gamemode.insert( 0, "MODE" )
	statref.insert( 0, "STATREF" )
	matchReq.insert( 0, "MTCHRQ" )

	int weeklyCounter = 1 
	int weeklyNum = 1 
	for ( int i = 0 ; i < ref.len() ; i++ )
	{
		string _ref            = ref[i]
		string _desc           = desc[i]
		string _xpReward       = xpReward[i]
		string _type           = type[i]
		string _diff           = difficulty[i]
		string _mode           = gamemode[i]
		string _stat           = statref[i]
		string _matchreq	   = matchReq[i]

		if ( _type == "SEASON_WEEKLY" )
		{
			if ( weeklyNum > NUM_WEEKLY_CHALLENGES_MAX )
			{
				weeklyNum = 1
				weeklyCounter++
			}

			if ( weeklyNum == 1 )
			{
				challengeDump += ( format( "WEEK #%d\n", weeklyCounter ) )
			}

			weeklyNum++

		}

		while( _ref.len() < refLen )
			_ref += " "
		while( _desc.len() < descLen )
			_desc += " "
		while( _xpReward.len() < xpRewardLen )
			_xpReward += " "
		while( _type.len() < typeLen )
			_type += " "
		while( _diff.len() < diffLen )
			_diff += " "
		while( _mode.len() < modeLen )
			_mode += " "

		challengeDump += ( format( "%s  %s  %s  %s  %s  %s  %s  %s\n", _ref, _desc, _xpReward, _type, _diff, _mode, _matchreq, _stat ) )
	}

	challengeDump += ( "------------------------------\n" )
	challengeDump += ( "  Total Challenges:" + string( allChallenges.len() ) + "\n" )
	challengeDump += ( "------------------------------\n" )

	DEV_PrintChallengeDataToFile( challengeDump )
}

void function DEV_PrintChallengeDataToFile( string out )
{
	const string DEBUG_OUTPUT_PATH = "../../dumps/" 
	printt( "Dumping Challenge data to depot/r5dev/dumps/challenge_data_dump.txt" )
	DevTextBufferClear()
	DevTextBufferWrite( out )
	DevTextBufferDumpToFile( DEBUG_OUTPUT_PATH + "challenge_data_dump.txt" )
	DevTextBufferClear()
}
#endif



array<ItemFlavor> function GetAssignedChallengesByTimeSpan( entity player, int timeSpan, int weekIndex = -1, ItemFlavor ornull specificEvent = null )
{
	Assert( timeSpan >= 0 && timeSpan < eChallengeTimeSpanKind.len() )
	Assert( (timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY) == (weekIndex > 0) )


	if( timeSpan == eChallengeTimeSpanKind.BEGINNER )
	{
		
		array<ItemFlavor> results



		foreach ( ItemFlavor challengeFlav in BeginnerChallenges_GetChallengeList() )

		{
			if( Challenge_IsAssigned( player, challengeFlav ) )
				results.append( challengeFlav )
		}
		return results
	}


	PlayerChallengesState pcs = GetPlayerChallengesState( player )

	array<ItemFlavor> results
	foreach ( ItemFlavor challengeFlav, ChallengeState cs in pcs.challengeStateMap )
	{
		if ( Challenge_GetTimeSpanKind( challengeFlav ) == timeSpan )
		{
			if ( !IsChallengePlaylistEnabled( challengeFlav ) )
				continue

			if ( timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY && Challenge_GetWeekNumber( challengeFlav ) != weekIndex )
				continue

			if ( timeSpan == eChallengeTimeSpanKind.EVENT && specificEvent != null )
			{
				expect ItemFlavor( specificEvent )
				int[1] OUT_nextRefreshUnixTime

				if( ItemFlavor_GetType( specificEvent ) == eItemType.calevent_story_challenges )
				{
					if( !StoryEvent_GetCurrentChapterChallenges( player, specificEvent ).contains( challengeFlav ) )
						continue
				}
				else
				{
					if ( !BuffetEvent_GetDailyChallenges_TEMP( specificEvent ).contains( challengeFlav ) &&
						 !BuffetEvent_GetCurrentChallenges_EXCLUDING_DAILIES( specificEvent, OUT_nextRefreshUnixTime ).contains( challengeFlav ) )
						continue
				}
			}

			results.append( challengeFlav )
		}
	}
	return results
}

bool function IsChallengePlaylistEnabled( ItemFlavor challengeFlav )
{
	if ( fileLevel.hasPlaylistChallengeOverrides == false )
		return true

	return GetCurrentPlaylistVarBool( format( "%s_enabled", ItemFlavor_GetGUIDString( challengeFlav ) ), true )
}























































































void function UpdateChallengeRowsRui( entity player, array<ItemFlavor> challenges, array<var> rowRuis = [] )
{
	
	Assert( challenges.len() <= NUM_DAILY_CHALLENGES, "total:" + challenges.len() + " Are Event Challenges set to show a set of more than 5 challenges in the lobby?" )

	foreach ( int rowIdx, var rui in rowRuis )
	{
		if ( challenges.len() <= rowIdx )
		{
			
			RuiSetBool( rui, "isVisible", false )
			continue
		}

		RuiSetBool( rui, "isVisible", true )


			
			RuiSetInt( rui, "rowIndex", rowIdx )


		ItemFlavor challenge     = challenges[ rowIdx ]

		int tierCount            = Challenge_GetTierCount( challenge ) 
		int activeTier           = Challenge_GetCurrentTier( player, challenge ) 
		bool isChallengeComplete = Challenge_IsComplete( player, challenge )     
		if ( isChallengeComplete )
			activeTier = tierCount - 1 
		bool challengeIsInfinite = Challenge_LastTierIsInfinite( challenge )    

		int maxRewardIcons      = MAX_REWARDS_PER_CHALLENGE_TIER 

		int gameMode
		string description
		int progress
		int goal

		bool isEitherOrChallenge = Challenge_IsEitherOr( challenge )


		if( isEitherOrChallenge )
		{
			array<int> gameModes = Challenge_EitherOr_GetGameModes( challenge )
			array<string> descriptions = Challenge_EitherOr_GetDescriptions( challenge )
			array<int> progression = Challenge_EitherOr_GetProgressValues( player, challenge )
			array<int> goals = Challenge_EitherOr_GetGoalVals( challenge )

			bool playerIsPlayingBR = Stats_CurrentModeIsSurvival()
			int challengeIndexToUse = 0
			foreach( int idx, int data in gameModes)
			{
				string tag = Challenge_GetGameModeTag( data )
				if( ( tag != GAME_MODE_TAG[eChallengeGameMode.BATTLE_ROYALE] && !playerIsPlayingBR ) ||
					( tag == GAME_MODE_TAG[eChallengeGameMode.BATTLE_ROYALE] && playerIsPlayingBR )
				)
				{
					challengeIndexToUse = idx
				}
			}

			gameMode = gameModes[challengeIndexToUse]
			description = descriptions[challengeIndexToUse]
			progress = progression[challengeIndexToUse]
			goal = goals[challengeIndexToUse]
		}
		else
		{
			gameMode = Challenge_GetGameMode( challenge )
			description = Challenge_GetDescription( challenge, activeTier )
			progress = Challenge_GetProgressDisplayValue( player, challenge, activeTier )
			goal = Challenge_GetGoalDisplayVal( challenge, activeTier )
		}

		SetSeasonColors( rui ) 

		vector rewardColor = <1, 1, 1> 
		int timeSpan       = Challenge_GetTimeSpanKind( challenge )
		if ( timeSpan == eChallengeTimeSpanKind.EVENT )
		{
			ItemFlavor eventFlav = Challenge_GetSource( challenge )
			rewardColor = BuffetEvent_GetRewardIconCol( eventFlav )
		}
		RuiSetFloat3( rui, "rewardColor", rewardColor )

		RuiSetString( rui, "challengeTierDesc", description )

#if DEV
			bool doDebug = (InputIsButtonDown( KEY_LSHIFT ) && InputIsButtonDown( KEY_LCONTROL )) || (InputIsButtonDown( BUTTON_TRIGGER_LEFT_FULL ) && InputIsButtonDown( BUTTON_B ))
			if ( doDebug )
			{
				printt( "#challenge --", DEV_ItemFlavor_GetCleanedAssetPath( challenge ) )
				RuiSetString( rui, "challengeTierDesc", DEV_ItemFlavor_GetCleanedAssetPath( challenge ) + " | " + activeTier )
			}
#endif


		RuiSetInt( rui, "challengeTierProgress", progress )
		RuiSetInt( rui, "challengeTierGoal", goal )
		RuiSetBool( rui, "challengeCompleted", isChallengeComplete )

		RuiSetString( rui, "challengeModeTag", Challenge_GetGameModeTag( gameMode ) )
		RuiSetFloat3( rui, "challengeModeTagColor", Challenge_GetGameModeTagColor( gameMode ) )

		bool showDiagonalWeapons                  = false 
		bool shouldUseBadgeRuis                   = false 
		array<ChallengeRewardDisplayData> rewards = GetChallengeRewardDisplayData( challenge, activeTier, showDiagonalWeapons, shouldUseBadgeRuis, false )
		if ( rewards.len() >= maxRewardIcons )
			Warning( "Too many rewards for one challenge: " + string(ItemFlavor_GetAsset( challenge )) )

		for ( int rewardIdx = 0; rewardIdx < maxint( rewards.len(), maxRewardIcons ); rewardIdx++ )
		{
			string ruiArgPrefix = "challengeTierReward" + rewardIdx
			if ( rewardIdx < rewards.len() )
				SetRuiArgsForChallengeReward( rui, ruiArgPrefix, rewards[ rewardIdx ] )
			else
				SetRuiArgsForChallengeReward( rui, ruiArgPrefix, null )
		}
	}
}

















































































































































































































































void function UpdateChallengeBoxBPLevelBadge( entity player, var rui )
{
	EHI playerEHI                      = ToEHI( player )
	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull

	if ( activeBattlePass != null && rui != null )
	{
		expect ItemFlavor( activeBattlePass )

		int currentBattlePassXP  = GetPlayerBattlePassXPProgress( playerEHI, activeBattlePass, false )
		int battlePassLevel      = GetBattlePassLevelForXP( activeBattlePass, currentBattlePassXP ) + 1
		bool battlePassCompleted = battlePassLevel >= (GetBattlePassMaxLevelIndex( activeBattlePass ) + 1)

		SetBattlePassLevelBadgeForLevel( player, rui, activeBattlePass, battlePassLevel, battlePassCompleted )
	}
}
void function SetBattlePassLevelBadgeForLevel( entity player, var rui, ItemFlavor activeBattlePass, int battlePassLevel, bool battlePassCompleted )
{
	RuiDestroyNestedIfAlive( rui, "headerBadgeHandle" )

	EHI playerEHI                        = ToEHI( player )
	ItemFlavor headerBadge               = GetBattlePassProgressBadge( activeBattlePass )
	int ornull overrideDataIntegerOrNull = battlePassLevel

	ItemFlavor dummy
	CreateNestedGladiatorCardBadge( rui, "headerBadgeHandle", playerEHI, headerBadge, 0, dummy, overrideDataIntegerOrNull )

	RuiSetBool( rui, "battlePassCompleted", battlePassCompleted )

	if ( battlePassCompleted )
		RuiSetImage( rui, "headerImage", BATTLE_COMPLETED_HEADER_IMAGE )
	else
		RuiSetImage( rui, "headerImage", $"" )
}



void function UpdateChallengeBoxHeaderBPProgress( entity player, var rui )
{
	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull activeBattlePass = fileLevel.currentSeason.battlePassOrNull

	if ( activeBattlePass != null )
	{
		expect ItemFlavor( activeBattlePass )

		if ( BattlePass_UseStarsToProgress( activeBattlePass ) )
		{
			ItemFlavor ornull starChallenge = GetBattlePassRecurringStarChallenge( activeBattlePass )

			if ( starChallenge != null )
			{
				expect ItemFlavor( starChallenge )

				if ( DoesPlayerHaveChallenge( player, starChallenge ) )
				{
					SetSeasonColors( rui )

					int tier     = Challenge_GetCurrentTier( player, starChallenge )
					int progress = Challenge_GetProgressValue( player, starChallenge, tier )
					RuiSetInt( rui, "bpStarCount", progress )
					RuiSetBool( rui, "showBPProgress", true )
				}
			}
		}
	}
}











































































































































































































































































































































































































































bool function Challenge_CanRerollChallenge( ItemFlavor challenge )
{
	if ( Challenge_GetTimeSpanKind( challenge ) != eChallengeTimeSpanKind.DAILY )
		return false

	if ( Challenge_GetDifficulty( challenge ) == eChallegeDifficulty.VERY_EASY )
		return false

	array<ItemFlavor> dailyChallengePool = clone GetAllChallengesOfTimespan( eChallengeTimeSpanKind.DAILY )
	array<ItemFlavor> rerollPool

	int diff = Challenge_GetDifficulty( challenge )

	foreach ( ch in dailyChallengePool )
	{
		if ( Challenge_GetDifficulty( ch ) == diff )
			rerollPool.append( ch )
	}

	if ( rerollPool.len() <= 1 )
		return false

	return true
}


void function SetRuiArgsForChallengeTier( var rui, string ruiArgPrefix, ItemFlavor challenge, int ornull displayTierIdx, int maxRewardIcons, int maxExtraRewardIcons, bool isEitherOrChallenge = false )
{
	
	

	entity player = GetLocalClientPlayer()
	string p      = ruiArgPrefix

	int challengeTierCount   = Challenge_GetTierCount( challenge )
	bool challengeIsInfinite = Challenge_LastTierIsInfinite( challenge )
	int currentTierIdx       = Challenge_GetCurrentTier( player, challenge )
	if ( displayTierIdx == null )
		displayTierIdx = currentTierIdx
	expect int(displayTierIdx)
	displayTierIdx = ClampInt( displayTierIdx, 0, challengeTierCount - 1 )

	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	ItemFlavor ornull season = fileLevel.currentSeason.calEventOrNull

	array<string> descriptions
	array<int> progression
	array<int> goals

	if ( isEitherOrChallenge )
	{
		descriptions = Challenge_EitherOr_GetDescriptions( challenge )
		progression = Challenge_EitherOr_GetProgressValues( player, challenge )
		goals = Challenge_EitherOr_GetGoalVals( challenge )
	}
	else
	{
		descriptions.append( Challenge_GetDescription( challenge, displayTierIdx ) )
		progression.append( Challenge_GetProgressDisplayValue( player, challenge, displayTierIdx ) )
		goals.append( Challenge_GetGoalDisplayVal( challenge, displayTierIdx )  )
	}

	
	
	
	

	foreach( int idx, string description in descriptions)
	{
		string modifier = ( idx > 0 ) ? "Alt": ""
		RuiSetString( rui, p + modifier + "TierDesc", description )
	}

	foreach( int idx, int progress in progression)
	{
		string modifier = ( idx > 0 ) ? "Alt": ""
		RuiSetInt( rui, p + modifier + "TierProgress", progress )
	}

	foreach( int idx, int goal in goals)
	{
		string modifier = ( idx > 0 ) ? "Alt": ""
		RuiSetInt( rui, p + modifier + "TierGoal", goal )
	}

	RuiSetInt( rui, p + "TiersCount", challengeTierCount )
	RuiSetBool( rui, p + "IsInfinite", challengeIsInfinite )
	RuiSetInt( rui, p + "ActiveTierIdx", currentTierIdx )
	RuiSetBool( rui, p + "Completed", Challenge_IsComplete( player, challenge ) )
	SetSeasonColors( rui )

	bool showDiagonalWeapons                  = false
	bool shouldUseBadgeRuis                   = false
	array<ChallengeRewardDisplayData> rewards = GetChallengeRewardDisplayData( challenge, displayTierIdx, showDiagonalWeapons, shouldUseBadgeRuis, true )

	int bestRarityTier = -1
	for ( int rewardIdx = 0; rewardIdx < maxint( rewards.len(), maxRewardIcons ); rewardIdx++ )
	{
		if ( rewardIdx < rewards.len() )
		{
			ChallengeRewardDisplayData crdd = rewards[rewardIdx]
			bestRarityTier = maxint( bestRarityTier, crdd.rarityTier )
			if ( rewardIdx >= maxRewardIcons )
			{
				if ( maxRewardIcons > 0 )
					Warning( "Too many rewards for one challenge tier. RUI will not display reward with icon: %s", string(crdd.icon) )
				continue 
			}

			SetRuiArgsForChallengeReward( rui, format( "%sTierReward%d", p, rewardIdx ), crdd )

			continue 
		}
		else if ( rewardIdx >= maxRewardIcons )
			continue 

		
		SetRuiArgsForChallengeReward( rui, format( "%sTierReward%d", p, rewardIdx ), null )
	}

	RuiSetInt( rui, p + "TierBestRarityTier", bestRarityTier )
}

void function SetRuiArgsForChallengeReward( var rui, string ruiArgPrefix, ChallengeRewardDisplayData ornull crdd )
{
	
	string p = ruiArgPrefix

	RuiDestroyNestedIfAlive( rui, format( "%sUi", p ) )

	if ( crdd == null )
	{
		RuiSetInt( rui, format( "%sStyle", p ), -1 )
		RuiSetInt( rui, format( "%sRarityTier", p ), -1 )
		RuiSetImage( rui, format( "%sIcon", p ), $"" )
		RuiSetString( rui, format( "%sTinyLabelText", p ), "" )
		RuiSetInt( rui, format( "%sTinyLabelPlacementStyle", p ), -1 )
		return
	}
	expect ChallengeRewardDisplayData(crdd)
	RuiSetInt( rui, format( "%sStyle", p ), crdd.style )
	RuiSetInt( rui, format( "%sRarityTier", p ), crdd.rarityTier )
	RuiSetImage( rui, format( "%sIcon", p ), crdd.icon )
	if ( crdd.badgeFlav != null )
	{
		CreateNestedGladiatorCardBadge( rui, format( "%sUi", p ), LocalClientEHI(),
			expect ItemFlavor(crdd.badgeFlav), -1, null, crdd.badgeTier, false ) 
	}
	RuiSetString( rui, format( "%sTinyLabelText", p ), crdd.tinyLabelText )
	RuiSetInt( rui, format( "%sTinyLabelPlacementStyle", p ), crdd.tinyLabelPlacementStyle )

	RuiSetBool( rui, "showMythicIndicator", crdd.isMythicSkin )
	if ( crdd.isMythicSkin )
		RuiSetInt( rui, "activeMythicTier", crdd.badgeTier )
}

void function SetRuiArgsForMythicSkinChallenge( var rui, int activeTier )
{
	RuiSetInt( rui, "activeMythicTier", activeTier )
}

array<ChallengeRewardDisplayData> function GetChallengeRewardDisplayData( ItemFlavor challenge, int tierIdx, bool showDiagonalWeapons, bool shouldUseBadgeRuis, bool tinyLabelToTheLeft )
{
	array<ChallengeRewardDisplayData> displayData = []

	ItemFlavorBag rewards = Challenge_GetRewards( challenge, tierIdx )

	if ( Challenge_GetTimeSpanKind( challenge ) == eChallengeTimeSpanKind.EVENTSHOP_DAILY_CHALLENGE )
	{
		foreach ( int itemIndex, ItemFlavor flav in rewards.flavors )
		{
			ChallengeRewardDisplayData data
			data.flav = flav
			data.originalQuantity = rewards.quantities[itemIndex]
			data.displayQuantity = data.originalQuantity
			data.style = eChallengeRewardStyle.ITEM_GENERAL
			data.rarityTier = ItemFlavor_GetQuality( flav, eRarityTier.COMMON )
			data.icon = CustomizeMenu_GetRewardButtonImage( flav )
			data.tinyLabelPlacementStyle = tinyLabelToTheLeft ? eTinyLabelPlacementStyle.LEFT : eTinyLabelPlacementStyle.CENTER
			data.tinyLabelText = Localize( "#PLUS_N", FormatAndLocalizeNumber( "1", float( data.displayQuantity ), false ) )

			displayData.append( data )
		}

		return displayData
	}

	foreach ( int itemIdx, ItemFlavor flav in rewards.flavors )
	{
		ChallengeRewardDisplayData crdd
		crdd.flav                    = flav
		crdd.originalQuantity        = rewards.quantities[itemIdx]
		crdd.displayQuantity         = crdd.originalQuantity
		crdd.style                   = eChallengeRewardStyle.ITEM_GENERAL
		crdd.rarityTier              = ItemFlavor_GetQuality( flav, eRarityTier.COMMON )
		crdd.icon                    = CustomizeMenu_GetRewardButtonImage( flav )
		crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.NONE

		if ( ItemFlavor_GetType( flav ) == eItemType.voucher )
		{
			bool foundQuantity = false
			if ( Voucher_GetEffectStatRef( flav ) != null && Voucher_GetEffectStatAmount( flav ) > 0 )
			{
				crdd.tinyLabelPlacementStyle = tinyLabelToTheLeft ? eTinyLabelPlacementStyle.LEFT : eTinyLabelPlacementStyle.CENTER
			}

			if ( Voucher_GetEffectBattlepassStars( flav ) > 0 )
			{
				crdd.displayQuantity *= Voucher_GetEffectBattlepassStars( flav )
				if ( tinyLabelToTheLeft )
				{
					crdd.tinyLabelText           = Localize( "#PLUS_N", FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false ) )
					crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.LEFT
				}
				else
				{
					crdd.tinyLabelText           = FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false )
					crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.CENTER
				}
			}

			if ( Voucher_GetEffectBattlepassLevels( flav ) > 0 )
			{
				if ( !foundQuantity )
				{
					foundQuantity = true
					crdd.displayQuantity *= Voucher_GetEffectBattlepassLevels( flav )
					crdd.icon     = $"rui/menu/challenges/challenges_icon_levelup"

					
					crdd.tinyLabelPlacementStyle = tinyLabelToTheLeft ? eTinyLabelPlacementStyle.LEFT : eTinyLabelPlacementStyle.NONE
					crdd.tinyLabelText           = tinyLabelToTheLeft ? Localize( "#PLUS_N", FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false ) ) : ""
				}
				else
				{
					Warning( "Challenge reward voucher gives multiple kinds of points -- this isn't yet supported properly!" )
				}
			}

			if ( Voucher_GetEffectAccountXP( flav ) > 0 )
			{
				if ( !foundQuantity )
				{
					foundQuantity = true
					crdd.displayQuantity *= Voucher_GetEffectAccountXP( flav )

					if ( tinyLabelToTheLeft )
					{
						crdd.tinyLabelText           = Localize( "#PLUS_N", FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false ) )
						crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.LEFT
					}
					else
					{
						crdd.tinyLabelText           = FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false )
						crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.CENTER
					}
				}
				else
				{
					Warning( "Challenge reward voucher gives multiple kinds of points -- this isn't yet supported properly!" )
				}
			}

			if ( Voucher_GetEffectStatRef( flav ) != null && Voucher_GetEffectStatAmount( flav ) != 0 )
			{
				if ( !foundQuantity )
				{
					foundQuantity = true
					crdd.displayQuantity *= Voucher_GetEffectStatAmount( flav )

					asset voucherImage = ItemFlavor_GetIcon( flav )
					if ( voucherImage != $"" )
						crdd.icon = voucherImage
				}
				else
				{
					Warning( "Challenge reward voucher gives multiple kinds of points -- this isn't yet supported properly!" )
				}
			}
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.weapon_skin )
		{
			if ( showDiagonalWeapons )
			{
				crdd.style = eChallengeRewardStyle.ITEM_WEAPON_SKIN
				crdd.icon  = WeaponItemFlavor_GetHudIcon( WeaponSkin_GetWeaponFlavor( flav ) )
			}
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.gladiator_card_badge )
		{
			if ( shouldUseBadgeRuis )
			{
				crdd.style     = eChallengeRewardStyle.ITEM_BADGE
				crdd.icon      = $""
				crdd.badgeFlav = flav
			}

			
			int badgeTier = 0
			for ( int prevTierIdx = 0; prevTierIdx < tierIdx; prevTierIdx++ )
			{
				ItemFlavorBag prevTierRewards = Challenge_GetRewards( challenge, prevTierIdx )
				if ( prevTierRewards.flavors.contains( flav ) )
					badgeTier++
			}

			crdd.badgeTier = badgeTier
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.account_currency || ItemFlavor_GetType( flav ) == eItemType.apex_coins )
		{
			
			crdd.tinyLabelPlacementStyle = eTinyLabelPlacementStyle.BOTTOM
			crdd.tinyLabelText           = FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false )
		}
		else if ( ItemFlavor_GetType( flav ) == eItemType.character_skin )
		{
			crdd.isMythicSkin = Challenge_GetTimeSpanKind( challenge ) == eChallengeTimeSpanKind.MYTHIC
			if ( crdd.isMythicSkin )
				crdd.badgeTier = tierIdx + 1
		}

		if ( crdd.tinyLabelText == "" )
			crdd.tinyLabelText = crdd.displayQuantity > 1 ? FormatAndLocalizeNumber( "1", float( crdd.displayQuantity ), false ) : ""

		displayData.append( crdd )
	}

	











	return displayData
}
















































































































































































































































string function Challenge_GetDescription( ItemFlavor challenge, int tier, bool getAlt = false )
{
	int tierCount = Challenge_GetTierCount( challenge )
	Assert( tier >= 0 && tier < tierCount , "Tier: " + tier + ", tierCount: " + tierCount )

	int challengeGoal = Challenge_GetGoalVal( challenge, tier, getAlt )

	var tierData = Challenge_GetTierDataBlock( challenge, tier )

	string challengeDisplay = FormatAndLocalizeNumber( "1", float( Challenge_GetGoalDisplayVal( challenge, tier, getAlt ) ), true )

	string tierDescription = getAlt ? GetSettingsBlockString( tierData, "descriptionAlt" ) : GetSettingsBlockString( tierData, "description" )
	if ( getAlt && tierDescription == "" )
		tierDescription = GetSettingsBlockString( tierData, "description" )

	string ornull result = null

	array<ItemFlavor> characterFlavors = Challenge_GetCharacterItemFlavors( challenge, tier )

	switch ( characterFlavors.len() )
	{
		case 0:
			result = Localize( tierDescription, challengeDisplay )
			break

		case 1:
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ) )
			break

		case 2:
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[1] ) )  )
			break

		case 3:
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[1] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[2] ) )  )
			break

		case 4:
			result = Localize( tierDescription, challengeDisplay, Localize( ItemFlavor_GetLongName( characterFlavors[0] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[1] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[2] ) ), Localize( ItemFlavor_GetLongName( characterFlavors[3] ) )  )
			break

		default:
			Assert( false, "Invalid number of character flavors referened in challenge " + string(ItemFlavor_GetAsset( challenge )) + " tier " + tier )
			break
	}

	Assert( result != null )
	return expect string(result)
}




bool function DoesPlayerHaveChallenge( entity player, ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	return (flavor in pcs.challengeStateMap)
}


















































































































































































































































































bool function IsChallengeTierComplete( entity player, ItemFlavor challenge, int tier, bool getAlt = false )
{
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challenge ) )

	int goalVal  = Challenge_GetGoalVal( challenge, tier, getAlt ? true : false )
	int progress = Challenge_GetProgressValue( player, challenge, tier, getAlt ? true : false )
	return progress >= goalVal
}












































































































array<ItemFlavor> function GetAllChallenges()
{
	
	return GetAllItemFlavorsOfType( eItemType.challenge )
}




array<ItemFlavor> function GetAllChallengesOfTimespan( int timeSpan, int weekIndex = -1 )
{
	Assert( timeSpan >= 0 && timeSpan < eChallengeTimeSpanKind.len() )
	Assert( (timeSpan == eChallengeTimeSpanKind.SEASON_WEEKLY) == (weekIndex > 0) )

	array<ItemFlavor> results = []

	if ( fileLevel.currentSeason.expirationTimestamp < GetUnixTimestamp() )
		RefreshCachedSeasonInfo()

	
	if ( fileLevel.currentSeason.battlePassOrNull == null && timeSpan != eChallengeTimeSpanKind.MYTHIC )
		return results

	switch ( timeSpan )
	{
		case eChallengeTimeSpanKind.BEGINNER:
		case eChallengeTimeSpanKind.EVENT:
		case eChallengeTimeSpanKind.MYTHIC:
			foreach ( ItemFlavor challenge in GetAllChallenges() )
			{
				if ( Challenge_GetTimeSpanKind( challenge ) == timeSpan )
				{
					if ( IsChallengePlaylistEnabled( challenge ) )
						results.append( challenge )
				}
			}
			break

		case eChallengeTimeSpanKind.SEASON_WEEKLY:
		case eChallengeTimeSpanKind.SEASON_WEEKLY_RECURRING:
		case eChallengeTimeSpanKind.DAILY:
			ItemFlavor pass = expect ItemFlavor( fileLevel.currentSeason.battlePassOrNull )
			foreach ( challenge in GetBattlePassChallenges( pass, timeSpan, weekIndex ) )
			{
				if ( IsChallengePlaylistEnabled( challenge ) )
					results.append( challenge )
			}
			break
	}

	return results
}































































































































































































































































































































































#if DEV
string function AddPadding( string str, int minWidth = 8 )
{
	int len = str.len()
	while ( len < minWidth )
	{
		str = str + " "
		len++
	}
	return str
}
#endif


int function Challenge_GetCurrentTier( entity player, ItemFlavor flavor )
{
#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return 0
#endif
	
	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	Assert( flavor in pcs.challengeStateMap, "Called Challenge_GetCurrentTier for challenge " + string(ItemFlavor_GetAsset( flavor )) + " but it was not assigned to the player " + string(player) )

	if ( !Challenge_IsAssigned( player, flavor ) )
	{
		
		return 0
	}

	ChallengeState cs = pcs.challengeStateMap[flavor]
	return player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].currentTier" )
}



bool function Challenge_IsAssigned( entity player, ItemFlavor flavor )
{
	
	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	return (flavor in pcs.challengeStateMap)
}




bool function Challenge_IsComplete( entity player, ItemFlavor flavor )
{
	int currentTier = Challenge_GetCurrentTier( player, flavor )
	int tierCount   = Challenge_GetTierCount( flavor )
	Assert( currentTier <= tierCount, "Player has a higher current tier than should be possible for Challenge " + string(ItemFlavor_GetAsset( flavor )) )
	return (currentTier == tierCount)
}



bool function Challenge_IsAllComplete( entity player, array< ItemFlavor > challengeFlavs )
{
	foreach ( ItemFlavor challenge in challengeFlavs )
	{
		if ( !Challenge_IsComplete( player, challenge ) )
		{
			return false
		}
	}

	return true
}




int function Challenge_GetTierCount( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	var settingsBlock = ItemFlavor_GetSettingsBlock( flavor )
	return GetSettingsArraySize( GetSettingsBlockArray( settingsBlock, "tiers" ) )
}




int function Challenge_GetTimeSpanKind( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	string key = GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "timeSpan" )
	Assert( key in eChallengeTimeSpanKind, format( "Challenge %s has invalid time span kind: %s", string(ItemFlavor_GetAsset( flavor )), key ) )
	return eChallengeTimeSpanKind[key]
}



bool function Challenge_IsBoostEnabled( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "isBoostEnabled" )
}



bool function Challenge_IsSingleMatch( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockString( tierData, "matchRequirement" ) == "inSingleMatch"
}




bool function Challenge_IsStreak( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockString( tierData, "matchRequirement" ) == "requiresStreak"
}




array<ItemFlavor> function Challenge_GetCharacterItemFlavors( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierBlock = Challenge_GetTierDataBlock( flavor, tier )

	array<ItemFlavor> characters = []
	var charactersArray          = GetSettingsBlockArray( tierBlock, "characters" )
	foreach ( var characterBlock in IterateSettingsArray( charactersArray ) )
	{
		asset characterAsset = GetSettingsBlockAsset( characterBlock, "flavor" )
		if ( IsValidItemFlavorSettingsAsset( characterAsset ) )
			characters.append( GetItemFlavorByAsset( characterAsset ) )
	}

	return characters
}




int function Challenge_GetGoalVal( ItemFlavor flavor, int tier, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	if ( Challenge_IsMetaChallenge( flavor ) )
	{
		return MetaChallenge_GetGoalVal( flavor )
	}

	if ( fileLevel.hasPlaylistChallengeOverrides )
	{
		int override = getAlt ? GetCurrentPlaylistVarInt( format( "%s_goal_alt_%i", ItemFlavor_GetGUIDString( flavor ), tier ), -1 ) :
			GetCurrentPlaylistVarInt( format( "%s_goal_%i", ItemFlavor_GetGUIDString( flavor ), tier ), -1 )
		if ( override > -1 )
			return override
	}

	var tierData = Challenge_GetTierDataBlock( flavor, tier )
	if ( getAlt )
		return GetSettingsBlockInt( tierData, "goalValAlt" )

	return GetSettingsBlockInt( tierData, "goalVal" )
}



int function Challenge_GetGoalDisplayVal( ItemFlavor flavor, int tier, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	int val = Challenge_GetGoalVal( flavor, tier, getAlt )

	var tierData                 = Challenge_GetTierDataBlock( flavor, tier )
	bool displaySecondsAsMinutes = GetSettingsBlockBool( tierData, "convertSecondsToMinutesDisplay" )

	int challengeDisplay = displaySecondsAsMinutes ? int(float( val ) / 60.0) : val

	return challengeDisplay
}



string function Challenge_GetGRXRewardSequenceRef( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "grxRewardSequenceRef" )
}




int function Challenge_GetBPStarsReward( ItemFlavor challengeFlav, int tierIdx )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )

	int total             = 0
	ItemFlavorBag rewards = Challenge_GetRewards( challengeFlav, tierIdx )
	foreach ( int rewardIdx, ItemFlavor rewardFlav in rewards.flavors )
	{
		if ( ItemFlavor_GetType( rewardFlav ) != eItemType.voucher )
			continue

		int points = Voucher_GetEffectBattlepassStars( rewardFlav )
		if ( points <= 0 )
			continue

		total += points * rewards.quantities[rewardIdx]
	}
	return total
}



int function Challenge_GetBattlepassLevelsReward( ItemFlavor challengeFlav, int tierIdx )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )

	int total             = 0
	ItemFlavorBag rewards = Challenge_GetRewards( challengeFlav, tierIdx )
	foreach ( int rewardIdx, ItemFlavor rewardFlav in rewards.flavors )
	{
		if ( ItemFlavor_GetType( rewardFlav ) != eItemType.voucher )
			continue

		int levels = Voucher_GetEffectBattlepassLevels( rewardFlav )
		if ( levels <= 0 )
			continue

		total += levels * rewards.quantities[rewardIdx]
	}
	return total
}




ItemFlavorBag function Challenge_GetRewards( ItemFlavor challengeFlav, int tier )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challengeFlav ) )

	var tierData = Challenge_GetTierDataBlock( challengeFlav, tier )

	ItemFlavorBag rewards
	foreach ( int rewardIdx, var rewardData in IterateSettingsArray( GetSettingsBlockArray( tierData, "rewards" ) ) )
	{
		asset rewardAsset = GetSettingsBlockAsset( rewardData, "flavor" )
		if ( !IsValidItemFlavorSettingsAsset( rewardAsset ) )
		{
			Warning( "Skipping item reward #%d of challenge '%s' because the asset is not a valid item flavor: '%s'", rewardIdx, string(ItemFlavor_GetAsset( challengeFlav )), string(rewardAsset) )
			continue
		}

		rewards.flavors.append( GetItemFlavorByAsset( rewardAsset ) )
		rewards.quantities.append( GetSettingsBlockInt( rewardData, "quantity" ) )
	}
	return rewards
}




bool function Challenge_LastTierIsInfinite( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "lastTierIsInfinite" )
}








































int function Challenge_GetWeekNumber( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsInt( ItemFlavor_GetAsset( flavor ), "weekNumber" )
}




int function Challenge_GetProgressValue( entity player, ItemFlavor challengeFlav, int tier, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( challengeFlav ) )

#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return 0
#endif

	PlayerChallengesState pcs = GetPlayerChallengesState( player )
	Assert( challengeFlav in pcs.challengeStateMap, "Called Challenge_GetActiveTier for challenge " + string(ItemFlavor_GetAsset( challengeFlav )) + " but it was not assigned to the player " + player )

	if ( !Challenge_IsAssigned( player, challengeFlav ) )
	{
		
		return 0
	}

	ChallengeState cs = pcs.challengeStateMap[challengeFlav]

	int goalVal = Challenge_GetGoalVal( challengeFlav, tier, getAlt )

	int currentTier = player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].currentTier" )

	
	if ( tier < currentTier )
		return goalVal

	
	if ( tier > currentTier )
		return 0

	int current            = 0
	array<string> statRefs = Challenge_GetStatRefs( challengeFlav, tier, getAlt )
	foreach ( string statRef in statRefs )
	{
		Assert( IsValidStatEntryRef( statRef ) )
		StatEntry entry = GetStatEntryByRef( statRef )
		Assert( entry.type == eStatType.INT )

	current += GetStat_Int( player, entry, eStatGetWhen.CURRENT, fileLevel.forceNoCache )



	}

	int marker = getAlt ? player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarkerAlt" ) :
		player.GetPersistentVarAsInt( "challenges[" + cs.persistenceIdx + "].statMarker" )

	
	

	int progress = current - marker

	if ( progress < 0 )
		return 0

	if ( progress > goalVal )
		return goalVal

	return progress
}













int function Challenge_GetProgressDisplayValue( entity player, ItemFlavor challengeFlav, int tier )
{
	int val = Challenge_GetProgressValue( player, challengeFlav, tier )

	var tierData                 = Challenge_GetTierDataBlock( challengeFlav, tier )
	bool displaySecondsAsMinutes = GetSettingsBlockBool( tierData, "convertSecondsToMinutesDisplay" )

	int challengeDisplay = displaySecondsAsMinutes ? int(float( val ) / 60.0) : val

	return challengeDisplay
}



ItemFlavor function Challenge_GetSource( ItemFlavor challengeFlav )
{
	Assert( ItemFlavor_GetType( challengeFlav ) == eItemType.challenge )
	return fileLevel.challengeSourceMap[challengeFlav]
}




var function Challenge_GetTierDataBlock( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var settingsBlock      = ItemFlavor_GetSettingsBlock( flavor )
	var tierDataBlockArray = GetSettingsBlockArray( settingsBlock, "tiers" )

	return GetSettingsArrayElem( tierDataBlockArray, tier )
}



int function Challenge_GetPostGamePersistenceIndex( entity player, int challengeGuid )
{
	for ( int pIdx = 0; pIdx < NUM_CHALLENGES_MAX; pIdx++ )
	{
		string pKey = format( "postGameChallengesProgress[%i].guid", pIdx )
		if ( player.GetPersistentVarAsInt( pKey ) == challengeGuid )
		{
			return pIdx
		}
	}

	Warning( format( "Could not find challenge with guid '%i' in persistence postGameChallengesProgress", challengeGuid ) )
	return -1
}



array<string> function Challenge_GetStatRefs( ItemFlavor flavor, int tier, bool getAlt = false )
{
	array<string> statRefs  = []

	if ( Challenge_IsMetaChallenge( flavor ) )
	{
		string metaChallengeStatRef = format( "stats.%s", MetaChallenge_GetStatRef( flavor ) )
		if ( metaChallengeStatRef != "" )
		{
			statRefs.append( metaChallengeStatRef )
			return statRefs 
		}
	}

	if ( ItemFlavor_ChallengesHaveMetaData() )
	{
		Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

		table<string, string> ornull metaData = ItemFlavor_GetMetaData( flavor )
		expect table<string, string>(metaData)
		int tierCount = int(metaData[ CHALLENGE_TIER_COUNT ])

		Assert( tier >= 0 && tier < tierCount )

		int statCount = int(metaData[ format( CHALLENGE_TIER_STAT_COUNT, tier ) ])

		for ( int i = 0; i < statCount; i++ )
		{
			if ( getAlt )
				statRefs.append( metaData[ format( CHALLENGE_TIER_STAT_ALT_REF, tier, i ) ] )
			else
				statRefs.append( metaData[ format( CHALLENGE_TIER_STAT_REF, tier, i ) ] )
		}
	}
	else
	{
		Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
		Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

		var tierData = Challenge_GetTierDataBlock( flavor, tier )

		string specifiedStatRef = getAlt ? GetSettingsBlockString( tierData, "statRefAlt" ) : GetSettingsBlockString( tierData, "statRef" )

		if ( specifiedStatRef.find( "%char%" ) > -1 )
		{
			array<ItemFlavor> characterFlavors = Challenge_GetCharacterItemFlavors( flavor, tier )
			Assert( characterFlavors.len() > 0, format( "Challenge %s tier %i uses char stat ref but doesn't have a character flavor associated with it", string(ItemFlavor_GetAsset( flavor )), tier ) )
			foreach ( ItemFlavor character in characterFlavors )
			{
				statRefs.append( replace( specifiedStatRef, "%char%", ItemFlavor_GetGUIDString( character ) ) )
			}
		}
		else
		{
			statRefs.append( specifiedStatRef )
		}
	}

	return statRefs
}



int function Challenge_GetDifficulty( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	string key = GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "difficulty" )
	Assert( key in eChallegeDifficulty, format( "Challenge %s has invalid difficulty kind: %s", string(ItemFlavor_GetAsset( flavor )), key ) )
	return eChallegeDifficulty[key]
}



int function Challenge_GetGameMode( ItemFlavor flavor, bool getAlt = false )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	string key = getAlt ? GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "modeAlt" ) :
		GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "mode" )

	Assert( key in eChallengeGameMode, format( "Challenge %s has invalid mode kind: %s", string(ItemFlavor_GetAsset( flavor )), key ) )
	return eChallengeGameMode[key]
}



string function Challenge_GetGameModeTag( int key )
{
	if ( key in GAME_MODE_TAG )
		return GAME_MODE_TAG[ key ]

	return ""
}



vector function Challenge_GetGameModeTagColor( int key )
{
	if ( key in GAME_MODE_TAG_COLOR )
		return GAME_MODE_TAG_COLOR[ key ]

	return < 0, 0, 0 >
}



bool function Challenge_ShouldStartAtZero( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockString( tierData, "progressAccrual" ) == "startAtZero"
}




bool function Challenge_ShouldAddProgressFromPrevTier( ItemFlavor flavor, int tier )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )
	Assert( tier >= 0 && tier < Challenge_GetTierCount( flavor ) )

	var tierData = Challenge_GetTierDataBlock( flavor, tier )

	return GetSettingsBlockString( tierData, "progressAccrual" ) == "addProgressFromPrevTier"
}




bool function Challenge_IsPremium( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "isPremium" )
}



bool function Challenge_IsEitherOr( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.challenge )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "isEitherOr" )
}


















int function GetCompletedChallengeCount( entity player, array<ItemFlavor> challenges )
{
	int count = 0

	foreach ( ItemFlavor challenge in challenges )
	{
		int maxTier = Challenge_GetTierCount( challenge ) - 1
		Assert( maxTier >= 0 )

		
		if ( maxTier < 0 )
			continue

		if ( IsChallengeTierComplete( player, challenge, maxTier ) || ( Challenge_IsEitherOr( challenge ) && IsChallengeTierComplete( player, challenge, maxTier, true ) ) )
			count++
	}

	return count
}






























void function ChallengeDbg( entity player, string label, ... )
{
	table stackInfos = expect table(getstackinfos( 2 ))
	string str       = format( "[ChallengeDbg %s %s %s %d %s] %s",
		expect string(stackInfos.src),
		SERVER ? "SV" : CLIENT ? "CL" : UI ? "UI" : "??",
		expect string(stackInfos.func),
		expect int(stackInfos.line),
		string(player),
		label
	)
	for ( int argIdx = 0; argIdx < vargc; argIdx += 2 )
	{
		if ( argIdx > 0 )
			str += "; "

		string key = expect string(vargv[argIdx + 0])
		var val    = vargv[argIdx + 1]
		str += key
		str += "= "
		str += string(val)
	}
	str += "\n"
	print( str )
	SpamLog( str )
}

bool function IsCalendarCategory( int challengeCategory )
{
	return ( challengeCategory == eChallengeCategory.DAILY ) || ( challengeCategory == eChallengeCategory.TOP_WEEKLY )
}

bool function IsPreferredCalendarCategory( int challengeCategory )
{
	if ( !IsCalendarCategory( challengeCategory ) )
		return false

	int preferredCalendar = file.hasCompletedRegularDailies ? eChallengeCategory.TOP_WEEKLY : eChallengeCategory.DAILY

	return ( challengeCategory == preferredCalendar )
}

bool function IsBeginnerCategory( int challengeCategory )
{
	return ( challengeCategory == eChallengeCategory.BEGINNER )
}

bool function IsEventCategory( int challengeCategory )
{
	switch ( challengeCategory )
	{
		case eChallengeCategory.EVENT_00:
		case eChallengeCategory.EVENT_01:
		case eChallengeCategory.EVENT_02:
		case eChallengeCategory.EVENT_03:
			return true
	}

	return false
}

bool function IsStoryCategory( int challengeCategory )
{
	switch ( challengeCategory )
	{
		case eChallengeCategory.STORY_00:
		case eChallengeCategory.STORY_01:
		case eChallengeCategory.STORY_02:
		case eChallengeCategory.STORY_03:
			return true
	}

	return false
}

bool function IsRewardCampaignChallengeCategory( int challengeCategory )
{
	return challengeCategory == eChallengeCategory.REWARD_CAMPAIGN
}

bool function IsEventShopChallengeCategory( int challengeCategory )
{
	return challengeCategory == eChallengeCategory.EVENTSHOP_DAILY_CHALLENGE || challengeCategory == eChallengeCategory.EVENTSHOP_EVENT_CHALLENGE
}

bool function IsEventShopEventChallengeCategory( int challengeCategory )
{
	return challengeCategory == eChallengeCategory.EVENTSHOP_EVENT_CHALLENGE
}

ItemFlavor ornull function GetActiveBuffetEventForCategory( int t, int currCat )
{
	return GetActiveBuffetEventForIndex( t, currCat - eChallengeCategory.EVENT_00 )
}

ItemFlavor ornull function GetActiveStoryEventForCategory( int t, int currCat )
{
	return GetActiveStoryEventForIndex( t, currCat - eChallengeCategory.STORY_00 )
}

void function RefreshCachedSeasonInfo()
{
	fileLevel.currentSeason.calEventOrNull = GetActiveSeason( GetUnixTimestamp() )
	fileLevel.currentSeason.battlePassOrNull = GetActiveBattlePass()
	if ( fileLevel.currentSeason.calEventOrNull != null )
		fileLevel.currentSeason.expirationTimestamp = CalEvent_GetFinishUnixTime( expect ItemFlavor( fileLevel.currentSeason.calEventOrNull ) )
}



array<int> function Challenge_EitherOr_GetGoalVals( ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )

	array<int> goalVals = [ 0, 0 ]

	goalVals[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetGoalVal( flavor, 0 )
	goalVals[ ALT_CHALLENGE_INDEX ] = Challenge_GetGoalVal( flavor, 0, true )

	return goalVals
}



array<int> function Challenge_EitherOr_GetProgressValues( entity player, ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )

	array<int> progressValues = [ 0, 0 ]

	progressValues[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetProgressValue( player, flavor, 0 )
	progressValues[ ALT_CHALLENGE_INDEX ] = Challenge_GetProgressValue( player, flavor, 0, true )

	return progressValues
}



array< array<string> > function Challenge_EitherOr_GetStatRefs( ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )
	array<string> empty = []
	array< array<string> > statRefs = [ empty, empty ]

	statRefs[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetStatRefs( flavor, 0 )
	statRefs[ ALT_CHALLENGE_INDEX ] = Challenge_GetStatRefs( flavor, 0, true )

	return statRefs
}



array<int> function Challenge_EitherOr_GetGameModes( ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )

	array<int> gameModes = [ 0, 0 ]

	gameModes[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetGameMode( flavor )
	gameModes[ ALT_CHALLENGE_INDEX ] = Challenge_GetGameMode( flavor, true )

	return gameModes
}



array<string> function Challenge_EitherOr_GetDescriptions( ItemFlavor flavor )
{
	Assert( Challenge_IsEitherOr( flavor ) )

	array<string> descriptions = [ "", "" ]

	descriptions[ PRIMARY_CHALLENGE_INDEX ] = Challenge_GetDescription( flavor, 0 )
	descriptions[ ALT_CHALLENGE_INDEX ] = Challenge_GetDescription( flavor, 0, true )

	return descriptions
}



bool function Challenge_CanBeCompletedInBR( ItemFlavor flavor )
{
	if ( Challenge_IsEitherOr( flavor ) )
		return true

	if ( Challenge_GetGameMode( flavor) == eChallengeGameMode.BATTLE_ROYALE )
		return true

	if ( Challenge_GetGameMode( flavor) == eChallengeGameMode.ANY )
		return true

	if ( Challenge_GetGameMode( flavor) == eChallengeGameMode.NON_MODE )
		return true

	return false

}




void function SpecialEventChallengeToolTipSetup( var button, ItemFlavor challenge, ToolTipData toolTipData )
{
	
	
	
	
	

	
	
	
	
	

	
	
	
	
	

	
	
	
	
	

	
	
	
	
	
}


bool function Challenge_IsMetaChallenge( ItemFlavor challengeFlav )
{
	asset challengeAsset = ItemFlavor_GetAsset( challengeFlav )
	return GetGlobalSettingsBool( challengeAsset, "isMetaChallenge" )
}



string function MetaChallenge_GetStatRef( ItemFlavor challengeFlav )
{
	if ( Challenge_IsMetaChallenge( challengeFlav ) )
	{
		ItemFlavor parentFlav = MetaChallenge_GetParentFlav( challengeFlav )
		string statRef = format( "metaChallenge_%s", ItemFlavor_GetGUIDString( parentFlav ) )
		return statRef

	}
	Assert( false, format( "%s is not a metachallenge!", ItemFlavor_GetGUIDString( challengeFlav ) ) )
	return ""
}



ItemFlavor function MetaChallenge_GetParentFlav( ItemFlavor challengeFlav )
{
	asset challengeAsset = ItemFlavor_GetAsset( challengeFlav )
	string parentType = GetGlobalSettingsString( challengeAsset, "typeOfMetaChallenge" )
	asset parentAsset
	switch ( parentType )
	{
		case "CHALLENGE_SET":
			parentAsset = GetGlobalSettingsAsset( challengeAsset, "challengeSet" )
			break
		case "CHALLENGE_COLLECTION":
			parentAsset = GetGlobalSettingsAsset( challengeAsset, "challengeCollection" )
			break
		case "REWARD_CAMPAIGN":
			parentAsset = GetGlobalSettingsAsset( challengeAsset, "rewardCampaign" )
			break
		default:
			Assert( false, "Invalid parent type for meta challenge!" )
	}

	Assert( parentAsset != $"", format( "The parent challengeSet, challengeCollection, or rewardCampaign was not set for metaChallenge %s", ItemFlavor_GetGUIDString( challengeFlav ) ) ) 
	ItemFlavor parentFlav = GetItemFlavorByAsset( parentAsset )
	return parentFlav
}



int function MetaChallenge_GetGoalVal( ItemFlavor challengeFlav )
{
	Assert ( Challenge_IsMetaChallenge( challengeFlav ) )
	ItemFlavor parentFlav = MetaChallenge_GetParentFlav( challengeFlav )

	switch ( ItemFlavor_GetType( parentFlav ) )
	{
		case eItemType.calevent_challenge_set:
			ChallengeSet set = ChallengeSet_GetByGUID( parentFlav.guid )
			return set.challenges.len()
		case eItemType.calevent_challenge_collection:
			ChallengeCollection col = ChallengeCollection_GetByGUID( parentFlav.guid )
			return col.challengeSets.len()
		case eItemType.calevent_reward_campaign:
			int numChallenges = RewardCampaign_GetChildChallenges( parentFlav ).len()
			return numChallenges
	}
	Assert( false, format( "Invalid meta challenge goal for %i", challengeFlav.guid ) )

	var tierData = Challenge_GetTierDataBlock( challengeFlav, 0 )
	return GetSettingsBlockInt( tierData, "goalVal" )
}

