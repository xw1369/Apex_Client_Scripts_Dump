
global function LootBoxCeremony_SharedInit












global function CLLootBoxCeremony_Init
global function UIToClient_LootCeremony_SetMenuHandles
global function UIToClient_EnterLootCeremony
global function UIToClient_AdditionalLootTick_Sequence
global function UIToClient_LootCeremonyExit
global function UIToClient_RewardPlacard_Hover
global function UIToClient_RewardInspectActivate
global function UIToClient_RewardInspectNavBack
global function UIToClient_TrackButtonOnClick
global function UIToClient_RewardEquipOnClick
global function UIToClient_RewardEquipOnClickWithIndex
global function UIToClient_RewardEquipToWheelOnClick
global function UIToClient_RewardEquipToWheelOnClickWithIndex
global function UIToClient_OnGRXPackOpeningResultsAvailable
global function UIToClient_SkipAnimation

global function UIToClient_SpecialItemPresentation
global function UIToClient_SpecialItemPresentationExit

global function IsLootCeremonyActive
global function IsSpecialItemPresentationModeActive

global function GetLootCeremonyFlashType



#if DEV
global function DEV_ShouldShowCustomLootRewards
global function DEV_SetCustomLootRewardsToDisplay
#endif


































global function IsItemEquipped
global function GetCurrentlyEquippedItemNameForItemTypeSlot
global function GetCurrentlyEquippedItemRarityForItemTypeSlot
global function EquipButton_GetItemLoadoutEntries



const float CAMERA_FOV = 35.5

const asset TICK_MODEL_DEFAULT = $"mdl/robots/drone_frag/drone_frag_loot.rmdl"
const asset TICK_FX_HOLO_BEAM_BASE = $"P_loot_triad_beam"
const asset TICK_FX_HOLO_BEAM_TIER1 = $"P_loot_triad_beam_reveal_T1"
const asset TICK_FX_HOLO_BEAM_TIER2 = $"P_loot_triad_beam_reveal_T2"
const asset TICK_FX_HOLO_BEAM_TIER3 = $"P_loot_triad_beam_reveal_T3"
const asset TICK_FX_HOLO_BEAM_TIER4 = $"P_loot_triad_beam_reveal_T4"
const asset TICK_FX_HOLO_BEAM_TIER5 = $"P_loot_triad_beam_reveal_T4"
const asset TICK_FX_HOLO_BEAM_TIER6 = $"P_loot_triad_beam_reveal_T6"
const asset TICK_FX_RARITY_IDLE = $"P_loot_tick_beam_idle_flash"
const asset TICK_FX_RARITY_BEAM_TIER1 = $"P_loot_tick_rarity_beam_T1"
const asset TICK_FX_RARITY_BEAM_TIER2 = $"P_loot_tick_rarity_beam_T2"
const asset TICK_FX_RARITY_BEAM_TIER3 = $"P_loot_tick_rarity_beam_T3"
const asset TICK_FX_RARITY_BEAM_TIER4 = $"P_loot_tick_rarity_beam_T4"
const asset TICK_FX_RARITY_BEAM_TIER5 = $"P_loot_tick_rarity_beam_T4"
const asset TICK_FX_RARITY_BEAM_TIER6 = $"P_loot_tick_rarity_beam_T6"
const asset TICK_FX_RARITY_FLASH_TIER1 = $"P_loot_tick_rarity_body_T1"
const asset TICK_FX_RARITY_FLASH_TIER2 = $"P_loot_tick_rarity_body_T2"
const asset TICK_FX_RARITY_FLASH_TIER3 = $"P_loot_tick_rarity_body_T3"
const asset TICK_FX_RARITY_FLASH_TIER4 = $"P_loot_tick_rarity_body_T4"
const asset TICK_FX_RARITY_FLASH_TIER5 = $"P_loot_tick_rarity_body_T4"
const asset TICK_FX_RARITY_FLASH_TIER6 = $"P_loot_tick_rarity_body_T6"

const asset TICK_FX_HEAD_CHARGE = $"P_loot_tick_head_charge"
const asset TICK_FX_JUMP_JET = $"P_loot_tick_jump_jet"
const string ATTACHNAME_LEFT = "FX_L_EYE"
const string ATTACHNAME_CENTER = "FX_R_EYE"        
const string ATTACHNAME_RIGHT = "FX_C_EYE"        
const array<string> TICK_LOOT_ATTACHMENTS = [ ATTACHNAME_LEFT, ATTACHNAME_CENTER, ATTACHNAME_RIGHT ]
const array<string> INSPECT_BUTTONS = [ "RewardLeftButton", "RewardCenterButton", "RewardRightButton" ]

global const asset CURRENCY_MODEL_COMMON = $"mdl/currency/crafting/currency_crafting_common.rmdl"
global const asset CURRENCY_MODEL_RARE = $"mdl/currency/crafting/currency_crafting_rare.rmdl"
global const asset CURRENCY_MODEL_EPIC = $"mdl/currency/crafting/currency_crafting_epic.rmdl"
global const asset CURRENCY_MODEL_LEGENDARY = $"mdl/currency/crafting/currency_crafting_legendary.rmdl"
const asset QUIP_BG_MODEL = $"mdl/menu/loot_ceremony_quip_bg.rmdl"
const asset STAT_TRACKER_BG_MODEL = $"mdl/menu/loot_ceremony_stat_tracker_bg.rmdl"
const asset LOADSCREEN_BG_MODEL = $"mdl/menu/generic_1920_1080_bg.rmdl"
const asset BP_GIFTING_TEMPLATE_MODEL = $"mdl/menu/generic_1570_740_bg.rmdl"

const asset FINISHER_SWAP_FX = $"P_menu_finisher_swap"

const string SOUND_DEPLOY_ZOOM = "LootCeremony_Tick_Deploy_Zoom"
const string SOUND_LIGHT_FLASH = "LootCeremony_Tick_LightFlash"
const string SOUND_BEAM_SWEETEN_TIER1 = "LootCeremony_Tick_Deploy_BeamSweetener_Rare"
const string SOUND_BEAM_SWEETEN_TIER2 = "LootCeremony_Tick_Deploy_BeamSweetener_Epic"
const string SOUND_BEAM_SWEETEN_TIER3 = "LootCeremony_Tick_Deploy_BeamSweetener_Legendary"
const string SOUND_BEAM_SWEETEN_TIER4 = "LootCeremony_Tick_Deploy_BeamSweetener_Heirloom"
const string SOUND_HOLOGRAM_FIRST_APPEAR = "LootCeremony_LootHologram_FirstAppear"
const string SOUND_HOLOGRAM_LOOP = "LootCeremony_Inspect_HologramLoop"
const string SOUND_HOLOGRAM_APPEAR_TIER0 = "LootCeremony_LootHologram_Appear_Common"
const string SOUND_HOLOGRAM_APPEAR_TIER1 = "LootCeremony_LootHologram_Appear_Rare"
const string SOUND_HOLOGRAM_APPEAR_TIER2 = "LootCeremony_LootHologram_Appear_Epic"
const string SOUND_HOLOGRAM_APPEAR_TIER3 = "LootCeremony_LootHologram_Appear_Legendary"
const string SOUND_HOLOGRAM_APPEAR_TIER4 = "LootCeremony_LootHologram_Appear_Heirloom"
const string SOUND_INSPECT_ZOOM_IN = "LootCeremony_Inspect_ZoomIn"
const string SOUND_INSPECT_ZOOM_OUT = "LootCeremony_Inspect_ZoomOut"
const string SOUND_EQUIP = "UI_Menu_Equip_Generic"
const string SOUND_HOLOGRAM_PREAPPEAR_TIER3 = "LootCeremony_LootHologram_PreAppear_Legendary"
const string SOUND_HOLOGRAM_PREAPPEAR_TIER4 = "LootCeremony_LootHologram_PreAppear_Legendary"
const string SOUND_HOLOGRAM_APPEAR_RESETVIEW = "LootCeremony_LootHologram_Appear_ResetView"

const int FINAL_TIER = 3








const array<int> INVALID_ITEM_TYPES_FOR_LOOT_CEREMONY = [
	eItemType.account_pack,
	eItemType.artifact_component_activation_emote,
	eItemType.artifact_component_power_source,
	eItemType.artifact_component_theme,
]



enum eLootCeremonyPackType
{
	APEX_PACK,

	COLLECTION_EVENT_PACK,
	MILESTONE_EVENT_PACK,

	MYTHIC_PACK,
	HEIRLOOM_PACK,

	THEMATIC_ITEM_TYPE_PACK,
	THEMATIC_WEAPON_PACK,
	THEMATIC_WEAPON_CATEGORY_PACK,
	THEMATIC_CHARACTER_PACK,

	COUNT
}



struct ItemPresentationData
{
	ItemFlavor& item
	int         quantity = 1
	string      attachment
	int         rarity
}



struct LootCeremonySortingData
{
	int packType

	int packThemeType					
	ItemFlavor ornull packTheme = null  
}



struct DummyInspectButtonData
{
	var  button
	bool shouldShow
}




struct GladiatorCardData
{
	NestedGladiatorCardHandle& handle
	var                        rui
	var                        topo = null
}





























struct FileLevelStruct
{




		table  signalDummy

		var                           menu
		var                           inspectMenu
		var                           equipButton
		var							  trackChallengeButton
		var                           equipToWheelButton
		var                           purchaseButton
		ItemFlavor&                   equipButtonItemFlavor
		ItemFlavor& 				  trackButtonItemFlavor
		var                           mouseClickElem
		var                           inspectVideoPanel
		array<DummyInspectButtonData> dummyInspectButtons
		var                           skipAnimButton
		bool                          menuActive = false
		bool                          inspectMenuIsNavigatingBack = false

		entity lootTickMover
		entity lootTickModel
		entity cameraMover
		entity cameraEnt

		table<string, var>            rewardPlacards = { RewardLeftButton = null, RewardCenterButton = null, RewardRightButton = null }
		array<entity>				  characterSkinModels
		bool						  inspectModeActive

		array< ItemPresentationData > itemPresentationDatas
		LootCeremonySortingData& lootCeremonySortingData

		bool specialItemPresentationModeActive = false

		
		ItemFlavor& currentPackFlav
		bool        grxRewardsReceived = false

		
		array<int> rarityBeamFXHandles
		bool       tickRandomFlashFXStarted = false

		array<PakHandle> pakHandles


#if DEV
		bool           debugShowCustomRewards = false
		array< asset > debugCustomRewardAssets = [
			$"settings/itemflav/character_skin/wraith/legendary_01.rpak",
			$"settings/itemflav/gcard_stance/wraith/epic_05.rpak",
			$"settings/itemflav/weapon_skin/hemlok/rare_04.rpak"
		]
#endif



























}
FileLevelStruct& fileLevel


void function LootBoxCeremony_SharedInit()
{
	Remote_RegisterServerFunction( "Server_GrantLegendaryStickersIfCollectionCompleted" )
	Remote_RegisterUIFunction( "ForceOpenRewardPacks" )
}























































































void function CLLootBoxCeremony_Init()
{
	RegisterSignal( "LootCeremonyExit" )
	RegisterSignal( "LootCeremonyAnimSeqStart" )
	RegisterSignal( "LootCeremonyInspectModeStart" )
	RegisterSignal( "LootCeremonyInspectModeStartComplete" )
	RegisterSignal( "LootCeremonyInspectModeEnd" )
	RegisterSignal( "LootCeremonyInspectModeEndComplete" )
	RegisterSignal( "LootCeremonyInspectCompleteOrBackout" )
	RegisterSignal( "LootCeremonyInspectTimeCompleteOrBackout" )
	RegisterSignal( "LootCeremonyInspectVideoCompleteOrBackout" )
	RegisterSignal( "LootCeremonyTimeComplete" )
	RegisterSignal( "LootCeremonyVideoComplete" )
	RegisterSignal( "TickAnimStartDisplayLoot" )
	RegisterSignal( "TickAnimStartDeployment" )
	RegisterSignal( "TickAnimSkip" )
	RegisterSignal( "LootCeremonyAnimShowLootOrSkip" )
	RegisterSignal( "LootCeremonyTickCancelAnim" )

	LootCeremonyLightingRigPreCache()

	AddCallback_FullUpdate( LootCeremonyOnFullUpdate )
	AddCallback_EntitiesDidLoad( EntitiesDidLoad )

	AddGlobalAnimEventTokenize( "loot_tick_rarity_random_flash_fx", OnLootTickAnimEvent )
	AddGlobalAnimEventTokenize( "loot_tick_rarity_beam_start_fx", OnLootTickAnimEvent )
	AddGlobalAnimEventTokenize( "loot_tick_rarity_beam_stop_fx", OnLootTickAnimEvent )
	AddGlobalAnimEventTokenize( "loot_tick_rarity_flash_start_fx", OnLootTickAnimEvent )
	AddGlobalAnimEventTokenize( "loot_tick_play_sound", OnLootTickAnimEvent )
}




void function EntitiesDidLoad()
{
	entity targetAnimRef = GetEntByScriptName( "target_loot_ceremony_ref" )
	fileLevel.lootTickMover = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", targetAnimRef.GetOrigin(), targetAnimRef.GetAngles() )
	fileLevel.lootTickModel = CreatePropDynamic( TICK_MODEL_DEFAULT, fileLevel.lootTickMover.GetOrigin(), fileLevel.lootTickMover.GetAngles() )

	
	table< string, table< string, vector > > tickAttachmentOriginsAngles
	Attachment camResult = fileLevel.lootTickModel.Anim_GetAttachmentAtTime( "loot_ceremony_tick_triads_idle", "CAMERA", 0 )
	foreach ( string attachment in TICK_LOOT_ATTACHMENTS )
	{
		tickAttachmentOriginsAngles[attachment] <- {}

		Attachment attachResult = fileLevel.lootTickModel.Anim_GetAttachmentAtTime( "loot_ceremony_tick_triads_idle", attachment, 0 )
		vector pos              = attachResult.position
		vector angles           = VectorToAngles( FlattenVec( camResult.position - pos ) )

		tickAttachmentOriginsAngles[ attachment ]["origin"] <- pos
		tickAttachmentOriginsAngles[ attachment ]["angles"] <- angles
	}
	InitLootCeremonyLightingRigs( tickAttachmentOriginsAngles )


	fileLevel.lootTickModel.SetParent( fileLevel.lootTickMover )
	thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_entrance_normal_idle", fileLevel.lootTickMover )
	HideEntityAndChildren( fileLevel.lootTickModel )

	fileLevel.cameraMover = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", targetAnimRef.GetOrigin(), targetAnimRef.GetAngles() )
	fileLevel.cameraEnt = CreateClientSidePointCamera( targetAnimRef.GetOrigin(), targetAnimRef.GetAngles(), CAMERA_FOV )
	fileLevel.cameraEnt.SetParent( fileLevel.cameraMover, "REF" )
	fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
}




void function UIToClient_LootCeremony_SetMenuHandles( var menu )
{
	fileLevel.menu = menu
	fileLevel.inspectMenu = Hud_GetChild( menu, "InspectBar" )
	fileLevel.equipButton = Hud_GetChild( menu, "InspectEquipButton" )
	fileLevel.trackChallengeButton = Hud_GetChild( menu, "TrackChallengeButton" )
	fileLevel.equipToWheelButton = Hud_GetChild( menu, "InspectEquipToWheelButton" )
	fileLevel.mouseClickElem = Hud_GetChild( menu, "ModelRotateMouseCapture" )
	fileLevel.inspectVideoPanel = Hud_GetChild( menu, "InspectVideoPanel" )

	fileLevel.dummyInspectButtons.clear()

	DummyInspectButtonData inspectButton1
	inspectButton1.button = Hud_GetChild( menu, "RewardLeftButton" )
	inspectButton1.shouldShow = false
	fileLevel.dummyInspectButtons.append( inspectButton1 )

	DummyInspectButtonData inspectButton2
	inspectButton2.button = Hud_GetChild( menu, "RewardCenterButton" )
	inspectButton2.shouldShow = false
	fileLevel.dummyInspectButtons.append( inspectButton2 )

	DummyInspectButtonData inspectButton3
	inspectButton3.button = Hud_GetChild( menu, "RewardRightButton" )
	inspectButton3.shouldShow = false
	fileLevel.dummyInspectButtons.append( inspectButton3 )

	fileLevel.skipAnimButton = Hud_GetChild( menu, "SkipAnimationButton" )
}





















void function UIToClient_OnGRXPackOpeningResultsAvailable()
{
	
	if ( !IsLootCeremonyActive() )
		return

	ItemFlavorBag bag = GRX_GetMostRecentPackOpeningResults()

	
	int error = GRX_INVENTORYERROR_NONE
	if ( bag.associatedError != GRX_INVENTORYERROR_NONE )
		error = bag.associatedError
	GRXPackOpened_ErrorHandling( error )

	
#if DEV
		if ( fileLevel.debugShowCustomRewards )
		{
			array< ItemFlavor > debugItems
			foreach ( asset itemAsset in fileLevel.debugCustomRewardAssets )
				debugItems.append( GetItemFlavorByAsset( itemAsset ) )

			bag.flavors = debugItems
		}
#endif

	fileLevel.itemPresentationDatas.clear()

	bool hasCurrency                      = false
	bool hasNonCurrency                   = false
	table<ItemFlavor, int> currencyCounts = {}
	foreach ( int bagEntryIdx, ItemFlavor bagEntryFlav in bag.flavors )
	{
		if ( ItemFlavor_GetType( bagEntryFlav ) == eItemType.account_currency )
		{
			hasCurrency = true
			if ( !(bagEntryFlav in currencyCounts) )
				currencyCounts[bagEntryFlav] <- 0
			currencyCounts[bagEntryFlav] += bag.quantities[bagEntryIdx]
		}
		else
		{
			hasNonCurrency = true
		}
	}

	bool hasJustCurrency = hasCurrency && hasNonCurrency == false && currencyCounts.len() == 1
	if ( hasJustCurrency )
	{
		




		ItemFlavor currencyFlav
		int currencyQty
		foreach ( ItemFlavor flav, int qty in currencyCounts )
		{ ; currencyFlav = flav; currencyQty = qty; break; }

		int middleQty = 0
		int leftQty   = 0
		int rightQty  = 0
		if ( currencyQty % 3 == 0 )
		{
			
			middleQty = currencyQty / 3
			leftQty   = middleQty
			rightQty  = middleQty
		}
		else if ( ( currencyQty - 100 ) % 3 == 0 )
		{
			
			middleQty = ( currencyQty - 100 ) / 3 + 100
			leftQty   = ( currencyQty - 100 ) / 3
			rightQty  = leftQty
		}
		else
		{
			
			
			middleQty = currencyQty / 3
			leftQty   = middleQty
			rightQty  = middleQty
		}
		
		middleQty += currencyQty - middleQty - leftQty - rightQty

		ItemPresentationData wtfLeft
		wtfLeft.item = currencyFlav
		wtfLeft.rarity = ItemFlavor_GetQuality( currencyFlav )
		wtfLeft.attachment = TICK_LOOT_ATTACHMENTS[0]
		wtfLeft.quantity = leftQty
		fileLevel.itemPresentationDatas.append( wtfLeft )

		ItemPresentationData wtfMiddle
		wtfMiddle.item = currencyFlav
		wtfMiddle.rarity = ItemFlavor_GetQuality( currencyFlav )
		wtfMiddle.attachment = TICK_LOOT_ATTACHMENTS[1]
		wtfMiddle.quantity = middleQty
		fileLevel.itemPresentationDatas.append( wtfMiddle )

		ItemPresentationData wtfRight
		wtfRight.item = currencyFlav
		wtfRight.rarity = ItemFlavor_GetQuality( currencyFlav )
		wtfRight.attachment = TICK_LOOT_ATTACHMENTS[2]
		wtfRight.quantity = rightQty
		fileLevel.itemPresentationDatas.append( wtfRight )
	}
	else if ( GRXPack_IsExpectedToContainSingleItemWithCurrency( fileLevel.currentPackFlav ) )
	{
		ItemFlavor ornull theSingleItemFlav = null
		ItemFlavor ornull theCurrencyFlav   = null
		int theCurrencyQty                  = 0
		foreach ( int bagEntryIdx, ItemFlavor bagEntryFlav in bag.flavors )
		{
			int bagEntryQty = bag.quantities[bagEntryIdx]
			if ( ItemFlavor_GetType( bagEntryFlav ) == eItemType.account_currency )
			{
				Assert( theCurrencyFlav == null || theCurrencyFlav == bagEntryFlav )
				theCurrencyFlav = bagEntryFlav
				theCurrencyQty += bagEntryQty
			}
			else
			{
				
				
				Assert( ItemFlavor_GetType( bagEntryFlav ) == eItemType.character_skin
				|| ItemFlavor_GetType( bagEntryFlav ) == eItemType.weapon_skin
				|| ItemFlavor_GetType( bagEntryFlav ) == eItemType.gladiator_card_stance
				|| ItemFlavor_GetType( bagEntryFlav ) == eItemType.music_pack )

				
				Assert( theSingleItemFlav == null )
				theSingleItemFlav = bagEntryFlav
			}
		}

		Assert( theSingleItemFlav != null )
		Assert( theCurrencyFlav != null )
		Assert( theCurrencyQty > 0 )

		if ( !IsEven( theCurrencyQty ) )
			Warning( "Pack %s gave an odd amount of currency but we expected an even amount: %d", string(ItemFlavor_GetAsset( fileLevel.currentPackFlav )), theCurrencyQty )

		int leftCurrencyAmount  = theCurrencyQty / 2
		int rightCurrencyAmount = theCurrencyQty - leftCurrencyAmount

		ItemPresentationData leftCurrencyIPD
		leftCurrencyIPD.item = expect ItemFlavor(theCurrencyFlav)
		leftCurrencyIPD.rarity = ItemFlavor_GetQuality( leftCurrencyIPD.item )
		leftCurrencyIPD.attachment = TICK_LOOT_ATTACHMENTS[0]
		leftCurrencyIPD.quantity = leftCurrencyAmount
		fileLevel.itemPresentationDatas.append( leftCurrencyIPD )

		ItemPresentationData theSingleItemIPD
		theSingleItemIPD.item = expect ItemFlavor(theSingleItemFlav)
		theSingleItemIPD.rarity = ItemFlavor_GetQuality( theSingleItemIPD.item )
		theSingleItemIPD.attachment = TICK_LOOT_ATTACHMENTS[1]
		fileLevel.itemPresentationDatas.append( theSingleItemIPD )

		ItemPresentationData rightCurrencyIPD
		rightCurrencyIPD.item = expect ItemFlavor(theCurrencyFlav)
		rightCurrencyIPD.rarity = ItemFlavor_GetQuality( rightCurrencyIPD.item )
		rightCurrencyIPD.attachment = TICK_LOOT_ATTACHMENTS[2]
		rightCurrencyIPD.quantity = rightCurrencyAmount
		fileLevel.itemPresentationDatas.append( rightCurrencyIPD )
	}
	else if ( bag.flavors.len() == 1 && Mythics_IsItemFlavorMythicSkin( bag.flavors[0] ) )
	{
		array<ItemFlavor> mythicSkins = Mythics_GetAllSkinsFromBase( bag.flavors[0] )

		Assert( FINAL_TIER == mythicSkins.len() )

		
		Remote_ServerCallFunction( "ClientCallback_UpdateMythicChallenges" )

		for ( int i = 0; i < mythicSkins.len(); i++ )
		{
			int attachmentIndex = i

			if ( i == 0 )
				attachmentIndex = 1
			else if ( i == 1 )
				attachmentIndex = 0

			ItemPresentationData data
			data.item = mythicSkins[i]
			data.rarity = eRarityTier.MYTHIC 
			data.attachment = TICK_LOOT_ATTACHMENTS[ attachmentIndex ]

			fileLevel.itemPresentationDatas.append( data )
		}
	}
	else
	{
		for ( int i = 0; i < bag.quantities.len(); i++ )
			Assert( bag.quantities[i] == 1, "Quantity is not 1 for loot ceremony item flavor: " + string(ItemFlavor_GetAsset( bag.flavors[i] )) )

		array<ItemFlavor> filteredAndSortedItemFlavors = FilterAndSortPackResults( bag.flavors )

		for ( int i = 0; i < filteredAndSortedItemFlavors.len(); i++ )
		{
			ItemFlavor flavor = filteredAndSortedItemFlavors[i]

			ItemPresentationData data
			data.item = flavor
			data.rarity = ItemFlavor_HasQuality( flavor ) ? ItemFlavor_GetQuality( flavor ) : 0
			data.attachment = TICK_LOOT_ATTACHMENTS[i]

			fileLevel.itemPresentationDatas.append( data )
		}
	}

	
	fileLevel.grxRewardsReceived = true
}




















bool function IsInvalidTypeForLootCeremony( int type )
{
	Assert( type < eItemType.COUNT, "Invalid eItemType : " + type )

	foreach ( int target in INVALID_ITEM_TYPES_FOR_LOOT_CEREMONY )
	{
		if ( target == type )
		{
			return true
		}
	}

	return false
}



void function UpdateLootCeremonySortingData()
{
	LootCeremonySortingData out

	int accountPackType = ItemFlavor_GetAccountPackType( fileLevel.currentPackFlav )

	switch ( accountPackType )
	{
		case eAccountPackType.MYTHIC:
		{
			
			out.packType = eLootCeremonyPackType.HEIRLOOM_PACK

			break
		}
		case eAccountPackType.THEMATIC:
		{
			asset themeAsset = GetGlobalSettingsAsset( ItemFlavor_GetAsset( fileLevel.currentPackFlav ), "themeFlavor" )
			if ( IsValidItemFlavorSettingsAsset( themeAsset ) )
			{
				out.packTheme = GetItemFlavorByAsset( themeAsset )
				out.packThemeType = ItemFlavor_GetType( expect ItemFlavor( out.packTheme ) )

				if ( out.packThemeType == eItemType.character )
				{
					out.packType = eLootCeremonyPackType.THEMATIC_CHARACTER_PACK
				}
				else if ( out.packThemeType == eItemType.weapon_category )
				{
					out.packType = eLootCeremonyPackType.THEMATIC_WEAPON_CATEGORY_PACK
				}
				else if ( out.packThemeType == eItemType.loot_main_weapon )
				{
					out.packType = eLootCeremonyPackType.THEMATIC_WEAPON_PACK
				}
				else
				{
					out.packType = eLootCeremonyPackType.THEMATIC_ITEM_TYPE_PACK 
				}
			}

			break
		}
		case eAccountPackType.EVENT_THEMATIC:
		{
			if ( GetGlobalSettingsBool( ItemFlavor_GetAsset( fileLevel.currentPackFlav ), "hasHolosprays" ) )
			{
				out.packType = eLootCeremonyPackType.THEMATIC_ITEM_TYPE_PACK
				out.packThemeType = eItemType.emote_icon
			}
			else if ( GetGlobalSettingsBool( ItemFlavor_GetAsset( fileLevel.currentPackFlav ), "hasStickers" ) )
			{
				out.packType = eLootCeremonyPackType.THEMATIC_ITEM_TYPE_PACK
				
				out.packThemeType = eItemType.sticker
			}

			break
		}
		case eAccountPackType.EVENT:
		{
			out.packType = eLootCeremonyPackType.COLLECTION_EVENT_PACK

			break
		}
		case eAccountPackType.SIRNGE:
		{
			out.packType = eLootCeremonyPackType.MILESTONE_EVENT_PACK

			break
		}
		default:
		{
			out.packType = eLootCeremonyPackType.APEX_PACK
		}
	}

	fileLevel.lootCeremonySortingData = out
}



int function SortApexPackResults( ItemFlavor a, ItemFlavor b )
{
	
	if ( ItemFlavor_GetSourceIcon( a ) != $"" )
	{
		return -1
	}

	if ( ItemFlavor_GetSourceIcon( b ) != $"" )
	{
		return 1
	}

	return 0
}



int function SortCollectionEventPackResults( ItemFlavor a, ItemFlavor b )
{
	ItemFlavor ornull collectionEvent = GetActiveCollectionEvent( GetUnixTimestamp() )

	if ( collectionEvent != null )
	{
		expect ItemFlavor( collectionEvent )

		if ( CollectionEvent_IsGivenItemFlavorReward( collectionEvent, a ) )
		{
			return -1
		}
		else if ( CollectionEvent_IsGivenItemFlavorReward( collectionEvent, b ) )
		{
			return 1
		}
	}

	return SortApexPackResults( a, b )
}



int function SortMilestoneEventPackResults( ItemFlavor a, ItemFlavor b )
{
	if ( ItemFlavor_GetType( a ) == eItemType.artifact_component_blade )
	{
		return -1
	}
	if ( ItemFlavor_GetType( b ) == eItemType.artifact_component_blade )
	{
		return 1
	}

	if ( ItemFlavor_GetType( a ) == eItemType.reward_set_tracker )
	{
		return -1
	}
	if ( ItemFlavor_GetType( b ) == eItemType.reward_set_tracker )
	{
		return 1
	}

	ItemFlavor ornull milestoneEvent = GetActiveMilestoneEvent( GetUnixTimestamp() )

	if ( milestoneEvent != null )
	{
		expect ItemFlavor( milestoneEvent )

		if ( MilestoneEvent_IsItemEventItem( milestoneEvent, a.grxIndex ) )
		{
			return -1
		}
		else if ( MilestoneEvent_IsItemEventItem( milestoneEvent, b.grxIndex ) )
		{
			return 1
		}
	}

	return SortApexPackResults( a, b )
}



int function SortHeirloomPackResults( ItemFlavor a, ItemFlavor b )
{
	if ( ItemFlavor_GetType( a ) == eItemType.melee_skin )
	{
		return -1
	}
	if ( ItemFlavor_GetType( b ) == eItemType.melee_skin )
	{
		return 1
	}

	return 0
}



int function SortThematicPackResults( ItemFlavor a, ItemFlavor b )
{
	int packThemeType = fileLevel.lootCeremonySortingData.packThemeType

	if ( packThemeType == ItemFlavor_GetType( a ) && ItemFlavor_GetQuality( a ) >= eRarityTier.RARE )
		return -1

	if ( packThemeType == ItemFlavor_GetType( b ) && ItemFlavor_GetQuality( b ) >= eRarityTier.RARE )
		return 1

	return 0
}



int function SortThematicWeaponPackResults( ItemFlavor a, ItemFlavor b )
{
	ItemFlavor ornull packTheme = fileLevel.lootCeremonySortingData.packTheme

	if ( ItemFlavor_GetType( a ) == eItemType.weapon_skin )
	{
		
		ItemFlavor themeCatagory     = WeaponItemFlavor_GetCategory( expect ItemFlavor( packTheme ) )
		ItemFlavor itemAssocCatagory = WeaponItemFlavor_GetCategory( expect ItemFlavor( GetItemFlavorAssociatedCharacterOrWeapon( a ) ) )

		if ( themeCatagory == itemAssocCatagory && ItemFlavor_GetQuality( a ) >= eRarityTier.RARE )
		{
			return -1
		}
	}

	if ( ItemFlavor_GetType( b ) == eItemType.weapon_skin )
	{
		ItemFlavor themeCatagory     = WeaponItemFlavor_GetCategory( expect ItemFlavor( packTheme ) )
		ItemFlavor itemAssocCatagory = WeaponItemFlavor_GetCategory( expect ItemFlavor( GetItemFlavorAssociatedCharacterOrWeapon( b ) ) )

		if ( themeCatagory == itemAssocCatagory && ItemFlavor_GetQuality( b ) >= eRarityTier.RARE )
		{
			return 1
		}
	}

	return 0
}



int function SortThematicWeaponCategoryPackResults( ItemFlavor a, ItemFlavor b )
{
	ItemFlavor ornull packTheme = fileLevel.lootCeremonySortingData.packTheme

	if ( ItemFlavor_GetType( a ) == eItemType.weapon_skin )
	{
		if ( packTheme == WeaponItemFlavor_GetCategory( expect ItemFlavor( GetItemFlavorAssociatedCharacterOrWeapon( a ) ) ) &&
				ItemFlavor_GetQuality( a ) >= eRarityTier.RARE )
			return -1
	}

	if ( ItemFlavor_GetType( b ) == eItemType.weapon_skin )
	{
		if ( packTheme == WeaponItemFlavor_GetCategory( expect ItemFlavor( GetItemFlavorAssociatedCharacterOrWeapon( b ) ) ) &&
				ItemFlavor_GetQuality( b ) >= eRarityTier.RARE )
			return 1
	}

	return 0
}



int function SortThematicCharacterPackResults( ItemFlavor a, ItemFlavor b )
{
	ItemFlavor ornull packTheme = fileLevel.lootCeremonySortingData.packTheme

	if ( packTheme == GetItemFlavorAssociatedCharacterOrWeapon( a ) && ItemFlavor_GetQuality( a ) >= eRarityTier.RARE )
		return -1

	if ( packTheme == GetItemFlavorAssociatedCharacterOrWeapon( b ) && ItemFlavor_GetQuality( b ) >= eRarityTier.RARE )
		return 1

	return 0
}


#if DEV
string function DEV_GetReadableLootCeremonyPackType( int type )
{
	switch ( type )
	{
		case eLootCeremonyPackType.APEX_PACK:
		{
			return "APEX_PACK"
		}

		case eLootCeremonyPackType.COLLECTION_EVENT_PACK:
		{
			return "COLLECTION_EVENT_PACK"
		}

		case eLootCeremonyPackType.MILESTONE_EVENT_PACK:
		{
			return "MILESTONE_EVENT_PACK"
		}

		case eLootCeremonyPackType.THEMATIC_ITEM_TYPE_PACK:
		{
			return "THEMATIC_ITEM_TYPE_PACK"
		}

		case eLootCeremonyPackType.THEMATIC_WEAPON_PACK:
		{
			return "THEMATIC_WEAPON_PACK"
		}

		case eLootCeremonyPackType.THEMATIC_WEAPON_CATEGORY_PACK:
		{
			return "THEMATIC_WEAPON_CATEGORY_PACK"
		}

		case eLootCeremonyPackType.THEMATIC_CHARACTER_PACK:
		{
			return "THEMATIC_CHARACTER_PACK"
		}

		default:
			return "UNKNOWN LOOT CEREMONY PACK TYPE"

	}

	return "UNKNOWN LOOT CEREMONY PACK TYPE"
}
#endif


array<ItemFlavor> function SortPackResults( array<ItemFlavor> results )
{
	Assert( fileLevel.lootCeremonySortingData.packType < eLootCeremonyPackType.COUNT, "Invalid Loot Ceremony Pack Type" )

	array<ItemFlavor> out = results

	
	switch ( fileLevel.lootCeremonySortingData.packType )
	{
		case eLootCeremonyPackType.APEX_PACK:
		{
			out.sort( SortApexPackResults )

			break
		}
		case eLootCeremonyPackType.COLLECTION_EVENT_PACK:
		{
			out.sort( SortCollectionEventPackResults )

			break
		}
		case eLootCeremonyPackType.MILESTONE_EVENT_PACK:
		{
			
			out.sort( SortMilestoneEventPackResults )

			break
		}
		case eLootCeremonyPackType.HEIRLOOM_PACK:
		{
			out.sort( SortHeirloomPackResults )

			break
		}
		case eLootCeremonyPackType.THEMATIC_ITEM_TYPE_PACK:
		{
			out.sort( SortThematicPackResults )

			break
		}
		case eLootCeremonyPackType.THEMATIC_WEAPON_PACK:
		{
			out.sort( SortThematicWeaponPackResults )

			break
		}
		case eLootCeremonyPackType.THEMATIC_WEAPON_CATEGORY_PACK:
		{
			out.sort( SortThematicWeaponCategoryPackResults )

			break
		}
		case eLootCeremonyPackType.THEMATIC_CHARACTER_PACK:
		{
			out.sort( SortThematicCharacterPackResults )

			break
		}
		default:
			Assert( false, "Invalid Loot Ceremony Pack Type" )
	}

	
	ItemFlavor temp = out[0]
	out[0] = out[1]
	out[1] = temp

#if DEV
	printt( FUNC_NAME() + " : Current Loot Ceremony Pack Type - " + DEV_GetReadableLootCeremonyPackType( fileLevel.lootCeremonySortingData.packType ) )

	if ( fileLevel.lootCeremonySortingData.packType >= eLootCeremonyPackType.THEMATIC_ITEM_TYPE_PACK &&
			fileLevel.lootCeremonySortingData.packType < eLootCeremonyPackType.COUNT &&
			fileLevel.lootCeremonySortingData.packTheme != null )
	{
		printt( FUNC_NAME() + " : Current Loot Ceremony Theme Item Type - " + DEV_DescItemFlavor( fileLevel.lootCeremonySortingData.packTheme ) )
	}
#endif

	return out
}



array<ItemFlavor> function FilterAndSortPackResults( array<ItemFlavor> resultList )
{
	UpdateLootCeremonySortingData()

	array<ItemFlavor> out = []

	
	
	ItemFlavor ornull rewardSetTracker = null

	
	foreach ( ItemFlavor result in resultList )
	{
		if ( ItemFlavor_GetType( result ) == eItemType.reward_set_tracker )
		{
			rewardSetTracker = result
		}

		if ( IsInvalidTypeForLootCeremony( ItemFlavor_GetType( result ) ) )
		{
			continue
		}

		out.append( result )
	}

	if ( rewardSetTracker != null )
	{
		out = FilterRewardSetItemsFromPackList( expect ItemFlavor( rewardSetTracker ), out )
	}

	out = SortPackResults( out )

	
	if ( out.len() > TICK_LOOT_ATTACHMENTS.len() )
		out.resize( TICK_LOOT_ATTACHMENTS.len() )

	return out
}



void function GRXPackOpened_ErrorHandling( int packError )
{
	if ( packError == GRX_INVENTORYERROR_NONE )
		return

	string message
	string warningText

	if ( packError == GRX_INVENTORYERROR_UNKNOWNITEM )
	{
		message = "#GRX_ERROR_MESSAGE_UNKNOWNITEM"
		warningText = "Loot Box had an error: UNKNOWNITEM"
	}
	else if ( packError == GRX_INVENTORYERROR_BACKEND )
	{
		message = "#GRX_ERROR_MESSAGE_BACKEND"
		warningText = "Loot Box had an error: BACKEND"
	}
	else
	{
		message = "#GRX_ERROR_MESSAGE_GENERIC"
		warningText = "Loot Box had an error: " + packError
	}

	RunUIScript( "ShowGRXErrorDialogue", message )

#if DEV
		Warning( warningText )
#endif
}























void function EnableFakeInspectButtons()
{
	foreach ( DummyInspectButtonData buttonData in fileLevel.dummyInspectButtons )
	{
		if ( buttonData.shouldShow )
		{
			Hud_SetEnabled( buttonData.button, true )
			Hud_SetVisible( buttonData.button, true )
		}
	}
}




void function DisableFakeInspectButtons()
{
	foreach ( DummyInspectButtonData buttonData in fileLevel.dummyInspectButtons )
	{
		Hud_SetEnabled( buttonData.button, false )
		Hud_SetVisible( buttonData.button, false )
	}
}




void function UIToClient_SkipAnimation()
{
	
}




void function UIToClient_SpecialItemPresentation( SettingsAssetGUID itemFlavorGUID, int itemQty, int badgeDataInteger )
{
	thread UIToClient_SpecialItemPresentation_Threaded( itemFlavorGUID, itemQty, badgeDataInteger )
}



void function UIToClient_SpecialItemPresentation_Threaded( SettingsAssetGUID itemFlavorGUID, int itemQty, int badgeDataInteger )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )

	fileLevel.specialItemPresentationModeActive = true

	
	DisableFakeInspectButtons()
	DisableInspectMenu()
	Hud_SetEnabled( fileLevel.skipAnimButton, false )
	Hud_SetVisible( fileLevel.skipAnimButton, false )

	
	LootCeremonySceneLightsUpdateShadows( true )

	if( fileLevel.cameraMover != null )
	{
		if ( !IsValid( fileLevel.cameraMover.GetParent() ) )
			fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
	}

	GetLocalClientPlayer().SetMenuCameraEntityWithAudio( fileLevel.cameraEnt )

	thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_triads_idle", fileLevel.lootTickMover )

	wait 0.25 

	
	ItemFlavor item     = GetItemFlavorByGUID( itemFlavorGUID )
	int itemType        = ItemFlavor_GetType( item )
	string attachment   = TICK_LOOT_ATTACHMENTS[1]
	int attachIDEye     = fileLevel.lootTickModel.LookupAttachment( attachment )
	vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachIDEye )
	vector attachAngles = VectorToAngles( FlattenVec( fileLevel.cameraMover.GetOrigin() - attachOrigin ) )
	int displayIndex    = TICK_LOOT_ATTACHMENTS.find( attachment )

	int rarity = 0
	if ( ItemFlavor_HasQuality( item ) )
		rarity = ItemFlavor_GetQuality( item )

	vector rarityColor = GetFXRarityColorForUnlockable( rarity )

	
	fileLevel.itemPresentationDatas.clear()
	ItemPresentationData data
	data.item = item
	data.quantity = itemQty
	
	data.attachment = attachment
	data.rarity = rarity
	fileLevel.itemPresentationDatas.append( data )

	
	InspectMenu_ZoomIn( Hud_GetChild( fileLevel.menu, "RewardCenterButton" ), true )

	
	thread ShowRewardBasedOnItemType( itemType, item, attachOrigin, attachAngles, rarity, itemQty, badgeDataInteger, displayIndex, attachment )

	
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_FIRST_APPEAR )
	
	RunUIScript( "ClientToUI_UpdateSpecialItemPresentationPurchaseButton" )
	
	thread ShowRewards_FX( attachIDEye, rarity, rarityColor, displayIndex )

	EnableInspectMenu()
}




void function UIToClient_SpecialItemPresentationExit()
{
	Signal( fileLevel.signalDummy, "LootCeremonyExit" )

	fileLevel.specialItemPresentationModeActive = false

	fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
	if ( IsValid( GetLocalClientPlayer() ) )
		GetLocalClientPlayer().ClearMenuCameraEntity()

	
	ClearInspectMenuDetails()
	LootCeremonySceneLightsUpdateShadows( false )
}























void function UIToClient_EnterLootCeremony( int packFlavGUID )
{
	ItemFlavor packFlav = GetItemFlavorByGUID( packFlavGUID )

	fileLevel.menuActive = true
	LootCeremonySceneLightsUpdateShadows( true )

	Chroma_LootCeremonyStart()

	ShowEntityAndChildren( fileLevel.lootTickModel )
	thread TickAnimationSequence( packFlav, true )
}




void function UIToClient_AdditionalLootTick_Sequence( int packFlavGUID )
{
	ItemFlavor packFlav = GetItemFlavorByGUID( packFlavGUID )

	Chroma_LootCeremonyStart()

	thread TickAnimationSequence( packFlav, false )
}




void function TickAnimationSequence( ItemFlavor packFlav, bool firstTime )
{
	Signal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	fileLevel.currentPackFlav = packFlav
	fileLevel.grxRewardsReceived = false
	DisableFakeInspectButtons()
	DisableInspectMenu()
	Hud_SetEnabled( fileLevel.skipAnimButton, false )
	Hud_SetVisible( fileLevel.skipAnimButton, false )

	
	fileLevel.lootTickModel.SetModel( GRXPack_GetTickModel( packFlav ) )
	fileLevel.lootTickModel.SetSkin( fileLevel.lootTickModel.GetSkinIndexByName( GRXPack_GetTickModelSkin( packFlav ) ) )

	string deployAnim = GetTickDeploymentAnim()

	OnThreadEnd(
		function() : ()
		{
			Signal( fileLevel.lootTickModel, "LootCeremonyTickCancelAnim" )

			

			if ( !IsLootCeremonyActive() )
			{
				thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_entrance_normal_idle", fileLevel.lootTickMover )
				HideEntityAndChildren( fileLevel.lootTickModel )
			}
			else
			{
				RunUIScript( "PlayCustomUIMusic", "" )
			}
		}
	)

	if ( !IsValid( fileLevel.cameraMover.GetParent() ) )
		fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )

	GetLocalClientPlayer().SetMenuCameraEntityWithAudio( fileLevel.cameraEnt )

	if ( firstTime )
		wait 0.25 

	RunUIScript( "PlayCustomUIMusic", LOOT_CEREMONY_MUSIC_P1 )

	
	PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_entrance_normal", fileLevel.lootTickMover )
	thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_idle", fileLevel.lootTickMover )

	
	wait 0.5

	
	while( !fileLevel.grxRewardsReceived )
		WaitFrame()

	
	Hud_SetEnabled( fileLevel.skipAnimButton, true )
	Hud_SetVisible( fileLevel.skipAnimButton, true )

	
	Signal( fileLevel.lootTickModel, "TickAnimStartDeployment" )

	
	RunUIScript( "PlayCustomUIMusic", LOOT_CEREMONY_MUSIC_P2 )
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_DEPLOY_ZOOM )

	
	thread PlayAnim( fileLevel.lootTickModel, deployAnim, fileLevel.lootTickMover )
	thread WaitForTickAnimCompleteAndSignalDisplayLoot( fileLevel.lootTickModel, deployAnim )

	
	bool animReachedDisplayEvent = false
	array<string> signalsToWait  = ["TickAnimStartDisplayLoot", "TickAnimSkip", "LootCeremonyTickCancelAnim"]
	string resultSignal          = GetWaitMultipleSignal_Entity( fileLevel.lootTickModel, signalsToWait, "LootCeremonyAnimShowLootOrSkip" )

	if ( resultSignal == "TickAnimStartDisplayLoot" )
		animReachedDisplayEvent = true

	
	Hud_SetEnabled( fileLevel.skipAnimButton, false )
	Hud_SetVisible( fileLevel.skipAnimButton, false )

	
	if ( animReachedDisplayEvent )
	{
		thread LootCeremonySequenceShowRewards()
		WaittillAnimDone( fileLevel.lootTickModel )
		thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_triads_idle", fileLevel.lootTickMover )
	}
	else
	{
		LootCeremony_RarityBeamFX_Stop( true )
		thread PlayAnim( fileLevel.lootTickModel, "loot_ceremony_tick_triads_idle", fileLevel.lootTickMover )
		thread LootCeremonySequenceShowRewards()
	}

	WaitForever()
}




string function GetTickDeploymentAnim()
{
	string deployAnim
	int randInt = RandomInt( 100 )

	if ( randInt > 95 )
	{
		
		deployAnim = "loot_ceremony_tick_deployment"
	}
	else
	{
		array<string> anims = [ "loot_ceremony_tick_deployment_fast_walk", "loot_ceremony_tick_deployment_hop", "loot_ceremony_tick_deployment_jump", "loot_ceremony_tick_deployment_walk"  ]
		deployAnim = anims.getrandom()
	}

	printt( "Loot Ceremony deployment animation: " + deployAnim )
	return deployAnim
}




void function WaitForTickAnimCompleteAndSignalDisplayLoot( entity tickModel, string tickAnim )
{
	
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	Wait( tickModel.GetSequenceDuration( tickAnim ) )

	Signal( fileLevel.lootTickModel, "TickAnimStartDisplayLoot" )
}




void function UIToClient_LootCeremonyExit()
{
	fileLevel.menuActive = false

	Signal( fileLevel.signalDummy, "LootCeremonyExit" )

	if ( IsValid( GetLocalClientPlayer() ) )
		GetLocalClientPlayer().ClearMenuCameraEntity()

	LootCeremonySceneLightsUpdateShadows( false )

	RunUIScript( "CancelCustomUIMusic" )

	
	LootCeremony_RarityBeamFX_Stop( true )

	Chroma_Lobby()
}




void function LootCeremonyOnFullUpdate()
{
	if ( !IsLootCeremonyActive() && !IsSpecialItemPresentationModeActive() )
		return

	printt( "#################" )
	printf( "%s() ", FUNC_NAME() )
	printt( "#################" )

	entity localClientPlayer = GetLocalClientPlayer()
	if ( IsValid( localClientPlayer ) && IsValid( fileLevel.cameraEnt ) )
		localClientPlayer.SetMenuCameraEntityWithAudio( fileLevel.cameraEnt )
}




bool function IsLootCeremonyActive()
{
	return fileLevel.menuActive
}























void function OnLootTickAnimEvent( entity ent, array<string> tokens )
{
	switch ( tokens[0] )
	{
		case "loot_tick_rarity_random_flash_fx":
		{
			thread LootCeremony_RandomFlashFX_Thread( ent )
			break
		}

		case "loot_tick_rarity_beam_start_fx":
		{
			LootCeremony_RarityBeamFX( ent, tokens[1] )
			break
		}

		case "loot_tick_rarity_beam_stop_fx":
		{
			LootCeremony_RarityBeamFX_Stop()
			break
		}

		case "loot_tick_rarity_flash_start_fx":
		{
			LootCeremony_RarityFlashFX( ent, tokens[1], tokens[2] )
			break
		}

		case "loot_tick_play_sound":
		{
			LootCeremony_PlayLootTickSound( ent, tokens[1] )
			break
		}

		default: Assert( false )
	}
}




void function LootCeremony_RandomFlashFX_Thread( entity tickModel )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )
	EndSignal( fileLevel.lootTickModel, "TickAnimStartDeployment" )

	if ( fileLevel.tickRandomFlashFXStarted )
		return

	fileLevel.tickRandomFlashFXStarted = true

	OnThreadEnd(
		function() : ()
		{
			fileLevel.tickRandomFlashFXStarted = false
		}
	)

	int attachID = tickModel.LookupAttachment( "FX_C_EYE" )

	while( true )
	{
		int rarity  = 0
		int randInt = RandomInt( 1000 )

		if ( randInt > 995 )
			rarity = 4
		if ( randInt > 970 )
			rarity = 3
		else if ( randInt > 900 )
			rarity = 2
		else if ( randInt > 600 )
			rarity = 1

		vector rarityColor = GetFXRarityColorForUnlockable( rarity )

		int fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_IDLE ), FX_PATTACH_POINT_FOLLOW, attachID )
		EffectSetControlPointVector( fxIndex, 1, rarityColor )

		RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_LIGHT_FLASH )

		Wait( RandomFloatRange( 0.2, 0.4 ) )
	}
}




void function LootCeremony_RarityBeamFX( entity tickModel, string fxAttachment )
{
	bool attachmentHasItem = false

	foreach ( ItemPresentationData data in fileLevel.itemPresentationDatas )
	{
		if ( data.attachment == fxAttachment )
		{
			attachmentHasItem = true
			break
		}
	}

	if ( !attachmentHasItem )
		return

	int rarity         = GetItemRarityFromAttachment( fxAttachment )
	vector rarityColor = GetFXRarityColorForUnlockable( rarity )

	Chroma_LootCeremonyBeam( rarity )

	int attachID = tickModel.LookupAttachment( fxAttachment )
	int fxIndex
	switch ( rarity )
	{
		case 0:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER1 ), FX_PATTACH_POINT_FOLLOW, attachID )
			break

		case 1:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER2 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER1 )
			break

		case 2:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER3 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER2 )
			break

		case 3:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER4 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER3 )
			break

		case 4:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER5 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER4 )
			break

		case 5:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER6 ), FX_PATTACH_POINT_FOLLOW, attachID )
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_BEAM_SWEETEN_TIER4 )
			break

		default:
			fxIndex = StartParticleEffectOnEntity( tickModel, GetParticleSystemIndex( TICK_FX_RARITY_BEAM_TIER1 ), FX_PATTACH_POINT_FOLLOW, attachID )
			break
	}

	EffectSetControlPointVector( fxIndex, 1, rarityColor )

	fileLevel.rarityBeamFXHandles.append( fxIndex )
}




void function LootCeremony_RarityBeamFX_Stop( bool stopImmediately = false )
{
	foreach ( int fxID in fileLevel.rarityBeamFXHandles )
	{
		if ( EffectDoesExist( fxID ) )
		{
			if ( stopImmediately )
				EffectStop( fxID, true, false )
			else
				EffectStop( fxID, false, true )
		}
	}

	fileLevel.rarityBeamFXHandles.clear()
}




void function LootCeremony_RarityFlashFX( entity tickModel, string attachmentHead, string attachmentEye )
{
	int rarity         = GetItemRarityFromAttachment( attachmentEye )
	vector rarityColor = GetFXRarityColorForUnlockable( rarity )

	int attachID  = tickModel.LookupAttachment( attachmentHead )
	vector origin = tickModel.GetAttachmentOrigin( attachID )
	vector angles = tickModel.GetAttachmentAngles( attachID )

	Chroma_LootCeremonyFlash( rarity )

	int fxIndex
	switch ( rarity )
	{
		case 0:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER1 ), origin, angles )
			break

		case 1:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER2 ), origin, angles )
			break

		case 2:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER3 ), origin, angles )
			break

		case 3:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER4 ), origin, angles )
			break

		case 4:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER5 ), origin, angles )
			break

		case 5:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER6 ), origin, angles )
			break

		default:
			fxIndex = StartParticleEffectInWorldWithHandle( GetParticleSystemIndex( TICK_FX_RARITY_FLASH_TIER1 ), origin, angles )
			break
	}

	EffectSetControlPointVector( fxIndex, 1, rarityColor )
}




void function LootCeremony_PlayLootTickSound( entity tickModel, string soundKindRef )
{
	string soundAlias = GRXPack_GetTickSoundAlias( fileLevel.currentPackFlav, eGRXPackTickSoundKind[soundKindRef] )
	if ( soundAlias != "" )
		EmitSoundOnEntity( tickModel, soundAlias )
}




int function GetItemRarityFromAttachment( string compareAttachment )
{
	int rarity = 0

	foreach ( ItemPresentationData data in fileLevel.itemPresentationDatas )
	{
		if ( data.attachment == compareAttachment )
			return data.rarity
	}

	return rarity
}






















const float REWARDS_DELAY_TIER5 = 1.1
const float REWARDS_DELAY_TIER4 = 1.0
const float REWARDS_DELAY_TIER3 = 0.4
const float REWARDS_DELAY_TIER1 = 0.2



void function LootCeremonySequenceShowRewards()
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	bool heirloomShards = false
	for ( int i = 0; i < fileLevel.itemPresentationDatas.len(); i++ )
	{
		ItemPresentationData data = fileLevel.itemPresentationDatas[i]
		ItemFlavor item           = data.item
		int quantity              = data.quantity
		int badgeDataInteger      = -1

		
		string attachment   = data.attachment
		int attachIDEye     = fileLevel.lootTickModel.LookupAttachment( attachment )
		vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachIDEye )
		vector attachAngles = VectorToAngles( FlattenVec( fileLevel.cameraMover.GetOrigin() - attachOrigin ) )

		int displayIndex = TICK_LOOT_ATTACHMENTS.find( attachment )

		
		int rarity         = data.rarity
		vector rarityColor = GetFXRarityColorForUnlockable( rarity )

		
		int itemType = ItemFlavor_GetType( item )

		
		if ( rarity == 4 )
		{
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_PREAPPEAR_TIER4 )

			wait REWARDS_DELAY_TIER5
		}
		else if ( rarity == 3 )
		{
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_PREAPPEAR_TIER3 )

			wait REWARDS_DELAY_TIER4
		}
		else if ( i > 0 )
		{
			if ( rarity == 2 || rarity == 1 )
				wait REWARDS_DELAY_TIER3
			else
				wait REWARDS_DELAY_TIER1
		}


		ShowRewardBasedOnItemType( itemType, item, attachOrigin, attachAngles, rarity, quantity, badgeDataInteger, displayIndex, attachment )

		
		thread ShowRewards_Placard( item, attachOrigin, attachAngles, rarity, displayIndex )
		thread ShowRewards_FX( attachIDEye, rarity, rarityColor, displayIndex )

		if ( i == 0 )
		{
			RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_FIRST_APPEAR )
			
		}

		switch ( rarity )
		{
			case 0:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER0 )
				break

			case 1:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER1 )
				break

			case 2:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER2 )
				break

			case 3:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER3 )
				break

			case 4:
				RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_TIER4 )
				break
		}

		if ( item == GetItemFlavorByAsset( $"settings/itemflav/currency_bundle/heirloom.rpak" ) )
			heirloomShards = true
	}

	
	RunUIScript( "ClientToUI_SetLootHasBeenPresented", heirloomShards )
	RunUIScript( "ClientToUI_UpdateStoreButtonVisibility" )
	RunUIScript( "LootCeremony_UpdateOpenAdditionalButton" )
	thread MythicUpdateAllEffects( true )

	
	for ( int i = 0; i < TICK_LOOT_ATTACHMENTS.len(); i++ )
	{
		if ( i < fileLevel.itemPresentationDatas.len() )
			fileLevel.dummyInspectButtons[i].shouldShow = true
		else
			fileLevel.dummyInspectButtons[i].shouldShow = false
	}
	EnableFakeInspectButtons()
}




void function ShowRewardBasedOnItemType( int itemType, ItemFlavor item, vector attachOrigin, vector attachAngles, int rarity, int quantity, int badgeDataInteger, int displayIndex, string attachment )
{
	switch ( itemType )
	{
		case eItemType.account_currency:
		case eItemType.account_currency_bundle:
			thread ShowRewards_Currency( item, attachOrigin, attachAngles, rarity, quantity, displayIndex, attachment )
			break

		case eItemType.account_pack:
			thread ShowRewards_LootTick( item, attachOrigin, attachAngles, rarity, quantity, displayIndex, attachment )
			break

		case eItemType.character:
			ItemFlavor characterSkin = CharacterClass_GetDefaultSkin( item )
			thread ShowRewards_CharacterSkin( characterSkin, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.character_skin:
			thread ShowRewards_CharacterSkin( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.character_execution:
			thread ShowRewards_Execution( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.emote_icon:
			thread ShowRewards_EmoteIcon( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.weapon_skin:
			asset video = WeaponSkin_GetVideo( item )
			if ( video != $"" && WeaponSkin_ShouldDisplayVideoOnInspect( item ) )
			{
				thread ShowBattlePassItem_WeaponSkinVideo( item, attachOrigin, attachAngles, rarity, displayIndex, video )
			}
			else
			{
				thread ShowRewards_WeaponSkin( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			}
			break

		case eItemType.weapon_charm:
			thread ShowRewards_WeaponCharm( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.gladiator_card_stance:
		case eItemType.gladiator_card_frame:
			thread ShowRewards_GladiatorCard( item, itemType, attachOrigin, attachAngles, displayIndex, rarity )
			break

		case eItemType.gladiator_card_intro_quip:
		case eItemType.gladiator_card_kill_quip:
			thread ShowRewards_Quip( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.gladiator_card_stat_tracker:
			thread ShowRewards_StatTracker( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.gladiator_card_badge:
			thread ShowRewards_Badge( item, badgeDataInteger, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.artifact_component_blade:
		case eItemType.melee_skin:
			thread ShowRewards_MeleeSkin( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.music_pack:
			thread ShowRewards_MusicPack( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.loadscreen:
			thread ShowRewards_Loadscreen( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.skydive_emote:
			thread ShowRewards_SkydiveEmote( item, attachOrigin, attachAngles, rarity, displayIndex )
			break

		case eItemType.character_emote:
			thread ShowRewards_CharacterEmote( item, attachOrigin, attachAngles, rarity, displayIndex, attachment )
			break

		case eItemType.voucher:
			thread ShowRewards_Voucher( item, attachOrigin, attachAngles, rarity, quantity, displayIndex, attachment )
			break

		case eItemType.sticker:
			thread ShowRewards_Sticker( item, attachOrigin, attachAngles, rarity, displayIndex )
			break


			case eItemType.reward_set_tracker:
				thread ShowRewards_RewardSetTracker( item, attachOrigin, attachAngles, rarity, displayIndex )
				break

			case eItemType.artifact_component_deathbox:
				thread ShowRewards_Deathbox( item, attachOrigin, attachAngles, rarity, displayIndex )
				break


		default:
			Warning( "Loot Ceremony reward item type not supported: " + DEV_GetEnumStringSafe( "eItemType", itemType ) )
			thread ShowRewards_PLACEHOLDER( item, attachOrigin, attachAngles, rarity, displayIndex )
			break
	}
}



const float MODEL_ROTATE_SPEED = 15.0
const float CURRENCY_Z_OFFSET = 26.0



void function ShowRewards_Currency( ItemFlavor item, vector origin, vector angles, int rarity, int quantity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	origin += <0, 0, CURRENCY_Z_OFFSET>

	asset modelAsset = $"mdl/dev/empty_model.rmdl"
	float modelScale = 1.0
	bool shouldSpin  = true
	if ( ItemFlavor_GetType( item ) == eItemType.account_currency )
	{
		

		if ( GRXCurrency_GetPreviewModel( item ) != $"" )
			modelAsset = GRXCurrency_GetPreviewModel( item )
		modelScale = 0.7
		shouldSpin = GetCurrentPlaylistVarBool( "loot_ceremony_currency_spins", true )
	}
	else
	{
		asset itemAsset = ItemFlavor_GetAsset( item )
		
		Assert( itemAsset == $"settings/itemflav/currency_bundle/crafting_common.rpak" ||
		itemAsset == $"settings/itemflav/currency_bundle/crafting_rare.rpak" ||
		itemAsset == $"settings/itemflav/currency_bundle/crafting_epic.rpak" ||
		itemAsset == $"settings/itemflav/currency_bundle/crafting_legendary.rpak" ||
		itemAsset == $"settings/itemflav/currency_bundle/heirloom.rpak" )

		switch ( rarity )
		{
			case eRarityTier.COMMON:
				modelAsset = CURRENCY_MODEL_COMMON
				break

			case eRarityTier.RARE:
				modelAsset = CURRENCY_MODEL_RARE
				break

			case eRarityTier.EPIC:
				modelAsset = CURRENCY_MODEL_EPIC
				break

			case eRarityTier.LEGENDARY:
				modelAsset = CURRENCY_MODEL_LEGENDARY
				break

			case eRarityTier.MYTHIC:
				ItemFlavor currencyFlav = GRXCurrencyBundle_GetCurrencyFlav( item )
				modelAsset = GRXCurrency_GetPreviewModel( currencyFlav )
				break

			default: Assert( false )
		}
	}

	

	entity moverEnt = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity modelEnt = CreateClientSidePropDynamic( origin, angles, modelAsset )

	moverEnt.MakeSafeForUIScriptHack()
	modelEnt.MakeSafeForUIScriptHack()
	modelEnt.SetParent( moverEnt )
	modelEnt.SetModelScale( modelScale )

	if ( shouldSpin )
		moverEnt.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( modelEnt, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.account_currency_bundle )

	OnThreadEnd(
		function() : ( moverEnt, modelEnt, attachment )
		{
			modelEnt.Destroy()
			moverEnt.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, quantity, angles, moverEnt, modelEnt, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, quantity, modelEnt, moverEnt, angles, 360.0 )
}




const float LOOT_TICK_Z_OFFSET = 15.0
void function ShowRewards_LootTick( ItemFlavor item, vector origin, vector angles, int rarity, int quantity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	origin += <0, 0, LOOT_TICK_Z_OFFSET>

	asset modelAsset = GRXPack_GetTickModel( item )

	entity moverEnt = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity modelEnt = CreateClientSidePropDynamic( origin, angles, modelAsset )
	modelEnt.SetSkin( modelEnt.GetSkinIndexByName( GRXPack_GetTickModelSkin( item ) ) )

	moverEnt.MakeSafeForUIScriptHack()
	modelEnt.MakeSafeForUIScriptHack()
	modelEnt.SetParent( moverEnt )
	modelEnt.SetModelScale( 0.5 )

	moverEnt.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( modelEnt, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.account_currency_bundle )

	OnThreadEnd(
		function() : ( moverEnt, modelEnt, attachment )
		{
			modelEnt.Destroy()
			moverEnt.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, quantity, angles, moverEnt, modelEnt, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, quantity, modelEnt, moverEnt, angles, 360.0 )
}



const float CHARACTER_SKIN_Z_OFFSET = 4.0
const float CHARACTER_SKIN_SCALE = 0.7



void function ShowRewards_CharacterSkin( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	origin += <0, 0, CHARACTER_SKIN_Z_OFFSET>

	entity mover          = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity characterModel = CreateClientSidePropDynamic( origin, angles, $"mdl/dev/empty_model.rmdl" )
	CharacterSkin_Apply( characterModel, item )
	characterModel.MakeSafeForUIScriptHack()
	mover.MakeSafeForUIScriptHack()
	characterModel.SetParent( mover )

	thread PlayAnim( characterModel, "ACT_MP_MENU_LOOT_CEREMONY_IDLE", mover )

	
	characterModel.SetModelScale( CHARACTER_SKIN_SCALE )

	
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( characterModel, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.character_skin )

	if ( Mythics_IsItemFlavorMythicSkin( item ) && displayIndex != 1 )
		fileLevel.characterSkinModels.append( characterModel )

	OnThreadEnd(
		function() : ( mover, characterModel, attachment )
		{
			characterModel.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, characterModel, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, characterModel, mover, angles, 360.0 )
}



const float EXECUTION_Z_OFFSET = 12.0
const vector EXECUTION_LOCAL_ANGLES = <0, 15, 0>
const float EXECUTION_SCALE = 0.4



void function ShowRewards_Execution( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	ItemFlavor attackerCharacter = CharacterExecution_GetCharacterFlavor( item )
	ItemFlavor characterSkin     = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_CharacterSkin( attackerCharacter ) )

	asset attackerAnimSeq = CharacterExecution_GetAttackerPreviewAnimSeq( item )
	asset victimAnimSeq   = CharacterExecution_GetVictimPreviewAnimSeq( item )

	
	origin += <0, 0, EXECUTION_Z_OFFSET>
	vector startAngles   = AnglesCompose( angles, EXECUTION_LOCAL_ANGLES )
	entity mover         = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, startAngles )
	entity attackerModel = CreateClientSidePropDynamic( origin, startAngles, $"mdl/dev/empty_model.rmdl" )
	entity victimModel   = CreateClientSidePropDynamic( origin, startAngles, $"mdl/dev/empty_model.rmdl" )

	CharacterSkin_Apply( attackerModel, characterSkin )
	victimModel.SetModel( $"mdl/humans/class/medium/dummy_v20_base_w.rmdl" )

	
	bool attackerHasSequence = attackerModel.Anim_HasSequence( attackerAnimSeq )
	bool victimHasSequence   = victimModel.Anim_HasSequence( victimAnimSeq )

	if ( !attackerHasSequence || !victimHasSequence )
	{
		asset attackerPlayerSettings = CharacterClass_GetSetFile( attackerCharacter )
		string attackerRigWeight     = GetGlobalSettingsString( attackerPlayerSettings, "bodyModelRigWeight" )
		string attackerAnim          = "mp_pt_execution_" + attackerRigWeight + "_attacker_loot"

		attackerModel.Anim_Play( attackerAnim )
		victimModel.Anim_Play( "mp_pt_execution_default_victim_loot" )
		Warning( "Couldn't find menu idles for execution reward: " + DEV_DescItemFlavor( item ) + ". Using fallback anims." )
		if ( !attackerHasSequence )
			Warning( "ATTACKER could not find sequence: " + attackerAnimSeq )
		if ( !victimHasSequence )
			Warning( "VICTIM could not find sequence: " + victimAnimSeq )
	}
	else
	{
		attackerModel.Anim_Play( attackerAnimSeq )
		victimModel.Anim_Play( victimAnimSeq )
	}

	mover.MakeSafeForUIScriptHack()

	attackerModel.MakeSafeForUIScriptHack()
	attackerModel.SetParent( mover )

	victimModel.MakeSafeForUIScriptHack()
	victimModel.SetParent( mover )

	
	attackerModel.SetModelScale( EXECUTION_SCALE )
	victimModel.SetModelScale( EXECUTION_SCALE )

	
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( attackerModel, flashType, flashColor )
	thread FlashMenuModel( victimModel, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.character_execution )

	OnThreadEnd(
		function() : ( mover, attackerModel, victimModel, attachment )
		{
			attackerModel.Destroy()
			victimModel.Destroy()
			mover.Destroy()

			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Execution( item, rarity, attackerModel, victimModel, mover )
	else
		InspectMenuFunctionality_Execution( item, displayIndex, rarity, attackerModel, victimModel, mover, startAngles )
}



const float WEAPON_SKIN_Z_OFFSET = 28.0
const vector WEAPON_SKIN_LOCAL_ANGLES = <10, -90, 0>






const float HOLOSPRAY_Z_OFFSET = 16.0

void function ShowRewards_EmoteIcon( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	entity mover
	entity spray
	if ( !IsSpecialItemPresentationModeActive() )
	{



		origin += <0, 0, HOLOSPRAY_Z_OFFSET>


		
		mover            = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
		mover.SetDoDestroyCallback( true )

		spray = CreateClientSideEmoteIconModel( item, origin, angles )
		spray.SetParent( mover )
		spray.SetModelScale( 0.4 )
	}
	else
	{
		origin -= <0, 0, HOLOSPRAY_Z_OFFSET> * 2

		asset EMOTE_ICON_BASE_MODEL = HOLO_SPRAY_BASE

		mover = CreateClientsideScriptMover( EMOTE_ICON_BASE_MODEL, origin, angles )
		mover.MakeSafeForUIScriptHack()
		mover.SetDoDestroyCallback( true )

		spray = CreateClientSidePropDynamic( origin, angles, $"mdl/dev/empty_model.rmdl" )

		thread CreateClientSideEmoteIcon( mover, ItemFlavor_GetGUID( item ), Time(), true )
	}


	
	
	
	
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.weapon_skin )

	OnThreadEnd(
		function() : ( mover, spray, attachment )
		{
			spray.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, spray, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, spray, mover, angles, 360.0 )

	WaitForever()
}


void function ShowRewards_WeaponSkin( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	origin += <0, 0, WEAPON_SKIN_Z_OFFSET>

	
	ItemFlavor weaponFlavor = WeaponSkin_GetWeaponFlavor( item )
	entity mover            = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity weaponModel      = CreateClientSidePropDynamic( origin, AnglesCompose( angles, WEAPON_SKIN_LOCAL_ANGLES ), $"mdl/dev/empty_model.rmdl" )
	WeaponCosmetics_Apply( weaponModel, item, null )

	bool isReactive = WeaponSkin_DoesReactToKills( item )
	if ( isReactive )
		MenuWeaponModel_ApplyReactiveSkinBodyGroup( item, weaponFlavor, weaponModel )
	else
		ShowDefaultBodygroupsOnFakeWeapon( weaponModel, WeaponItemFlavor_GetClassname( weaponFlavor ) )

	MenuWeaponModel_ClearReactiveEffects( weaponModel )
	if ( isReactive )
		MenuWeaponModel_StartReactiveEffects( weaponModel, item )

	mover.MakeSafeForUIScriptHack()
	weaponModel.MakeSafeForUIScriptHack()
	weaponModel.SetVisibleForLocalPlayer( 0 )
	weaponModel.Anim_SetPaused( true )
	weaponModel.SetModelScale( WeaponItemFlavor_GetLootCeremonyScale( weaponFlavor ) )
	weaponModel.SetParent( mover )

	
	string attachmentName = "MENU_ROTATE"
	vector originOffset   = GetAttachmentOriginOffset( weaponModel, attachmentName, WEAPON_SKIN_LOCAL_ANGLES )

	weaponModel.SetLocalOrigin( originOffset )
	weaponModel.SetLocalAngles( WEAPON_SKIN_LOCAL_ANGLES )
	mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( weaponModel, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.weapon_skin )

	OnThreadEnd(
		function() : ( mover, weaponModel, attachment )
		{
			weaponModel.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, weaponModel, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, weaponModel, mover, angles, 360.0 )
}



const float WEAPON_CHARM_Z_OFFSET = 32.0
const vector WEAPON_CHARM_LOCAL_ANGLES = <-5, -40, 0>
const float WEAPON_CHARM_BASE_SCALE = 1.0
const float WEAPON_CHARM_EXTRA_SCALE = 1.34



void function ShowRewards_WeaponCharm( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	origin += <0, 0, WEAPON_CHARM_Z_OFFSET>

	vector moverStartAngles = <0, fileLevel.cameraMover.GetAngles().y + 90, 0>
	entity mover            = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, moverStartAngles )
	mover.MakeSafeForUIScriptHack()

	entity weaponModel = CreateClientSidePropDynamic( origin, <0, 0, 0>, $"mdl/dev/empty_model.rmdl" )
	weaponModel.SetModel( $"mdl/weapons/r97/ptpov_r97.rmdl" )
	weaponModel.SetSkin( weaponModel.GetSkinIndexByName( "charm_preview_black" ) )
	weaponModel.MakeSafeForUIScriptHack()
	weaponModel.SetVisibleForLocalPlayer( 0 )
	weaponModel.Anim_SetPaused( true )
	weaponModel.SetModelScale( WEAPON_CHARM_BASE_SCALE )
	weaponModel.SetParent( mover )
	ShowDefaultBodygroupsOnFakeWeapon( weaponModel, "mp_weapon_r97" )

	weaponModel.SetLocalOrigin( GetAttachmentOriginOffset( weaponModel, "CHARM", WEAPON_CHARM_LOCAL_ANGLES ) )
	weaponModel.SetLocalAngles( WEAPON_CHARM_LOCAL_ANGLES )

	WeaponCosmetics_Apply( weaponModel, null, item )

	entity charmEnt = GetCharmForWeaponEntity( weaponModel )
	charmEnt.SetModelScale( WEAPON_CHARM_BASE_SCALE * WEAPON_CHARM_EXTRA_SCALE )

	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( weaponModel, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.weapon_skin )

	OnThreadEnd(
		function() : ( mover, weaponModel, charmEnt, attachment )
		{
			weaponModel.Destroy()
			mover.Destroy()
			if ( IsValid( charmEnt ) )
				charmEnt.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, weaponModel, 50.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, weaponModel, mover, moverStartAngles, 50.0 )
}



void function ShowRewards_MeleeSkin( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	origin += <0, 0, WEAPON_SKIN_Z_OFFSET>

	bool isArtifact = false
	if ( ItemFlavor_GetType( item ) == eItemType.artifact_component_blade )
	{
		item = GetItemFlavorByGUID( ARTIFACT_CONFIGURATION_PTR_0_GUID )
		isArtifact = true
	}

	vector extraRotation = MeleeSkin_GetMenuModelRotation( item )
	entity mover         = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity weaponModel   = CreateClientSidePropDynamic( origin, AnglesCompose( angles, extraRotation ), $"mdl/dev/empty_model.rmdl" )

	asset modelAsset = MeleeSkin_GetMenuModel( item )
	weaponModel.SetModel( modelAsset )

	mover.MakeSafeForUIScriptHack()
	weaponModel.MakeSafeForUIScriptHack()
	weaponModel.SetVisibleForLocalPlayer( 0 )

	if ( isArtifact )
	{
		int configIdx = 0
		LoadoutEntry bladeEntry = Artifacts_Loadouts_GetEntryForConfigIndexAndType( configIdx, eArtifactComponentType.BLADE )
		LoadoutEntry powerSourceEntry = Artifacts_Loadouts_GetEntryForConfigIndexAndType( configIdx, eArtifactComponentType.POWER_SOURCE )
		LoadoutEntry themeEntry = Artifacts_Loadouts_GetEntryForConfigIndexAndType( configIdx, eArtifactComponentType.THEME )

		if ( bladeEntry.validItemFlavorList.len() < 2 )
			return

		ItemFlavor bladeComponent = bladeEntry.validItemFlavorList[1]
		ItemFlavor powerSourceComponent = powerSourceEntry.validItemFlavorList[1]
		ItemFlavor themeComponent = themeEntry.validItemFlavorList[1]
		int setIndex = eArtifactSetIndex.MOB

		Artifacts_Loadouts_ApplyModelForSet( weaponModel, setIndex )
		Artifacts_Loadouts_PreviewBladeAndPowerSource( weaponModel, bladeComponent, powerSourceComponent )
		Artifacts_Loadouts_PreviewTheme( weaponModel, themeComponent )
	}

	asset animSeq = MeleeSkin_GetMenuAnimSeq( item )
	if ( animSeq != $"" )
		weaponModel.Anim_Play( animSeq )

	weaponModel.SetModelScale( WeaponItemFlavor_GetLootCeremonyScale( item ) )
	weaponModel.SetParent( mover )

	
	string attachmentName = "MENU_ROTATE"
	vector originOffset   = GetAttachmentOriginOffset( weaponModel, attachmentName, extraRotation )

	weaponModel.SetLocalOrigin( originOffset )
	weaponModel.SetLocalAngles( extraRotation )
	mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( weaponModel, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.weapon_skin )

	OnThreadEnd(
		function() : ( mover, weaponModel, attachment )
		{
			weaponModel.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, weaponModel, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, weaponModel, mover, angles, 360.0 )
}




int function GetLootCeremonyFlashType( ItemFlavor item )
{
	Assert( ItemFlavor_HasQuality( item ) )

	int rarity = ItemFlavor_GetQuality( item )
	if ( rarity >= eRarityTier.LEGENDARY )
		return eMenuModelFlashType.LOOT_CEREMONY_HIGH_RARITY

	return eMenuModelFlashType.LOOT_CEREMONY_LOW_RARITY
}



const float GLADIATOR_CARD_WIDTH = 528.0
const float GLADIATOR_CARD_HEIGHT = 912.0
const float GLADIATOR_CARD_Z_OFFSET = 2.0



void function ShowRewards_GladiatorCard( ItemFlavor item, int itemType, vector origin, vector angles, int displayIndex, int rarity )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	GladiatorCardData gCardData = ShowRewards_GladiatorCard_Create( item, itemType, true, rarity, origin, angles )

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_GladiatorCard( item, itemType, rarity, gCardData )
	else
		InspectMenuFunctionality_GladiatorCard( item, itemType, origin, angles, displayIndex, rarity, gCardData )
}




GladiatorCardData function ShowRewards_GladiatorCard_Create( ItemFlavor item, int itemType, bool firstTime, int rarity, vector origin, vector angles )
{
	entity player    = GetLocalClientPlayer()
	vector ruiOrigin = origin + <0, 0, GLADIATOR_CARD_Z_OFFSET>
	vector ruiAngles = AnglesCompose( angles, <0, 180, 0> )
	float width      = GLADIATOR_CARD_WIDTH / 16.0
	float height     = GLADIATOR_CARD_HEIGHT / 16.0
	var topo         = CreateRUITopology_Worldspace( ruiOrigin + <0, 0, height * 0.5>, ruiAngles, width, height )
	var parentRui    = RuiCreate( $"ui/loot_ceremony_glad_card.rpak", topo, RUI_DRAW_WORLD, 0 )

	int gcardPresentation
	if ( itemType == eItemType.gladiator_card_frame )
		gcardPresentation = eGladCardPresentation.FRONT_FRAME_ONLY
	else
		gcardPresentation = eGladCardPresentation.FRONT_STANCE_ONLY

	NestedGladiatorCardHandle nestedGCHandleFront = CreateNestedGladiatorCard( parentRui, "card", eGladCardDisplaySituation.MENU_LOOT_CEREMONY_ANIMATED, gcardPresentation )
	ChangeNestedGladiatorCardOwner( nestedGCHandleFront, ToEHI( player ) )

	if ( itemType == eItemType.gladiator_card_frame )
	{
		ItemFlavor ornull character = GladiatorCardFrame_GetCharacterFlavor( item )
		if ( character == null )
			character = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_Character() )

		expect ItemFlavor( character )

		SetNestedGladiatorCardOverrideCharacter( nestedGCHandleFront, character )
		SetNestedGladiatorCardOverrideFrame( nestedGCHandleFront, item )
	}
	else
	{
		ItemFlavor character = GladiatorCardStance_GetCharacterFlavor( item )
		SetNestedGladiatorCardOverrideCharacter( nestedGCHandleFront, character )
		SetNestedGladiatorCardOverrideStance( nestedGCHandleFront, item )

		ItemFlavor characterDefaultFrame = GetDefaultItemFlavorForLoadoutSlot( EHI_null, Loadout_GladiatorCardFrame( character ) )
		SetNestedGladiatorCardOverrideFrame( nestedGCHandleFront, characterDefaultFrame ) 
	}

	GladiatorCardData gCardData
	gCardData.handle = nestedGCHandleFront
	gCardData.rui = parentRui
	gCardData.topo = topo

	RuiSetBool( parentRui, "firstTime", firstTime )
	RuiSetInt( parentRui, "rarity", rarity )

	return gCardData
}




void function ShowRewards_GladiatorCard_Destroy( GladiatorCardData gCardData )
{
	CleanupNestedGladiatorCard( gCardData.handle )
	RuiDestroyIfAlive( gCardData.rui )

	if ( gCardData.topo != null )
	{
		RuiTopology_Destroy( gCardData.topo )
		gCardData.topo = null
	}
}



const float RUI_QUIP_WIDTH = 390.0
const float RUI_QUIP_HEIGHT = 208.0
const float RUI_QUIP_Z_OFFSET = 24.0



void function ShowRewards_Quip( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	const float QUIP_RUI_SCALE_DIVIDE_BY = 16.0

	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	vector placardOrigin = origin + <0, 0, RUI_QUIP_Z_OFFSET>
	float width          = RUI_QUIP_WIDTH / QUIP_RUI_SCALE_DIVIDE_BY
	float height         = RUI_QUIP_HEIGHT / QUIP_RUI_SCALE_DIVIDE_BY
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	entity bgModel = CreateClientSidePropDynamic( placardOrigin, angles, QUIP_BG_MODEL )
	bgModel.MakeSafeForUIScriptHack()
	bgModel.SetModelScale( 1.0 / QUIP_RUI_SCALE_DIVIDE_BY )

	var topoQuip = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )

	
	var ruiQuip
	ItemFlavor quipCharacter
	string labelText

	if ( ItemFlavor_GetType( item ) == eItemType.gladiator_card_intro_quip )
	{
		ruiQuip = RuiCreate( $"ui/loot_reward_intro_quip.rpak", topoQuip, RUI_DRAW_WORLD, 0 )
		quipCharacter = CharacterIntroQuip_GetCharacterFlavor( item )
		labelText = "#LOOT_QUIP_INTRO"
	}
	else
	{
		ruiQuip = RuiCreate( $"ui/loot_reward_kill_quip.rpak", topoQuip, RUI_DRAW_WORLD, 0 )
		quipCharacter = CharacterKillQuip_GetCharacterFlavor( item )
		labelText = "#LOOT_QUIP_Kill"
	}

	RuiSetBool( ruiQuip, "isVisible", true )
	RuiSetInt( ruiQuip, "rarity", rarity )
	RuiSetImage( ruiQuip, "portraitImage", CharacterClass_GetGalleryPortrait( quipCharacter ) )
	RuiSetString( ruiQuip, "quipTypeText", labelText )
	RuiTrackFloat( ruiQuip, "level", null, RUI_TRACK_SOUND_METER, 0 )

	OnThreadEnd(
		function() : ( ruiQuip, topoQuip, bgModel )
		{
			RuiDestroyIfAlive( ruiQuip )
			RuiTopology_Destroy( topoQuip )
			bgModel.Destroy()
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Quip( item, rarity, ruiQuip )
	else
		InspectMenuFunctionality_Quip( item, displayIndex, rarity, ruiQuip, bgModel )
}




void function ShowRewards_MusicPack( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	const float QUIP_RUI_SCALE_DIVIDE_BY = 16.0

	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	vector placardOrigin = origin + <0, 0, RUI_QUIP_Z_OFFSET>
	float width          = RUI_QUIP_WIDTH / QUIP_RUI_SCALE_DIVIDE_BY
	float height         = RUI_QUIP_HEIGHT / QUIP_RUI_SCALE_DIVIDE_BY
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	entity bgModel = CreateClientSidePropDynamic( placardOrigin, angles, QUIP_BG_MODEL )
	bgModel.MakeSafeForUIScriptHack()
	bgModel.SetModelScale( 1.0 / QUIP_RUI_SCALE_DIVIDE_BY )

	var topo = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )

	
	var rui = RuiCreate( $"ui/loot_reward_intro_quip.rpak", topo, RUI_DRAW_WORLD, 0 )

	RuiSetBool( rui, "isVisible", true )
	RuiSetInt( rui, "rarity", rarity )
	RuiSetImage( rui, "portraitImage", MusicPack_GetPortraitImage( item ) )
	RuiSetFloat( rui, "portraitBlend", MusicPack_GetPortraitBlend( item ) )
	RuiSetString( rui, "quipTypeText", "#MUSIC_PACK" )
	RuiTrackFloat( rui, "level", null, RUI_TRACK_SOUND_METER, 0 )

	OnThreadEnd(
		function() : ( rui, topo, bgModel )
		{
			RuiDestroyIfAlive( rui )
			RuiTopology_Destroy( topo )
			bgModel.Destroy()
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_MusicPack( item, rarity, rui )
	else
		InspectMenuFunctionality_MusicPack( item, displayIndex, rarity, rui, bgModel )
}



const float STAT_TRACKER_WIDTH = 594.0
const float STAT_TRACKER_HEIGHT = 230.0
const float STAT_TRACKER_Z_OFFSET = 27.0
const float STAT_TRACKER_SCALE_DIVIDE_BY = 24.0



void function ShowRewards_StatTracker( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	vector placardOrigin = origin + <0, 0, STAT_TRACKER_Z_OFFSET>
	float width          = STAT_TRACKER_WIDTH / STAT_TRACKER_SCALE_DIVIDE_BY
	float height         = STAT_TRACKER_HEIGHT / STAT_TRACKER_SCALE_DIVIDE_BY
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topoStatTracker = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )
	var ruiStatTracker  = RuiCreate( $"ui/loot_ceremony_stat_tracker.rpak", topoStatTracker, RUI_DRAW_WORLD, 0 )

	entity bgModel = CreateClientSidePropDynamic( placardOrigin, angles, STAT_TRACKER_BG_MODEL )
	bgModel.MakeSafeForUIScriptHack()
	bgModel.SetModelScale( 1.0 / STAT_TRACKER_SCALE_DIVIDE_BY )

	ItemFlavor ornull character = GladiatorCardStatTracker_GetCharacterFlavor( item )
	if ( character == null ) 
		character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

	expect ItemFlavor( character )

	RuiSetBool( ruiStatTracker, "isVisible", true )
	UpdateRuiWithStatTrackerData( ruiStatTracker, "tracker", LocalClientEHI(), character, -1, item, null, true )
	RuiSetColorAlpha( ruiStatTracker, "trackerColor0", GladiatorCardStatTracker_GetColor0( item ), 1.0 )

	OnThreadEnd(
		function() : ( ruiStatTracker, topoStatTracker, bgModel )
		{
			RuiDestroyIfAlive( ruiStatTracker )
			RuiTopology_Destroy( topoStatTracker )
			bgModel.Destroy()
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, ruiStatTracker, "#STAT_TRACKER_DESCRIPTION" )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, ruiStatTracker, bgModel, "#STAT_TRACKER_DESCRIPTION" )
}




const float BADGE_Z_OFFSET = 20.0



void function ShowRewards_Badge( ItemFlavor item, int badgeDataInteger, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )


	const float BATTLEPASS_BADGE_WIDTH = 500.0
	const float BATTLEPASS_BADGE_HEIGHT = 500.0
	const float BATTLEPASS_BADGE_SCALE = 0.06

	
	vector placardOrigin = origin + <0, 0, BADGE_Z_OFFSET>
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	float width  = BATTLEPASS_BADGE_WIDTH * BATTLEPASS_BADGE_SCALE
	float height = BATTLEPASS_BADGE_HEIGHT * BATTLEPASS_BADGE_SCALE

	var topoBadge = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )
	var ruiBadge  = RuiCreate( $"ui/world_space_badge.rpak", topoBadge, RUI_DRAW_VIEW_MODEL, 0 )
	RuiSetFloat( ruiBadge, "bloomScale", 0.2 )

	entity bgModel = null
	
	

	RuiSetBool( ruiBadge, "isVisible", true )

	int ornull overrideDataIntegerOrNull      = badgeDataInteger >= 0 ? badgeDataInteger : null
	bool showOneTierHigherThanIsUnlocked = true

	CreateNestedGladiatorCardBadge( ruiBadge, "badge", LocalClientEHI(), item, -1, null, overrideDataIntegerOrNull, showOneTierHigherThanIsUnlocked )

	OnThreadEnd(
		function() : ( ruiBadge, topoBadge, bgModel )
		{
			RuiDestroyIfAlive( ruiBadge )
			RuiTopology_Destroy( topoBadge )
			if ( IsValid( bgModel ) )
				bgModel.Destroy()
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, ruiBadge, ItemFlavor_GetShortDescription( item ) )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, ruiBadge, bgModel, ItemFlavor_GetShortDescription( item ) )
}




const float RUI_LOADSCREEN_WIDTH = 800.0
const float RUI_LOADSCREEN_HEIGHT = 450.0
const float RUI_LOADSCREEN_Z_OFFSET = 30

void function ShowRewards_Loadscreen( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	vector placardOrigin = origin + <0, 0, RUI_LOADSCREEN_Z_OFFSET>
	float width          = RUI_LOADSCREEN_WIDTH / 16.0
	float height         = RUI_LOADSCREEN_HEIGHT / 16.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	
	var topo = CreateRUITopology_Worldspace( placardOrigin, placardAngles, width, height )
	var rui  = RuiCreate( $"ui/world_space_loadscreen.rpak", topo, RUI_DRAW_WORLD, 0 )

	if ( IsSpecialItemPresentationModeActive() )
		PopulateInspectMenuDetails( item, rarity, 1, "", "" ) 
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, rui )

	RuiSetImage( rui, "loadscreenImage", $"" )

	OnThreadEnd(
		function() : ( rui, topo )
		{
			RuiDestroyIfAlive( rui )
			RuiTopology_Destroy( topo )

			
			foreach ( handle in fileLevel.pakHandles )
			{
				if ( handle.isAvailable )
					ReleasePakFile( handle )
			}
		}
	)

	WaitFrame() 

	
	string rpak         = Loadscreen_GetRPakName( item )
	PakHandle pakHandle = RequestPakFile( rpak, TRACK_FEATURE_UI )
	fileLevel.pakHandles.append( pakHandle )

	if ( !pakHandle.isAvailable )
		WaitSignal( pakHandle, "PakFileLoaded" )

	RuiSetImage( rui, "loadscreenImage", Loadscreen_GetLoadscreenImageAsset( item ) )

	WaitForever()
}




const float RUI_REWARD_SET_TRACKER_WIDTH = 630.0
const float RUI_REWARD_SET_TRACKER_HEIGHT = 820.0
const float RUI_REWARD_SET_TRACKER_Z_OFFSET = 30.0
const float RUI_REWARD_SET_TRACKER_SCALE = 0.0625

void function ShowRewards_RewardSetTracker( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	vector placardOrigin = origin + <0, 0, RUI_REWARD_SET_TRACKER_Z_OFFSET>
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	UISize screenSize = GetScreenSize()
	var topo = CreateRUITopology_Worldspace( placardOrigin, placardAngles, 1920, 1080 )
	var rui  = RuiCreate( $"ui/world_space_image2d.rpak", topo, RUI_DRAW_WORLD, 0 )

	RuiSetBool( rui, "isVisible", true )
	RuiSetImage( rui, "image2d", RewardSetTracker_GetDisplayImageAsset( item ) )
	RuiSetFloat( rui, "imageWidth", RUI_REWARD_SET_TRACKER_WIDTH )
	RuiSetFloat( rui, "imageHeight", RUI_REWARD_SET_TRACKER_HEIGHT )
	RuiSetFloat( rui, "imageScale", RUI_REWARD_SET_TRACKER_SCALE )
	RuiSetBool( rui, "disableLoadIcon", true )

	OnThreadEnd(
		function() : ( rui, topo )
		{
			RuiDestroyIfAlive( rui )
			RuiTopology_Destroy( topo )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
	{
		PopulateInspectMenuDetails( item, rarity, 1, "", "" )
		
		
		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )
	}
	else
	{
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, rui )
	}
}



const float RUI_DEATHBOX_WIDTH = 800.0
const float RUI_DEATHBOX_HEIGHT = 450.0
const float RUI_DEATHBOX_Z_OFFSET = 30

void function ShowRewards_Deathbox( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	vector placardOrigin = origin + <0, 0, RUI_DEATHBOX_Z_OFFSET>
	float width          = RUI_DEATHBOX_WIDTH / 16.0
	float height         = RUI_DEATHBOX_HEIGHT / 16.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topo = CreateRUITopology_Worldspace( placardOrigin, placardAngles, width, height )
	var rui  = RuiCreate( $"ui/finisher_video.rpak", topo, RUI_DRAW_VIEW_MODEL, 0 )

	int videoChannel = ReserveVideoChannel()
	RuiSetInt( rui, "channel", videoChannel )
	StartVideoOnChannel( videoChannel, Deathbox_GetVideo( item ), true, 0.0 )

	OnThreadEnd(
		function() : ( rui, topo, videoChannel )
		{
			RuiDestroyIfAlive( rui )
			RuiTopology_Destroy( topo )
			ReleaseVideoChannel( videoChannel )
		}
	)

	bool isOwned = GRX_IsItemOwnedByPlayer( item, GetLocalClientPlayer() )
	string descString = isOwned ? "#EQUIP_IN_MELEE_MENU" : "#FINAL_MILESTONE_REWARD"

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, rui, descString )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, rui )
}



const float RUI_WEAPON_VIDEO_WIDTH = 800.0
const float RUI_WEAPON_VIDEO_HEIGHT = 450.0
const float RUI_WEAPON_VIDEO_Z_OFFSET = 30

void function ShowBattlePassItem_WeaponSkinVideo( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, asset video )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	vector placardOrigin = origin + <0, 0, RUI_WEAPON_VIDEO_Z_OFFSET>
	float width          = RUI_WEAPON_VIDEO_WIDTH / 16.0
	float height         = RUI_WEAPON_VIDEO_HEIGHT / 16.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topo = CreateRUITopology_Worldspace( placardOrigin, placardAngles, width, height )
	var rui  = RuiCreate( $"ui/finisher_video.rpak", topo, RUI_DRAW_VIEW_MODEL, 0 )

	int videoChannel = ReserveVideoChannel()
	RuiSetInt( rui, "channel", videoChannel )
	StartVideoOnChannel( videoChannel, video, true, 0.0 )

	OnThreadEnd(
		function() : ( rui, topo, videoChannel )
		{
			RuiDestroyIfAlive( rui )
			RuiTopology_Destroy( topo )
			ReleaseVideoChannel( videoChannel )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, rui )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, rui )
}



const float RUI_SKYDIVE_EMOTE_WIDTH = 800.0
const float RUI_SKYDIVE_EMOTE_HEIGHT = 450.0
const float RUI_SKYDIVE_EMOTE_Z_OFFSET = 30

void function ShowRewards_SkydiveEmote( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	vector placardOrigin = origin + <0, 0, RUI_SKYDIVE_EMOTE_Z_OFFSET>
	float width          = RUI_SKYDIVE_EMOTE_WIDTH / 16.0
	float height         = RUI_SKYDIVE_EMOTE_HEIGHT / 16.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topo = CreateRUITopology_Worldspace( placardOrigin, placardAngles, width, height )
	var rui  = RuiCreate( $"ui/finisher_video.rpak", topo, RUI_DRAW_VIEW_MODEL, 0 )

	int videoChannel = ReserveVideoChannel()
	RuiSetInt( rui, "channel", videoChannel )
	StartVideoOnChannel( videoChannel, SkydiveEmote_GetVideo( item ), true, 0.0 )

	OnThreadEnd(
		function() : ( rui, topo, videoChannel )
		{
			RuiDestroyIfAlive( rui )
			RuiTopology_Destroy( topo )
			ReleaseVideoChannel( videoChannel )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, rui )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, rui )
}




void function ShowRewards_CharacterEmote( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	origin += <0, 0, CHARACTER_SKIN_Z_OFFSET>

	ItemFlavor ornull char = CharacterQuip_GetCharacterFlavor( item )

	if ( char == null )
		char = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

	expect ItemFlavor( char )

	ItemFlavor skin = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_CharacterSkin( char ) )

	
	if ( string(ItemFlavor_GetAsset( item )) == CAUSTIC_SPECIAL_CASE_EMOTE_ASSET_PATH )
	{
		angles += < 0, 50, 0 >
	}

	entity mover          = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity characterModel = CreateClientSidePropDynamic( origin, angles, $"mdl/dev/empty_model.rmdl" )

	CharacterSkin_Apply( characterModel, skin )
	characterModel.MakeSafeForUIScriptHack()
	mover.MakeSafeForUIScriptHack()
	characterModel.SetParent( mover )

	thread ModelPerformEmote( characterModel, item, mover, false )

	
	characterModel.SetModelScale( CHARACTER_SKIN_SCALE )

	
	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( characterModel, flashType, flashColor )
	LootCeremonyUpdateSpotLights( attachment, true, eItemType.character_skin )

	OnThreadEnd(
		function() : ( mover, characterModel, attachment )
		{
			characterModel.Destroy()
			mover.Destroy()
			LootCeremonyUpdateSpotLights( attachment, false )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, 1, angles, mover, characterModel, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, 1, characterModel, mover, angles, 360.0 )
}




const float VOUCHER_Z_OFFSET = 31.0

void function ShowRewards_Voucher( ItemFlavor item, vector origin, vector angles, int rarity, int quantity, int displayIndex, string attachment )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	origin += <0, 0, VOUCHER_Z_OFFSET>

	asset modelAsset = Voucher_GetModel( item )
	entity moverEnt = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	entity modelEnt
	if ( Voucher_GetEffectBattlepassStars( item ) > 0 )
	{
		modelEnt = CreateClientSidePropDynamic( origin, AnglesCompose( angles, <90, 32, 0> ), BATTLEPASS_STAR_REWARD_MODEL )
		modelEnt.SetModelScale( 0.25 )
	}
	else
	{
		modelEnt = CreateClientSidePropDynamic( origin, angles, modelAsset )
		
		int flashType     = GetLootCeremonyFlashType( item )
		vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
		thread FlashMenuModel( modelEnt, flashType, flashColor )
		LootCeremonyUpdateSpotLights( attachment, true, eItemType.voucher )

		OnThreadEnd(
			function() : ( moverEnt, modelEnt, attachment )
			{
				modelEnt.Destroy()
				moverEnt.Destroy()
				LootCeremonyUpdateSpotLights( attachment, false )
			}
		)
		modelEnt.SetModelScale( 0.75 )
	}

	moverEnt.MakeSafeForUIScriptHack()
	modelEnt.MakeSafeForUIScriptHack()
	modelEnt.SetParent( moverEnt )

	moverEnt.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, quantity, angles, moverEnt, modelEnt, 360.0 )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, quantity, modelEnt, moverEnt, angles, 360.0 )
}




void function ShowRewards_Sticker( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	origin += <0, 0, 29>

	entity mover = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", origin, angles )
	mover.MakeSafeForUIScriptHack()

	entity stickerModel = CreateClientSidePropDynamic( origin, angles, UNAPPLIED_STICKER_MODEL )
	stickerModel.MakeSafeForUIScriptHack()
	stickerModel.SetParent( mover )

	asset stickerMat = Sticker_GetReplacementMaterialAsset( item )
	int stickerInstance = Sticker_SetMaterialModForLocalPlayer( stickerModel, stickerMat )

	int flashType     = GetLootCeremonyFlashType( item )
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	Sticker_CreateFlashData( stickerInstance, stickerModel, flashType, flashColor )
	Sticker_OnPlaced( stickerInstance, Sticker_FlashOnLoadComplete )

	OnThreadEnd(
		function() : ( mover, stickerModel )
		{
			stickerModel.Destroy()
			mover.Destroy()
		}
	)

	int quantity = 1
	float maxYaw = 0 

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_Model( item, rarity, quantity, angles, mover, stickerModel, maxYaw )
	else
		InspectMenuFunctionality_Model( item, displayIndex, rarity, quantity, stickerModel, mover, angles, maxYaw )
}




const float RUI_PLACEHOLDER_WIDTH = 450.0
const float RUI_PLACEHOLDER_HEIGHT = 200.0
const float RUI_PLACEHOLDER_Z_OFFSET = 25

void function ShowRewards_PLACEHOLDER( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	vector placardOrigin = origin + <0, 0, RUI_PLACEHOLDER_Z_OFFSET>
	float width          = RUI_PLACEHOLDER_WIDTH / 16.0
	float height         = RUI_PLACEHOLDER_HEIGHT / 16.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topoPlaceholder = CreateRUITopology_Worldspace( placardOrigin, placardAngles, width, height )
	var ruiPlaceholder  = RuiCreate( $"ui/loot_reward_temp.rpak", topoPlaceholder, RUI_DRAW_WORLD, 0 )

	RuiSetString( ruiPlaceholder, "bodyText", Localize( ItemFlavor_GetLongName( item ) ) )

	OnThreadEnd(
		function() : ( ruiPlaceholder, topoPlaceholder )
		{
			RuiDestroyIfAlive( ruiPlaceholder )
			RuiTopology_Destroy( topoPlaceholder )
		}
	)

	if ( IsSpecialItemPresentationModeActive() )
		SpecialItemPresentationView_RUI( item, rarity, ruiPlaceholder )
	else
		InspectMenuFunctionality_RUI( item, displayIndex, rarity, ruiPlaceholder )
}



const float RUI_PLACARD_WIDTH 			= 550.0
const float RUI_PLACARD_HEIGHT 			= 256.0
const float RUI_PLACARD_Z_OFFSET		= 7.0
const float RUI_PLACARD_FORWARD_OFFSET 	= 32.0
const bool  RUI_PLACARD_DEBUG 			= false
const int   MYTHIC_PRESTIGE_RARITY_INDEX = eRarityTier._COUNT 


void function ShowRewards_Placard( ItemFlavor item, vector origin, vector angles, int rarity, int displayIndex )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	vector placardOrigin = origin + (AnglesToForward( angles ) * RUI_PLACARD_FORWARD_OFFSET) + <0, 0, RUI_PLACARD_Z_OFFSET>
	float width          = RUI_PLACARD_WIDTH / 18.0
	float height         = RUI_PLACARD_HEIGHT / 18.0
	vector placardAngles = VectorToAngles( AnglesToForward( angles ) * -1 )

	var topoPlacard = CreateRUITopology_Worldspace( placardOrigin + <0, 0, (height * 0.5)>, placardAngles, width, height )
	int ruiDrawMode = string(ItemFlavor_GetAsset( item )) == CAUSTIC_SPECIAL_CASE_EMOTE_ASSET_PATH ? RUI_DRAW_VIEW_MODEL : RUI_DRAW_WORLD
	var ruiPlacard  = RuiCreate( $"ui/loot_placard.rpak", topoPlacard, ruiDrawMode, 1 )

	if ( ItemFlavor_GetType( item ) == eItemType.account_currency )
	{
		RuiSetString( ruiPlacard, "nameText", ItemFlavor_GetShortName( item ) )
	}
	else if ( ItemFlavor_GetType( item ) == eItemType.account_currency_bundle )
	{
		ItemFlavor currencyFlav = GRXCurrencyBundle_GetCurrencyFlav( item )
		RuiSetString( ruiPlacard, "nameText", ItemFlavor_GetShortName( currencyFlav ) )
	}
	else if ( Mythics_IsItemFlavorMythicSkin( item ) )
	{
		int tierIndex = Mythics_GetSkinTierIntForSkin( item )

		RuiSetString( ruiPlacard, "nameText", Localize( "#TIER", tierIndex ) )
		rarity = MYTHIC_PRESTIGE_RARITY_INDEX

		if ( tierIndex == 1 && Mythics_SkinHasCustomSkydivetrail( item ) )
			RuiSetString( ruiPlacard, "additionalText", "+" + Localize( "#PRESTIGE_PLUS_SKYDIVE_TRAIL" ).toupper() )

		if ( tierIndex == 3 )
			RuiSetString( ruiPlacard, "additionalText", "+" + Localize( "#itemtype_character_execution_NAME" ).toupper() )

		if ( tierIndex > 1 )
			RuiSetBool( ruiPlacard, "isLocked", true )
	}
	else
	{
		RuiSetString( ruiPlacard, "nameText", ItemFlavor_GetTypeName( item ) )
	}
	RuiSetInt( ruiPlacard, "rarity", rarity )

	fileLevel.rewardPlacards[ INSPECT_BUTTONS[displayIndex] ] = ruiPlacard

	OnThreadEnd(
		function() : ( ruiPlacard, topoPlacard, displayIndex )
		{
			RuiDestroyIfAlive( ruiPlacard )
			RuiTopology_Destroy( topoPlacard )

			fileLevel.rewardPlacards[INSPECT_BUTTONS[displayIndex]] = null
		}
	)

	while( true )
	{
		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		RuiSetBool( ruiPlacard, "visible", false )

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		RuiSetBool( ruiPlacard, "visible", true )
	}
}




void function UIToClient_RewardPlacard_Hover( var menuButton, bool isHovered )
{
	var rui = RewardPlacard_GetRuiFromMenuButton( menuButton )

	if ( IsValid( rui ) )
		RuiSetBool( rui, "isHovered", isHovered )

	MythicSetButtonModelFade( menuButton, !isHovered )
}



void function MythicUpdateAllEffects( bool enable )
{
	WaitFrame()
	if ( fileLevel.characterSkinModels.len() < 2 )
		return

	if ( !enable )
	{
		thread MythicModelClear( fileLevel.characterSkinModels[0] )
		thread MythicModelClear( fileLevel.characterSkinModels[1] )
	}
	else
	{
		thread MythicModelFade( fileLevel.characterSkinModels[0] )
		thread MythicModelFade( fileLevel.characterSkinModels[1] )
	}
}

void function MythicSetButtonModelFade( var menuButton, bool fade )
{
	if ( fileLevel.characterSkinModels.len() < 2 || Hud_GetHudName( menuButton ) == INSPECT_BUTTONS[1] )
		return

	entity model

	if ( Hud_GetHudName( menuButton ) == INSPECT_BUTTONS[0] )
		model = fileLevel.characterSkinModels[0]
	else if ( Hud_GetHudName( menuButton ) == INSPECT_BUTTONS[2] )
		model = fileLevel.characterSkinModels[1]

	if( !IsValid( model ) )
		return

	if( fade && !fileLevel.inspectModeActive )
		thread MythicModelFade( model )
	else
		thread MythicModelClear( model )
}

void function MythicModelFade( entity model )
{
	WaitFrame()

	if( !IsValid( model ) )
		return

	array<entity> hierachy = GetEntityAndImmediateChildren( model )
	foreach ( entity childEnt in hierachy )
	{
		childEnt.Highlight_ResetFlags()
		childEnt.Highlight_SetCurrentContext( HighlightContext_GetId( "mythic_model_fade" ) )
		childEnt.Highlight_SetFadeInTime( 1 )
		childEnt.Highlight_SetFadeOutTime( 999999 )
		childEnt.Highlight_StartOn()
		childEnt.Highlight_SetLifeTime( 99999999 )
	}
}

void function MythicModelClear( entity model )
{
	WaitFrame()

	if( !IsValid( model ) )
		return
	array<entity> hierachy = GetEntityAndImmediateChildren( model )
	foreach ( entity childEnt in hierachy )
	{
		childEnt.Highlight_SetCurrentContext( HIGHLIGHT_INVALID_ID )
	}
}



var function RewardPlacard_GetRuiFromMenuButton( var menuButton )
{
	string menuButtonName = Hud_GetHudName( menuButton )

	return fileLevel.rewardPlacards[menuButtonName]
}




void function ShowInspect_FX( int animAttachID, int rarity, vector rarityColor )
{
	EndSignal( level, "EndSetPresentationType" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	
	asset particleAssetRarity
	switch ( rarity )
	{
		case 0:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER1
			break

		case 1:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER2
			break

		case 2:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER3
			break

		case 3:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER4
			break

		case 4:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER5
			break

		case 5:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER6
			break

		default:
			Assert( false, "Couldn't find particle beam asset based on rarity: " + rarity )
	}

	int fxIndexRarity = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( particleAssetRarity ), FX_PATTACH_POINT_FOLLOW, animAttachID )
	EffectSetControlPointVector( fxIndexRarity, 1, rarityColor )

	int fxIndexBeam = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( TICK_FX_HOLO_BEAM_BASE ), FX_PATTACH_POINT_FOLLOW, animAttachID )
	EffectSetControlPointVector( fxIndexBeam, 1, rarityColor )

	table<string, int> fxTrackerBeam = { fxID = fxIndexBeam }

	OnThreadEnd(
		function() : ( fxIndexRarity, fxTrackerBeam )
		{
			if ( EffectDoesExist( fxIndexRarity ) )
				EffectStop( fxIndexRarity, true, false )

			if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
				EffectStop( fxTrackerBeam[ "fxID" ], true, false )
		}
	)

	WaitForever()
}

void function ShowRewards_FX( int animAttachID, int rarity, vector rarityColor, int displayIndex )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	Chroma_LootCeremonyReward( displayIndex, rarity )

	
	asset particleAssetRarity
	switch ( rarity )
	{
		case 0:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER1
			break

		case 1:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER2
			break

		case 2:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER3
			break

		case 3:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER4
			break

		case 4:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER5
			break

		case 5:
			particleAssetRarity = TICK_FX_HOLO_BEAM_TIER6
			break

		default:
			Assert( false, "Couldn't find particle beam asset based on rarity: " + rarity )
	}

	int fxIndexRarity = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( particleAssetRarity ), FX_PATTACH_POINT_FOLLOW, animAttachID )
	EffectSetControlPointVector( fxIndexRarity, 1, rarityColor )

	int fxIndexBeam = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( TICK_FX_HOLO_BEAM_BASE ), FX_PATTACH_POINT_FOLLOW, animAttachID )
	EffectSetControlPointVector( fxIndexBeam, 1, rarityColor )

	table<string, int> fxTrackerBeam = { fxID = fxIndexBeam }

	if ( IsSpecialItemPresentationModeActive() )
	{
		OnThreadEnd(
			function() : ( fxIndexRarity, fxTrackerBeam )
			{
				if ( EffectDoesExist( fxIndexRarity ) )
					EffectStop( fxIndexRarity, true, false )

				if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
					EffectStop( fxTrackerBeam[ "fxID" ], true, false )
			}
		)

		WaitForever()
	}
	else
		InspectMenuFunctionality_FXBeams( displayIndex, fxIndexRarity, fxTrackerBeam, animAttachID, rarityColor )
}



#if DEV
void function DEV_ShouldShowCustomLootRewards( bool shouldShow )
{
	fileLevel.debugShowCustomRewards = shouldShow
}
#endif

#if DEV
void function DEV_SetCustomLootRewardsToDisplay( string itemRef0 = "", string itemRef1 = "", string itemRef2 = "" )
{
	DEV_ShouldShowCustomLootRewards( true )

	array<string> flavorRefs = [itemRef0, itemRef1, itemRef2]
	array<asset> flavorAssets

	foreach ( string ref in  flavorRefs )
	{
		if ( ref == "" )
			continue

		ItemFlavor flavor
		if ( DEV_IsValidGRXRef( ref ) )
			flavor = DEV_GetItemFlavorByGRXRef( ref )
		else if ( DEV_IsValidItemFlavorHumanReadableRef_Slow( ref ) )
			flavor = DEV_GetItemFlavorByHumanReadableRef_Slow( ref )
		else
			Assert( false, "unknown item ref " + ref )

		asset flavorAsset = ItemFlavor_GetAsset( flavor )
		flavorAssets.append( flavorAsset )
	}

	fileLevel.debugCustomRewardAssets = flavorAssets
}
#endif





















const float INSPECT_ZOOM_TIME = 0.25



void function UIToClient_RewardInspectActivate( var menuButton )
{
	thread UIToClient_RewardInspectActivate_Threaded( menuButton )
}




void function UIToClient_RewardInspectActivate_Threaded( var menuButton )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

	table<string, bool> success = { result = false }

	
	RunUIScript( "ClientToUI_SetInspectModeIsActive" )
	RunUIScript( "ClientToUI_UpdateStoreButtonVisibility" )
	RunUIScript( "LootCeremony_UpdateOpenAdditionalButton" )
	DisableFakeInspectButtons()

	fileLevel.inspectModeActive = true
	thread MythicUpdateAllEffects( false )

	
	string menuButtonName = Hud_GetHudName( menuButton )
	Signal( fileLevel.signalDummy, "LootCeremonyInspectModeStart", { inspectButton = menuButtonName } )

	
	InspectMenu_ZoomIn( menuButton )

	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_INSPECT_ZOOM_IN )

	OnThreadEnd(
		function() : ( success )
		{
			if ( success[ "result" ] == false )
			{
				if ( !IsLootCeremonyActive() )
				{
					fileLevel.cameraMover.NonPhysicsStop()
					fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )

					DisableInspectMenu()
				}
			}
		}
	)

	wait INSPECT_ZOOM_TIME

	EnableInspectMenu()
	Signal( fileLevel.signalDummy, "LootCeremonyInspectModeStartComplete" )

	success[ "result" ] = true
}




void function InspectMenu_ZoomIn( var menuButton, bool instantZoom = false )
{
	table<string, vector> zoomOrgAngles = RewardInspect_GetCameraOrgAnglesFromMenuButton( menuButton )

	InspectMenu_SetZoom( zoomOrgAngles[ "origin" ], zoomOrgAngles[ "angles" ], instantZoom )
}

void function InspectMenu_SetZoom( vector zoomOrigin, vector zoomAngles, bool instantZoom = false )
{
	fileLevel.cameraMover.ClearParent()

	if ( instantZoom )
	{
		fileLevel.cameraMover.SetOrigin( zoomOrigin )
		fileLevel.cameraMover.SetAngles( zoomAngles )
	}
	else
	{
		fileLevel.cameraMover.NonPhysicsMoveTo( zoomOrigin, INSPECT_ZOOM_TIME, 0, 0.1 )
		fileLevel.cameraMover.NonPhysicsRotateTo( zoomAngles, INSPECT_ZOOM_TIME, 0, 0.1 )
	}
}




void function UIToClient_RewardInspectNavBack()
{
	thread UIToClient_RewardInspectNavBack_Threaded()
}




void function UIToClient_TrackButtonOnClick()
{
	if ( Hud_IsLocked( fileLevel.trackChallengeButton ) )
	{
		RunUIScript( "ClientToUI_PlayLootCeremonySound", "menu_deny" )
		return
	}

	RunUIScript( "ClientToUI_TrackMythicChallenge", ItemFlavor_GetGUID( fileLevel.trackButtonItemFlavor) )
}

void function UIToClient_RewardEquipOnClick()
{
#if DEV
		if ( fileLevel.debugShowCustomRewards )
		{
			Warning( "Trying to equip a reward you may not actually own. You should disable custom rewards." )
		}
#endif

	if ( Hud_IsLocked( fileLevel.equipButton ) )
	{
		RunUIScript( "ClientToUI_PlayLootCeremonySound", "menu_deny" )
		return
	}

	RunUIScript( "ClientToUI_LootCeremonyMarkItemAsNoLongerNew", ItemFlavor_GetGUID( fileLevel.equipButtonItemFlavor ) )

	int itemType              = ItemFlavor_GetType( fileLevel.equipButtonItemFlavor )
	array<LoadoutEntry> entry = EquipButton_GetItemLoadoutEntries( fileLevel.equipButtonItemFlavor, false )

	if ( entry.len() == 1 )
	{
		UIToClient_RewardEquipOnClickWithIndex( 0 )
	}
	else
	{
		RunUIScript( "ClientToUI_EquipButtonShowDialog", ItemFlavor_GetGUID( fileLevel.equipButtonItemFlavor ) )
	}
}

void function UIToClient_RewardEquipOnClickWithIndex( int index )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( fileLevel.equipButtonItemFlavor, false )

	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_EQUIP )
	RequestSetItemFlavorLoadoutSlot_WithDuplicatePrevention( LocalClientEHI(), entries, fileLevel.equipButtonItemFlavor, index )
	PIN_Customization( null, fileLevel.equipButtonItemFlavor, "equip", index )

	Hud_SetLocked( fileLevel.equipButton, true )
	var rui = Hud_GetRui( fileLevel.equipButton )
	RuiSetString( rui, "buttonText", "#EQUIPPED_LOOT_REWARD" )
	RuiSetString( rui, "descText", Localize( "#CURRENTLY_EQUIPPED_ITEM", Localize( ItemFlavor_GetLongName( fileLevel.equipButtonItemFlavor ) ) ) )

	int rarity = 0
	if ( ItemFlavor_HasQuality( fileLevel.equipButtonItemFlavor ) )
		rarity = ItemFlavor_GetQuality( fileLevel.equipButtonItemFlavor )

	RuiSetInt( rui, "descTextRarity", rarity )
}

void function UIToClient_RewardEquipToWheelOnClick()
{
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_EQUIP )
	RunUIScript( "ClientToUI_LootCeremonyMarkItemAsNoLongerNew", ItemFlavor_GetGUID( fileLevel.equipButtonItemFlavor ) )
	RunUIScript( "ClientToUI_EquipToWheelButtonShowDialog", ItemFlavor_GetGUID( fileLevel.equipButtonItemFlavor ) )
}

void function UIToClient_RewardEquipToWheelOnClickWithIndex( int index )
{
	int itemType                = ItemFlavor_GetType( fileLevel.equipButtonItemFlavor )
	ItemFlavor character        = expect ItemFlavor( GetItemFlavorAssociatedCharacterOrWeapon( fileLevel.equipButtonItemFlavor ) )
	array<LoadoutEntry> entries = []
	int numSlots
	LoadoutEntry functionref( ItemFlavor, int ) getEntryFunc

	
	

	if ( itemType == eItemType.skydive_emote )
	{
		numSlots     = NUM_SKYDIVE_EMOTE_SLOTS
		getEntryFunc = Loadout_SkydiveEmote
	}
	else
	{
		numSlots     = MAX_QUIPS_EQUIPPED
		getEntryFunc = Loadout_CharacterQuip
	}

	for ( int i = 0; i < numSlots; i++ )
	{
		LoadoutEntry entry = getEntryFunc( character, i )
		if ( LoadoutSlot_IsReady( LocalClientEHI(), entry ) )
			entries.append( entry )
	}

	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_EQUIP )
	RequestSetItemFlavorLoadoutSlot_WithDuplicatePrevention( LocalClientEHI(), entries, fileLevel.equipButtonItemFlavor, index )
	PIN_Customization( null, fileLevel.equipButtonItemFlavor, "equip", index )
}




array<LoadoutEntry> function EquipButton_GetItemLoadoutEntries( ItemFlavor item, bool statTrackerFindExistingEntry = false )
{
	int itemType = ItemFlavor_GetType( item )
	array<LoadoutEntry> loadoutEntries

	switch ( itemType )
	{
		case eItemType.character_skin:
			loadoutEntries = [ Loadout_CharacterSkin( CharacterSkin_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.weapon_skin:
			loadoutEntries = [ Loadout_WeaponSkin( WeaponSkin_GetWeaponFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_frame:
			ItemFlavor ornull character = GladiatorCardFrame_GetCharacterFlavor( item )
			if ( character == null ) 
				character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )
			expect ItemFlavor( character )

			loadoutEntries = [ Loadout_GladiatorCardFrame( character ) ]
			break

		case eItemType.gladiator_card_stance:
			loadoutEntries = [ Loadout_GladiatorCardStance( GladiatorCardStance_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.character_execution:
			loadoutEntries = [ Loadout_CharacterExecution( CharacterExecution_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_intro_quip:
			loadoutEntries = [ Loadout_CharacterIntroQuip( CharacterIntroQuip_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_kill_quip:
			loadoutEntries = [ Loadout_CharacterKillQuip( CharacterKillQuip_GetCharacterFlavor( item ) ) ]
			break

		case eItemType.gladiator_card_stat_tracker:
			if ( statTrackerFindExistingEntry )
			{
				loadoutEntries = [ PopulateInspectMenuDetails_GetStatTrackerLoadoutEntry( item, statTrackerFindExistingEntry ) ]
			}
			else
			{
				ItemFlavor ornull character = GladiatorCardStatTracker_GetCharacterFlavor( item )
				if ( character == null ) 
					character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

				expect ItemFlavor( character )

				for ( int trackerIndex = 0; trackerIndex < GLADIATOR_CARDS_NUM_TRACKERS; trackerIndex++ )
				{
					LoadoutEntry trackerSlot = Loadout_GladiatorCardStatTracker( character, trackerIndex )
					if ( LoadoutSlot_IsReady( LocalClientEHI(), trackerSlot ) )
						loadoutEntries.append( trackerSlot )
				}
			}
			break

		case eItemType.artifact_component_blade:
			loadoutEntries = [ Loadout_MeleeSkin( LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() ) ) ]
			break

		case eItemType.melee_skin:
			if ( !MeleeSkin_HasSpecificCharacterFlavor( item ) )
			{
				loadoutEntries = [ Loadout_MeleeSkin( LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() ) ) ]
				break
			}
			loadoutEntries = [ Loadout_MeleeSkin( MeleeSkin_GetCharacterFlavor( item ) ) ]
			break


		case eItemType.artifact_component_deathbox:
			loadoutEntries = [ Loadout_Deathbox( LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() ) ) ]
			break


		case eItemType.gladiator_card_badge:
			ItemFlavor character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

			for ( int badgeIndex = 0; badgeIndex < GLADIATOR_CARDS_NUM_BADGES; badgeIndex++ )
			{
				LoadoutEntry badgeSlot = Loadout_GladiatorCardStatTracker( character, badgeIndex )
				if ( LoadoutSlot_IsReady( LocalClientEHI(), badgeSlot ) )
					loadoutEntries.append( badgeSlot )
			}
			break

		case eItemType.music_pack:
			loadoutEntries = [ Loadout_MusicPack() ]
			break

		case eItemType.loadscreen:
			loadoutEntries = [ Loadout_Loadscreen() ]
			break

		case eItemType.skydive_trail:
			loadoutEntries = [ Loadout_SkydiveTrail() ]
			break

		case eItemType.skydive_emote:
			ItemFlavor character = SkydiveEmote_GetCharacterFlavor( item )

			for ( int emoteIndex = 0; emoteIndex < NUM_SKYDIVE_EMOTE_SLOTS; emoteIndex++ )
			{
				LoadoutEntry emoteSlot = Loadout_SkydiveEmote( character, emoteIndex )
				if ( LoadoutSlot_IsReady( LocalClientEHI(), emoteSlot ) )
					loadoutEntries.append( emoteSlot )
			}
			break

		case eItemType.emote_icon:
		case eItemType.character_emote:
			ItemFlavor ornull character = CharacterQuip_GetCharacterFlavor( item )
			if ( character == null ) 
				character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )
			expect ItemFlavor( character )

			for ( int emoteIndex = 0; emoteIndex < MAX_QUIPS_EQUIPPED; emoteIndex++ )
			{
				LoadoutEntry emoteSlot = Loadout_CharacterQuip( character, emoteIndex )
				if ( LoadoutSlot_IsReady( LocalClientEHI(), emoteSlot ) )
					loadoutEntries.append( emoteSlot )
			}
			break

		case eItemType.sticker:
			for ( int stickerObjectType = 0; stickerObjectType < eStickerObjectType.len(); stickerObjectType++ )
			{
				for ( int stickerIndex = 0; stickerIndex < GetMaxStickersForObjectType( stickerObjectType ); stickerIndex++ )
				{
					LoadoutEntry stickerSlot = Loadout_Sticker( stickerObjectType, stickerIndex )
					if ( LoadoutSlot_IsReady( LocalClientEHI(), stickerSlot ) )
						loadoutEntries.append( stickerSlot )
				}
			}
			break

			case eItemType.reward_set_tracker:
				break
			case eItemType.voucher:
				break

		case eItemType.account_currency:
			break
		case eItemType.account_pack:
			break
		case eItemType.weapon_charm:
			break

		
		case eItemType.character:
			ItemFlavor characterSkin = CharacterClass_GetDefaultSkin( item )
			loadoutEntries = [ Loadout_CharacterSkin( CharacterSkin_GetCharacterFlavor( characterSkin ) ) ]
			break

		default:
			Assert( false, "Loot Ceremony equip button does not support reward type: " + DEV_GetEnumStringSafe( "eItemType", itemType ) )
	}

	return loadoutEntries
}




LoadoutEntry function PopulateInspectMenuDetails_GetStatTrackerLoadoutEntry( ItemFlavor item, bool findExistingEntry )
{
	ItemFlavor ornull character = GladiatorCardStatTracker_GetCharacterFlavor( item )
	if ( character == null ) 
		character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )

	expect ItemFlavor( character )

	for ( int trackerIndex = 0; trackerIndex < GLADIATOR_CARDS_NUM_TRACKERS; trackerIndex++ )
	{
		LoadoutEntry trackerSlot = Loadout_GladiatorCardStatTracker( character, trackerIndex )
		ItemFlavor flavor        = LoadoutSlot_GetItemFlavor( LocalClientEHI(), trackerSlot )

		if ( findExistingEntry )
		{
			if ( flavor == item )
				return trackerSlot
		}
		else if ( LoadoutSlot_IsReady( LocalClientEHI(), trackerSlot ) )
		{
			if ( GladiatorCardTracker_IsTheEmpty( flavor ) )
				return trackerSlot
		}
	}

	LoadoutEntry fallback = Loadout_GladiatorCardStatTracker( character, (GLADIATOR_CARDS_NUM_TRACKERS - 1) )
	return fallback
}




void function UIToClient_RewardInspectNavBack_Threaded()
{
	if ( fileLevel.inspectMenuIsNavigatingBack )
		return

	fileLevel.inspectMenuIsNavigatingBack = true

	Signal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	table<string, bool> success = { result = false }

	DisableInspectMenu()

	
	int attachID        = fileLevel.lootTickModel.LookupAttachment( "CAMERA" )
	vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachID )
	vector attachAngles = fileLevel.lootTickModel.GetAttachmentAngles( attachID )

	fileLevel.cameraMover.NonPhysicsMoveTo( attachOrigin, INSPECT_ZOOM_TIME, 0, 0.1 )
	fileLevel.cameraMover.NonPhysicsRotateTo( attachAngles, INSPECT_ZOOM_TIME, 0, 0.1 )

	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_INSPECT_ZOOM_OUT )

	OnThreadEnd(
		function() : ( success )
		{
			if ( success[ "result" ] == false )
			{
				if ( !IsLootCeremonyActive() )
				{
					fileLevel.cameraMover.NonPhysicsStop()
					fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
					fileLevel.inspectMenuIsNavigatingBack = false
				}
			}
		}
	)

	wait INSPECT_ZOOM_TIME

	fileLevel.cameraMover.SetParent( fileLevel.lootTickModel, "CAMERA" )
	RunUIScript( "ClientToUI_ClearInspectModeIsActive" )
	RunUIScript( "ClientToUI_UpdateStoreButtonVisibility" )
	RunUIScript( "LootCeremony_UpdateOpenAdditionalButton" )
	EnableFakeInspectButtons()
	RunUIScript( "ClientToUI_PlayLootCeremonySound", SOUND_HOLOGRAM_APPEAR_RESETVIEW )
	fileLevel.inspectModeActive = false
	thread MythicUpdateAllEffects( true )

	Signal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

	fileLevel.inspectMenuIsNavigatingBack = false
	success[ "result" ] = true
}




void function EnableInspectMenu()
{
	Hud_SetEnabled( fileLevel.inspectMenu, true )
	Hud_SetVisible( fileLevel.inspectMenu, true )
	RuiSetBool( Hud_GetRui( fileLevel.inspectMenu ), "isVisible", true )

	
	

	Hud_SetEnabled( fileLevel.mouseClickElem, true )
	Hud_SetVisible( fileLevel.mouseClickElem, true )
}




void function DisableInspectMenu()
{
	Hud_SetEnabled( fileLevel.inspectMenu, false )
	Hud_SetVisible( fileLevel.inspectMenu, false )
	RuiSetBool( Hud_GetRui( fileLevel.inspectMenu ), "isVisible", false )

	Hud_SetEnabled( fileLevel.equipButton, false )
	Hud_SetVisible( fileLevel.equipButton, false )

	Hud_SetEnabled( fileLevel.trackChallengeButton, false )
	Hud_SetVisible( fileLevel.trackChallengeButton, false )

	Hud_SetVisible( fileLevel.equipToWheelButton, false )

	Hud_SetEnabled( fileLevel.mouseClickElem, false )
	Hud_SetVisible( fileLevel.mouseClickElem, false )

	Hud_SetEnabled( fileLevel.inspectVideoPanel, false )
	Hud_SetVisible( fileLevel.inspectVideoPanel, false )
}



const float INSPECT_FORWARD_OFFSET = 136.0
const float INSPECT_FORWARD_OFFSET_WEAPON = 100.0
const float INSPECT_FORWARD_OFFSET_CHARM = 45.0
const float INSPECT_FORWARD_OFFSET_EXECUTION = 100.0
const float INSPECT_FORWARD_OFFSET_CURRENCY = 100.0

const float INSPECT_RIGHT_OFFSET = -24.0
const float INSPECT_RIGHT_OFFSET_WEAPON = -18.0
const float INSPECT_RIGHT_OFFSET_CHARM = -7.5
const float INSPECT_RIGHT_OFFSET_EXECUTION = -20.0
const float INSPECT_RIGHT_OFFSET_CURRENCY = -20.0

const float INSPECT_UP_OFFSET = 30.0
const float INSPECT_UP_OFFSET_EXECUTION = 28.0
const float INSPECT_UP_OFFSET_CHARM = 30.0



table<string, vector> function RewardInspect_GetCameraOrgAnglesFromMenuButton( var menuButton )
{
	string menuButtonName = Hud_GetHudName( menuButton )
	int menuButtonIndex   = INSPECT_BUTTONS.find( menuButtonName )
	string attachment     = TICK_LOOT_ATTACHMENTS[menuButtonIndex]

	int itemType
	foreach ( ItemPresentationData data in fileLevel.itemPresentationDatas )
	{
		if ( data.attachment == attachment )
		{
			itemType = ItemFlavor_GetType( data.item )
			break
		}
	}

	return RewardInspect_GetCameraOrgAngles( attachment, itemType )
}

table<string, vector> function RewardInspect_GetCameraOrgAngles( string attachment, int itemType )
{
	float forwardOffset
	float rightOffset
	float upOffset
	if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_WEAPON
		rightOffset = INSPECT_RIGHT_OFFSET_WEAPON
		upOffset = INSPECT_UP_OFFSET
	}
	else if ( itemType == eItemType.weapon_charm )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_CHARM
		rightOffset = INSPECT_RIGHT_OFFSET_CHARM
		upOffset = INSPECT_UP_OFFSET_CHARM
	}
	else if ( itemType == eItemType.character_execution )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_EXECUTION
		rightOffset = INSPECT_RIGHT_OFFSET_EXECUTION
		upOffset = INSPECT_UP_OFFSET_EXECUTION
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_CURRENCY
		rightOffset = INSPECT_RIGHT_OFFSET_CURRENCY
		upOffset = INSPECT_UP_OFFSET
	}
	else
	{
		forwardOffset = INSPECT_FORWARD_OFFSET
		rightOffset = INSPECT_RIGHT_OFFSET
		upOffset = INSPECT_UP_OFFSET
	}

	int attachID        = fileLevel.lootTickModel.LookupAttachment( attachment )
	vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachID )
	vector attachAngles = VectorToAngles( FlattenVec( fileLevel.cameraMover.GetOrigin() - attachOrigin ) )

	vector offsetRight   = (AnglesToRight( attachAngles ) * rightOffset)
	vector offsetForward = (AnglesToForward( attachAngles ) * forwardOffset)
	vector zoomOrigin    = attachOrigin + offsetRight + offsetForward + <0, 0, upOffset>

	table<string, vector> zoomOrgAngles = {
		origin = zoomOrigin,
		angles = VectorToAngles( FlattenVec( attachOrigin - fileLevel.cameraMover.GetOrigin() ) )
	}

	return zoomOrgAngles
}

table<string, vector> function Inspect_GetCameraOrgAngles( string attachment, int itemType )
{
	float forwardOffset
	float rightOffset
	float upOffset
	if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET
		rightOffset = 0
		upOffset = 26
	}
	else if ( itemType == eItemType.character_execution )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET
		rightOffset = 0
		upOffset = 18
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		forwardOffset = INSPECT_FORWARD_OFFSET_CURRENCY
		rightOffset = 0
		upOffset = INSPECT_UP_OFFSET
	}
	else if ( itemType == eItemType.character_skin )
	{
		forwardOffset = 212
		rightOffset = 0
		upOffset = 20
	}
	else
	{
		forwardOffset = INSPECT_FORWARD_OFFSET
		rightOffset = 0
		upOffset = INSPECT_UP_OFFSET
	}

	int attachID        = fileLevel.lootTickModel.LookupAttachment( attachment )
	vector attachOrigin = fileLevel.lootTickModel.GetAttachmentOrigin( attachID )
	vector attachAngles = VectorToAngles( FlattenVec( fileLevel.cameraMover.GetOrigin() - attachOrigin ) )

	vector offsetRight   = (AnglesToRight( attachAngles ) * rightOffset)
	vector offsetForward = (AnglesToForward( attachAngles ) * forwardOffset)
	vector zoomOrigin    = attachOrigin + offsetRight + offsetForward + <0, 0, upOffset>

	table<string, vector> zoomOrgAngles = {
		origin = zoomOrigin,
		angles = VectorToAngles( FlattenVec( attachOrigin - fileLevel.cameraMover.GetOrigin() ) )
	}

	return zoomOrgAngles
}




bool function ShouldShowControlHintsForItemType( int itemType )
{
	switch( itemType )
	{
		case eItemType.account_currency_bundle:
		case eItemType.character_skin:
		case eItemType.weapon_skin:
		case eItemType.melee_skin:
		case eItemType.character_execution:
		case eItemType.weapon_charm:
			return true
	}

	return false
}




void function PopulateInspectMenuDetails_WeaponSkin( ItemFlavor item, int rarity, int quantity )
{
	PopulateInspectMenuDetails( item, rarity, quantity, ItemFlavor_GetShortName( WeaponSkin_GetWeaponFlavor( item ) ) )
}




void function PopulateInspectMenuDetails_MeleeSkin( ItemFlavor item, int rarity, int quantity )
{

	string miscString = MeleeSkin_HasSpecificCharacterFlavor( item ) ? ItemFlavor_GetShortName( MeleeSkin_GetCharacterFlavor( item ) ) : "#REWARD_GENERIC"



	PopulateInspectMenuDetails( item, rarity, quantity, miscString )
}




void function PopulateInspectMenuDetails_CharacterSkin( ItemFlavor item, int rarity, int quantity )
{
	PopulateInspectMenuDetails( item, rarity, quantity, ItemFlavor_GetShortName( CharacterSkin_GetCharacterFlavor( item ) ) )
}




void function PopulateInspectMenuDetails_CharacterEmote( ItemFlavor item, int rarity, int quantity )
{
	ItemFlavor ornull char = CharacterQuip_GetCharacterFlavor( item )

	if ( char == null )
		PopulateInspectMenuDetails( item, rarity, 1 )
	else
	{
		expect ItemFlavor( char )
		PopulateInspectMenuDetails( item, rarity, quantity, ItemFlavor_GetShortName( char ) )
	}
}




void function PopulateInspectMenuDetails( ItemFlavor item, int rarity, int quantity, string miscString = "", string descString = "" )
{
	int itemType = ItemFlavor_GetType( item )

	var rui             = Hud_GetRui( fileLevel.inspectMenu )
	string itemTypeName = ItemFlavor_GetTypeName( item )
	string itemName     = "?"
	RuiSetInt( rui, "mythicTier", -1 )

	if ( itemType == eItemType.gladiator_card_stat_tracker )
	{
		itemName = Localize( ItemFlavor_GetShortName( item ) )
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		ItemFlavor currencyFlav = GRXCurrencyBundle_GetCurrencyFlav( item )
		itemTypeName = ItemFlavor_GetShortName( currencyFlav )
		itemName = Localize( "#CURRENCY_AMOUNT", string( ItemFlavor_GetIcon( currencyFlav ) ), GRXCurrencyBundle_GetValue( item ) )
	}
	else if ( itemType == eItemType.account_currency )
	{
		itemTypeName = ItemFlavor_GetShortName( item )
		itemName = Localize( "#CURRENCY_AMOUNT", string( ItemFlavor_GetIcon( item ) ), quantity )
	}
	else if ( itemType == eItemType.account_pack )
	{
		itemName = Localize( ItemFlavor_GetLongName( item ) )
		if ( quantity != 1 )
			itemName += " x" + quantity
	}
	else if ( itemType == eItemType.voucher )
	{
		itemTypeName = ItemFlavor_GetLongName( item )
		itemName = ""
		descString = ItemFlavor_GetLongDescription( item )
		if ( Voucher_GetEffectBattlepassStars( item ) > 0 )
		{
			int starsQuantity = Voucher_GetEffectBattlepassStars( item )
			itemTypeName = starsQuantity > 1 ? ItemFlavor_GetLongName( item ) : ItemFlavor_GetShortName( item )
			itemName = starsQuantity > 1 ? "x" + starsQuantity : ""
		}
	}

		else if ( itemType == eItemType.reward_set_tracker )
		{
			itemTypeName = Localize( ItemFlavor_GetLongName( item ) )
			itemName = Localize( ItemFlavor_GetShortName( item ) )
		}

	else if ( Mythics_IsItemFlavorMythicSkin( item ) )
	{
		int mythicTier = Mythics_GetSkinTierIntForSkin( item )
		RuiSetInt( rui, "mythicTier", mythicTier )
		itemName = Localize( ItemFlavor_GetLongName( item ) )
		itemTypeName = Localize( "#MYTHIC_SKIN" )
	}
	else
	{
		itemName = Localize( ItemFlavor_GetLongName( item ) )
	}

	if ( itemType == eItemType.gladiator_card_badge || itemType == eItemType.gladiator_card_stat_tracker )
	{
		descString = ""
	}

	RuiSetString( rui, "itemType", itemTypeName )
	RuiSetString( rui, "itemName", itemName )
	RuiSetInt( rui, "rarity", rarity )
	RuiSetString( rui, "miscText", miscString )
	RuiSetString( rui, "descText", descString )
	RuiSetBool( rui, "showControlsHints", ShouldShowControlHintsForItemType( itemType ) )

	

	
	RuiSetFloat( rui, "descTextPositionScalar", ((itemType == eItemType.gladiator_card_stat_tracker) ? 1.0 : 0.0) )


	
	if ( itemType != eItemType.account_currency_bundle )
		RunUIScript( "ClientToUI_LootCeremonyMarkItemAsNoLongerNew", ItemFlavor_GetGUID( item ) )

	
	fileLevel.equipButtonItemFlavor = item
	var equipButtonRui = Hud_GetRui( fileLevel.equipButton )

	
	if ( Mythics_IsItemFlavorMythicSkin( item ) )
	{
		var trackButtonRui = Hud_GetRui( fileLevel.trackChallengeButton )

		ItemFlavor challenge = Mythics_GetChallengeForSkin( item )
		bool isChallengeTracked = IsFavoriteChallenge( challenge )
		RuiSetString( trackButtonRui, "buttonText", isChallengeTracked ?  "#CHALLENGE_TRACKED" : "#CHALLENGE_TRACK" )
		RuiSetBool( trackButtonRui, "isChallengeTracked", isChallengeTracked )
		fileLevel.trackButtonItemFlavor = item
		Hud_SetVisible( fileLevel.trackChallengeButton, true )
		Hud_SetEnabled( fileLevel.trackChallengeButton, true )
	}
	else
	{

		Hud_SetVisible( fileLevel.trackChallengeButton, false )
	}

	Hud_SetVisible( fileLevel.equipToWheelButton, false )

	array<int> hideItemList = [
		eItemType.weapon_charm,
		eItemType.skydive_emote,
		eItemType.account_pack,
		eItemType.account_currency,
		eItemType.account_currency_bundle,
		eItemType.voucher,
		eItemType.sticker,

			eItemType.reward_set_tracker,
			eItemType.artifact_component_deathbox,

	]

	bool hasValidCharacterOrWeapon = ( GetItemFlavorAssociatedCharacterOrWeapon( item ) != null ) 

	if ( hideItemList.contains(itemType) )
	{
		Hud_SetVisible( fileLevel.equipButton, false )
		Hud_SetEnabled( fileLevel.equipButton, false )

		if ( ItemFlavor_CanEquipToWheel( item ) )
		{
			bool isOwned = GRX_IsItemOwnedByPlayer( item, GetLocalClientPlayer() )
			if ( isOwned && hasValidCharacterOrWeapon )
			{
				Hud_SetVisible( fileLevel.equipToWheelButton, true )
				Hud_SetEnabled( fileLevel.equipToWheelButton, true )
				Hud_SetLocked( fileLevel.equipToWheelButton, false )

				var equipWheelButtonRui = Hud_GetRui( fileLevel.equipToWheelButton )
				string equipTip = ItemFlavor_GetType( item ) == eItemType.skydive_emote ? "#EQUIP_SKYDIVE_WHEEL_REWARD" : "#EQUIP_WHEEL_LOOT_REWARD"
				RuiSetString( equipWheelButtonRui, "buttonText", equipTip )
				RuiSetString( equipWheelButtonRui, "descText", "" )
			}
			else if ( isOwned && ! hasValidCharacterOrWeapon )
			{
				Hud_SetVisible( fileLevel.equipToWheelButton, true )
				Hud_SetEnabled( fileLevel.equipToWheelButton, false )
				Hud_SetLocked( fileLevel.equipToWheelButton, true )

				var equipWheelButtonRui = Hud_GetRui( fileLevel.equipToWheelButton )
				RuiSetString( equipWheelButtonRui, "buttonText", "#UNLOCKED" )
				RuiSetString( equipWheelButtonRui, "descText", "#EQUIP_IN_LEGENDS_MENU" )
			}
		}
	}
	else if ( IsItemEquipped( item ) )
	{
		Hud_SetVisible( fileLevel.equipButton, true )

		if ( ItemFlavor_CanEquipToWheel( item ) && hasValidCharacterOrWeapon )
		{
			Hud_SetVisible( fileLevel.equipToWheelButton, true )
			Hud_SetEnabled( fileLevel.equipToWheelButton, true )
			Hud_SetLocked( fileLevel.equipToWheelButton, false )

			var equipWheelButtonRui = Hud_GetRui( fileLevel.equipToWheelButton )
			string equipTip = ItemFlavor_GetType( item ) == eItemType.skydive_emote ? "#EQUIP_SKYDIVE_WHEEL_REWARD" : "#EQUIP_WHEEL_LOOT_REWARD"
			RuiSetString( equipWheelButtonRui, "buttonText", equipTip )
			RuiSetString( equipWheelButtonRui, "descText", "" )
		}

		Hud_SetEnabled( fileLevel.equipButton, true )
		Hud_SetLocked( fileLevel.equipButton, true )

		RuiSetString( equipButtonRui, "buttonText", "#EQUIPPED_LOOT_REWARD" )
		RuiSetString( equipButtonRui, "descText", Localize( "#CURRENTLY_EQUIPPED_ITEM", Localize( ItemFlavor_GetLongName( item ) ) ) )
		RuiSetInt( equipButtonRui, "descTextRarity", rarity )
	}
	else
	{
		bool agnosticEquipToCurrentCharacter = ( itemType == eItemType.melee_skin || itemType == eItemType.character_emote || itemType == eItemType.emote_icon )
		if ( agnosticEquipToCurrentCharacter && !hasValidCharacterOrWeapon )
		{
			ItemFlavor character = LoadoutSlot_GetItemFlavor( LocalClientEHI(), Loadout_Character() )
			RuiSetString( equipButtonRui, "buttonText", Localize( "#EQUIP_LOOT_REWARD_TO", Localize( ItemFlavor_GetLongName( character ) ) ) )
		}
		else
		{
			RuiSetString( equipButtonRui, "buttonText", "#EQUIP_LOOT_REWARD" )
		}

		RuiSetString( equipButtonRui, "descText", Localize( "#CURRENTLY_EQUIPPED_ITEM", Localize( GetCurrentlyEquippedItemNameForItemTypeSlot( item ) ) ) )
		RuiSetInt( equipButtonRui, "descTextRarity", GetCurrentlyEquippedItemRarityForItemTypeSlot( item ) )

		if ( !Hud_IsVisible( Hud_GetChild( fileLevel.menu, "InspectPurchaseButton" ) ) )
		{
			Hud_SetVisible( fileLevel.equipButton, true )

			if ( ItemFlavor_CanEquipToWheel( item ) && hasValidCharacterOrWeapon )
			{
				Hud_SetVisible( fileLevel.equipToWheelButton, true )
				Hud_SetEnabled( fileLevel.equipToWheelButton, true )
				Hud_SetLocked( fileLevel.equipToWheelButton, false )

				var equipWheelButtonRui = Hud_GetRui( fileLevel.equipToWheelButton )
				string equipTip = ItemFlavor_GetType( item ) == eItemType.skydive_emote ? "#EQUIP_SKYDIVE_WHEEL_REWARD" : "#EQUIP_WHEEL_LOOT_REWARD"
				RuiSetString( equipWheelButtonRui, "buttonText", equipTip )
				RuiSetString( equipWheelButtonRui, "descText", "" )
			}

			Hud_SetEnabled( fileLevel.equipButton, true )
			Hud_SetLocked( fileLevel.equipButton, false )

			if( Mythics_IsItemFlavorMythicSkin( item ) && Mythics_GetSkinTierIntForSkin( item ) > 1)
			{
				Hud_SetLocked( fileLevel.equipButton, true )
				RuiSetString( equipButtonRui, "buttonText", "#EQUIP_LOCKED")
				RuiSetString( equipButtonRui, "descText", "#CHALLENGE_MYTHIC_LOCKED_ICON")
			}
		}
	}
}




bool function IsItemEquipped( ItemFlavor item )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( item, true )
	foreach ( entry in entries )
	{
		if ( item == LoadoutSlot_GetItemFlavor( LocalClientEHI(), entry ) )
			return true
	}

	return false
}




string function GetCurrentlyEquippedItemNameForItemTypeSlot( ItemFlavor referenceItem )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( referenceItem, true )

	ItemFlavor equippedItem = LoadoutSlot_GetItemFlavor( LocalClientEHI(), entries[ 0 ] )
	return ItemFlavor_GetLongName( equippedItem )
}




int function GetCurrentlyEquippedItemRarityForItemTypeSlot( ItemFlavor referenceItem )
{
	array<LoadoutEntry> entries = EquipButton_GetItemLoadoutEntries( referenceItem, true )

	ItemFlavor equippedItem = LoadoutSlot_GetItemFlavor( LocalClientEHI(), entries[ 0 ] )

	if ( ItemFlavor_HasQuality( equippedItem ) )
		return ItemFlavor_GetQuality( equippedItem )

	return -1
}




void function ClearInspectMenuDetails()
{
	var rui = Hud_GetRui( fileLevel.inspectMenu )
	RuiSetString( rui, "itemType", "#UNKNOWN_LOOT_REWARD" )
	RuiSetString( rui, "itemName", "#UNKNOWN_LOOT_REWARD" )
	RuiSetString( rui, "miscText", "" )
	RuiSetInt( rui, "rarity", 0 )
}




void function InspectMenuFunctionality_Model( ItemFlavor item, int displayIndex, int rarity, int quantity, entity model, entity mover, vector startAngles, float maxYaw )
{
	int itemType = ItemFlavor_GetType( item )

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		if ( !activelyInspecting )
		{
			HideEntityAndChildren( model )
			mover.NonPhysicsStop()
		}
		else
		{
			
			if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
			{
				HideEntityAndChildren( model )
				mover.NonPhysicsStop()
			}

			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
				{
					if ( itemType == eItemType.weapon_skin )
						PopulateInspectMenuDetails_WeaponSkin( item, rarity, quantity )
					else if ( itemType == eItemType.melee_skin )
						PopulateInspectMenuDetails_MeleeSkin( item, rarity, quantity )

					mover.SetAngles( startAngles )
					mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )
					ShowEntityAndChildren( model )

					vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
					thread FlashMenuModel( model, eMenuModelFlashType.LOOT_CEREMONY_QUICK, flashColor )
				}
				else if ( itemType == eItemType.character_skin )
				{
					PopulateInspectMenuDetails_CharacterSkin( item, rarity, 1 )
				}
				else if ( itemType == eItemType.account_currency_bundle )
				{
					PopulateInspectMenuDetails( item, rarity, quantity, "", "#CURRENCY_CRAFTING_DESCRIPTION" )
				}
				else if ( itemType == eItemType.account_currency )
				{
					PopulateInspectMenuDetails( item, rarity, quantity, "", ItemFlavor_GetLongDescription( item ) )
				}
				else if ( itemType == eItemType.character_emote )
				{
					PopulateInspectMenuDetails_CharacterEmote( item, rarity, 1 )
				}
				else
				{
					PopulateInspectMenuDetails( item, rarity, 1 )
				}

				waitthread TurntableModelController( model, mover, itemType, null, maxYaw )
			}
			else
			{
				HideEntityAndChildren( model )
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		mover.SetAngles( startAngles )

		if ( itemType == eItemType.character_emote )
		{
			model.Anim_Stop()
			thread ModelPerformEmote( model, item, mover, false, true )
		}

		ShowEntityAndChildren( model )

		vector flashColor    = ItemFlavor_GetQualityColor( item ) / 255
		bool includeChildren = true
		bool depthDiscard = ItemFlavor_GetType( item ) == eItemType.sticker
		thread FlashMenuModel( model, eMenuModelFlashType.LOOT_CEREMONY_QUICK, flashColor, includeChildren, depthDiscard )

		if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin || itemType == eItemType.account_currency_bundle )
			mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )
	}
}




void function SpecialItemPresentationView_Model( ItemFlavor item, int rarity, int quantity, vector angles, entity mover, entity model, float maxYaw )
{
	int itemType = ItemFlavor_GetType( item )

	if ( itemType == eItemType.weapon_skin )
	{
		PopulateInspectMenuDetails_WeaponSkin( item, rarity, quantity )
	}
	else if ( itemType == eItemType.melee_skin )
	{
		PopulateInspectMenuDetails_MeleeSkin( item, rarity, quantity )
	}
	else if ( itemType == eItemType.character_skin )
	{
		PopulateInspectMenuDetails_CharacterSkin( item, rarity, quantity )
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		PopulateInspectMenuDetails( item, rarity, quantity, "", "#CURRENCY_CRAFTING_DESCRIPTION" )
	}
	else if ( itemType == eItemType.account_currency )
	{
		PopulateInspectMenuDetails( item, rarity, quantity, "", ItemFlavor_GetLongDescription( item ) )
	}
	else
	{
		PopulateInspectMenuDetails( item, rarity, quantity )
	}

	waitthread TurntableModelController( model, mover, itemType, null, maxYaw )
}



const float EXECUTION_START_VIDEO_DELAY = 0.25
const float EXECUTION_START_TURNTABLE_DELAY = 0.15



void function InspectMenuFunctionality_Execution( ItemFlavor item, int displayIndex, int rarity, entity attackerModel, entity victimModel, entity mover, vector startAngles )
{
	int itemType         = ItemFlavor_GetType( item )
	var rui              = Hud_GetRui( fileLevel.inspectVideoPanel )
	string characterName = ItemFlavor_GetShortName( CharacterExecution_GetCharacterFlavor( item ) )

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		if ( !activelyInspecting )
		{
			HideEntityAndChildren( attackerModel )
			HideEntityAndChildren( victimModel )
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				PopulateInspectMenuDetails( item, rarity, 1, characterName )

				int attachIDAttacker = attackerModel.LookupAttachment( "ORIGIN" )
				int attachIDVictim   = victimModel.LookupAttachment( "ORIGIN" )
				int fxIndexAttacker  = StartParticleEffectOnEntity( attackerModel, GetParticleSystemIndex( FINISHER_SWAP_FX ), FX_PATTACH_POINT_FOLLOW, attachIDAttacker )
				int fxIndexVictim    = StartParticleEffectOnEntity( victimModel, GetParticleSystemIndex( FINISHER_SWAP_FX ), FX_PATTACH_POINT_FOLLOW, attachIDVictim )

				bool delayCompleted = WaitForInspectTimeCompleteOrBackout( EXECUTION_START_VIDEO_DELAY )

				HideEntityAndChildren( attackerModel )
				HideEntityAndChildren( victimModel )

				if ( delayCompleted )
				{
					Hud_SetVisible( fileLevel.inspectVideoPanel, true )
					Hud_SetEnabled( fileLevel.inspectVideoPanel, true )

					int videoChannel = ReserveVideoChannel( ExecutionVideoOnFinished )
					RuiSetInt( rui, "channel", videoChannel )
					StartVideoOnChannel( videoChannel, CharacterExecution_GetExecutionVideo( item ), false, 0.0 )

					bool videoCompleted = WaitForInspectVideoCompleteOrBackout()

					Hud_SetVisible( fileLevel.inspectVideoPanel, false )
					Hud_SetEnabled( fileLevel.inspectVideoPanel, false )

					ReleaseVideoChannel( videoChannel )

					if ( videoCompleted )
					{
						bool secondDelayCompleted = WaitForInspectTimeCompleteOrBackout( EXECUTION_START_TURNTABLE_DELAY )

						if ( secondDelayCompleted )
						{
							ShowEntityAndChildren( attackerModel )
							ShowEntityAndChildren( victimModel )

							int flashType     = eMenuModelFlashType.LOOT_CEREMONY_QUICK
							vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
							thread FlashMenuModel( attackerModel, flashType, flashColor )
							thread FlashMenuModel( victimModel, flashType, flashColor )

							mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )
							waitthread TurntableModelController( attackerModel, mover, itemType, victimModel )
						}
					}
				}
				else
				{
					if ( EffectDoesExist( fxIndexAttacker ) )
						EffectStop( fxIndexAttacker, true, false )

					if ( EffectDoesExist( fxIndexVictim ) )
						EffectStop( fxIndexVictim, true, false )
				}
			}
			else
			{
				HideEntityAndChildren( attackerModel )
				HideEntityAndChildren( victimModel )
			}

			ClearInspectMenuDetails()
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		mover.NonPhysicsStop()
		mover.SetAngles( startAngles )
		ShowEntityAndChildren( attackerModel )
		ShowEntityAndChildren( victimModel )

		int flashType     = eMenuModelFlashType.LOOT_CEREMONY_QUICK
		vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
		thread FlashMenuModel( attackerModel, flashType, flashColor )
		thread FlashMenuModel( victimModel, flashType, flashColor )
	}
}




void function SpecialItemPresentationView_Execution( ItemFlavor item, int rarity, entity attackerModel, entity victimModel, entity mover )
{
	int itemType         = ItemFlavor_GetType( item )
	var rui              = Hud_GetRui( fileLevel.inspectVideoPanel )
	string characterName = ItemFlavor_GetShortName( CharacterExecution_GetCharacterFlavor( item ) )

	PopulateInspectMenuDetails( item, rarity, 1, characterName )

	wait 1

	int attachIDAttacker = attackerModel.LookupAttachment( "ORIGIN" )
	int attachIDVictim   = victimModel.LookupAttachment( "ORIGIN" )
	int fxIndexAttacker  = StartParticleEffectOnEntity( attackerModel, GetParticleSystemIndex( FINISHER_SWAP_FX ), FX_PATTACH_POINT_FOLLOW, attachIDAttacker )
	int fxIndexVictim    = StartParticleEffectOnEntity( victimModel, GetParticleSystemIndex( FINISHER_SWAP_FX ), FX_PATTACH_POINT_FOLLOW, attachIDVictim )

	wait EXECUTION_START_VIDEO_DELAY

	HideEntityAndChildren( attackerModel )
	HideEntityAndChildren( victimModel )

	Hud_SetVisible( fileLevel.inspectVideoPanel, true )
	Hud_SetEnabled( fileLevel.inspectVideoPanel, true )

	int videoChannel = ReserveVideoChannel( ExecutionVideoOnFinished )
	RuiSetInt( rui, "channel", videoChannel )
	StartVideoOnChannel( videoChannel, CharacterExecution_GetExecutionVideo( item ), false, 0.0 )

	bool videoCompleted = WaitForInspectVideoCompleteOrBackout()

	Hud_SetVisible( fileLevel.inspectVideoPanel, false )
	Hud_SetEnabled( fileLevel.inspectVideoPanel, false )

	ReleaseVideoChannel( videoChannel )

	wait EXECUTION_START_TURNTABLE_DELAY

	ShowEntityAndChildren( attackerModel )
	ShowEntityAndChildren( victimModel )

	int flashType     = eMenuModelFlashType.LOOT_CEREMONY_QUICK
	vector flashColor = ItemFlavor_GetQualityColor( item ) / 255
	thread FlashMenuModel( attackerModel, flashType, flashColor )
	thread FlashMenuModel( victimModel, flashType, flashColor )

	mover.NonPhysicsRotate( <0, 0, 1>, MODEL_ROTATE_SPEED )

	waitthread TurntableModelController( attackerModel, mover, itemType, victimModel )
}




void function ExecutionVideoOnFinished( int channel )
{
	Signal( fileLevel.signalDummy, "LootCeremonyVideoComplete" )
}




void function InspectMenuFunctionality_RUI( ItemFlavor item, int displayIndex, int rarity, var rui, entity bgModel = null, string descString = "" )
{
	int itemType    = ItemFlavor_GetType( item )
	string nameText = ""

	switch ( itemType )
	{
		case eItemType.gladiator_card_stat_tracker:
			if ( GladiatorCardStatTracker_GetCharacterFlavor( item ) != null )
			{
				nameText = ItemFlavor_GetShortName( expect ItemFlavor(GladiatorCardStatTracker_GetCharacterFlavor( item )))
			}
			break
	}

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		
		if ( !activelyInspecting )
		{
			RuiSetBool( rui, "isVisible", false )

			if ( IsValid( bgModel ) )
				bgModel.Hide()
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				PopulateInspectMenuDetails( item, rarity, 1, nameText, descString )

				WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

				RuiSetBool( rui, "isVisible", false )

				if ( IsValid( bgModel ) )
					bgModel.Hide()

				ClearInspectMenuDetails()
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )

				if ( IsValid( bgModel ) )
					bgModel.Hide()
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		RuiSetBool( rui, "introComplete", true )
		RuiSetBool( rui, "isVisible", true )

		if ( IsValid( bgModel ) )
			bgModel.Show()
	}
}




void function SpecialItemPresentationView_RUI( ItemFlavor item, int rarity, var rui, string descString = "" )
{
	int itemType    = ItemFlavor_GetType( item )
	string nameText = ""

	switch ( itemType )
	{
		case eItemType.gladiator_card_stat_tracker:
			if ( GladiatorCardStatTracker_GetCharacterFlavor( item ) == null )
			{
				break
			}

			nameText = ItemFlavor_GetShortName( expect ItemFlavor( GladiatorCardStatTracker_GetCharacterFlavor( item ) ) )
			break
	}

	PopulateInspectMenuDetails( item, rarity, 1, nameText, descString )

	WaitForever()
}



const float QUIP_START_AUDIO_DELAY = 0.25



void function InspectMenuFunctionality_Quip( ItemFlavor item, int displayIndex, int rarity, var rui, entity bgModel )
{
	int itemType = ItemFlavor_GetType( item )

	string nameText  = ""
	string quipAlias = ""
	if ( itemType == eItemType.gladiator_card_kill_quip )
	{
		quipAlias = CharacterKillQuip_GetVictimVoiceSoundEvent( item )
		nameText = ItemFlavor_GetShortName( CharacterKillQuip_GetCharacterFlavor( item ) )
	}
	else
	{
		quipAlias = CharacterIntroQuip_GetVoiceSoundEvent( item )
		nameText = ItemFlavor_GetShortName( CharacterIntroQuip_GetCharacterFlavor( item ) )
	}

	if ( quipAlias == "" )
		Warning( "Quip sound alias came back empty. It probably hasn't been authored yet: " + ItemFlavor_GetLongName( item ) )

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		if ( !activelyInspecting )
		{
			RuiSetBool( rui, "isVisible", false )
			bgModel.Hide()
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				PopulateInspectMenuDetails( item, rarity, 1, nameText )

				bool delayCompleted = WaitForInspectTimeCompleteOrBackout( QUIP_START_AUDIO_DELAY )

				if ( delayCompleted )
				{
					if ( quipAlias != "" )
						RunUIScript( "ClientToUI_PlayLootCeremonySound", quipAlias )

					WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

					if ( quipAlias != "" )
						RunUIScript( "ClientToUI_StopLootCeremonySound", quipAlias )

					RuiSetBool( rui, "isVisible", false )
					bgModel.Hide()
					ClearInspectMenuDetails()
				}
				else
				{
					RuiSetBool( rui, "isVisible", false )
					bgModel.Hide()
				}
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )
				bgModel.Hide()
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		RuiSetBool( rui, "introComplete", true )
		RuiSetBool( rui, "isVisible", true )
		bgModel.Show()
	}
}




void function SpecialItemPresentationView_Quip( ItemFlavor item, int rarity, var rui )
{
	int itemType = ItemFlavor_GetType( item )

	string nameText  = ""
	string quipAlias = ""
	if ( itemType == eItemType.gladiator_card_kill_quip )
	{
		quipAlias = CharacterKillQuip_GetVictimVoiceSoundEvent( item )
		nameText = ItemFlavor_GetShortName( CharacterKillQuip_GetCharacterFlavor( item ) )
	}
	else
	{
		quipAlias = CharacterIntroQuip_GetVoiceSoundEvent( item )
		nameText = ItemFlavor_GetShortName( CharacterIntroQuip_GetCharacterFlavor( item ) )
	}

	if ( quipAlias == "" )
		Warning( "Quip sound alias came back empty. It probably hasn't been authored yet: " + ItemFlavor_GetLongName( item ) )

	OnThreadEnd(
		function() : ( quipAlias )
		{
			if ( quipAlias != "" )
				RunUIScript( "ClientToUI_StopLootCeremonySound", quipAlias )
		}
	)

	PopulateInspectMenuDetails( item, rarity, 1, nameText )

	wait 0.75

	if ( quipAlias != "" )
		RunUIScript( "ClientToUI_PlayLootCeremonySound", quipAlias )

	WaitForever()
}




void function InspectMenuFunctionality_MusicPack( ItemFlavor item, int displayIndex, int rarity, var rui, entity bgModel )
{
	string nameText = ItemFlavor_GetShortName( item )
	string previewAlias = MusicPack_GetPreviewMusic( item )

	if ( previewAlias == "" )
		Warning( "Music pack sound alias came back empty. It probably hasn't been authored yet: " + ItemFlavor_GetLongName( item ) )

	while ( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		if ( !activelyInspecting )
		{
			RuiSetBool( rui, "isVisible", false )
			bgModel.Hide()
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( inspectComplete )
			{
				PopulateInspectMenuDetails( item, rarity, 1, nameText )

				bool delayCompleted = WaitForInspectTimeCompleteOrBackout( QUIP_START_AUDIO_DELAY )

				if ( delayCompleted )
				{
					if ( previewAlias != "" )
						RunUIScript( "ClientToUI_PlayLootCeremonySound", previewAlias )

					WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

					if ( previewAlias != "" )
						RunUIScript( "ClientToUI_StopLootCeremonySound", previewAlias )

					RuiSetBool( rui, "isVisible", false )
					bgModel.Hide()
					ClearInspectMenuDetails()
				}
				else
				{
					RuiSetBool( rui, "isVisible", false )
					bgModel.Hide()
				}
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )
				bgModel.Hide()
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		RuiSetBool( rui, "introComplete", true )
		RuiSetBool( rui, "isVisible", true )
		bgModel.Show()
	}
}




void function SpecialItemPresentationView_MusicPack( ItemFlavor item, int rarity, var rui )
{
	string nameText = ItemFlavor_GetShortName( item )
	string previewAlias = MusicPack_GetPreviewMusic( item )

	if ( previewAlias == "" )
		Warning( "Music pack sound alias came back empty. It probably hasn't been authored yet: " + ItemFlavor_GetLongName( item ) )

	OnThreadEnd(
		function() : ( previewAlias )
		{
			if ( previewAlias != "" )
				RunUIScript( "ClientToUI_StopLootCeremonySound", previewAlias )
		}
	)

	PopulateInspectMenuDetails( item, rarity, 1, nameText )

	wait 0.75

	if ( previewAlias != "" )
		RunUIScript( "ClientToUI_PlayLootCeremonySound", previewAlias )

	WaitForever()
}




void function InspectMenuFunctionality_GladiatorCard( ItemFlavor item, int itemType, vector origin, vector angles, int displayIndex, int rarity, GladiatorCardData gCardData )
{
	table <string, GladiatorCardData> gCardDataTracker = { data = gCardData }
	OnThreadEnd(
		function() : ( gCardDataTracker )
		{
			ShowRewards_GladiatorCard_Destroy( gCardDataTracker.data )
		}
	)

	string characterName
	if ( itemType == eItemType.gladiator_card_frame )
	{
		ItemFlavor ornull character = GladiatorCardFrame_GetCharacterFlavor( item )
		if ( character == null )
		{
			characterName = "#REWARD_GENERIC"
		}
		else
		{
			expect ItemFlavor( character )
			characterName = ItemFlavor_GetShortName( character )
		}
	}
	else
	{
		characterName = ItemFlavor_GetShortName( GladiatorCardStance_GetCharacterFlavor( item ) )
	}

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton = expect string( results.inspectButton )

		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		
		if ( !activelyInspecting )
		{
			ShowRewards_GladiatorCard_Destroy( gCardDataTracker.data )
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( !inspectComplete )
			{
				ShowRewards_GladiatorCard_Destroy( gCardDataTracker.data )
			}
			else
			{
				PopulateInspectMenuDetails( item, rarity, 1, characterName )

				WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

				ShowRewards_GladiatorCard_Destroy( gCardDataTracker.data )

				ClearInspectMenuDetails()
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		
		gCardDataTracker.data = ShowRewards_GladiatorCard_Create( item, itemType, false, rarity, origin, angles )
	}
}




void function SpecialItemPresentationView_GladiatorCard( ItemFlavor item, int itemType, int rarity, GladiatorCardData gCardData )
{
	OnThreadEnd(
		function() : ( gCardData )
		{
			ShowRewards_GladiatorCard_Destroy( gCardData )
		}
	)

	string characterName
	if ( itemType == eItemType.gladiator_card_frame )
	{
		ItemFlavor ornull character = GladiatorCardFrame_GetCharacterFlavor( item )
		if ( character == null )
		{
			characterName = "#REWARD_GENERIC"
		}
		else
		{
			expect ItemFlavor( character )
			characterName = ItemFlavor_GetShortName( character )
		}
	}
	else
	{
		characterName = ItemFlavor_GetShortName( GladiatorCardStance_GetCharacterFlavor( item ) )
	}

	PopulateInspectMenuDetails( item, rarity, 1, characterName )

	WaitForever()
}




void function InspectMenuFunctionality_FXBeams( int displayIndex, int fxIndexRarity, table<string, int> fxTrackerBeam, int animAttachID, vector rarityColor )
{
	OnThreadEnd(
		function() : ( fxIndexRarity, fxTrackerBeam )
		{
			if ( EffectDoesExist( fxIndexRarity ) )
				EffectStop( fxIndexRarity, true, false )

			if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
				EffectStop( fxTrackerBeam[ "fxID" ], true, false )
		}
	)

	while( true )
	{
		table results = WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeStart" )

		string inspectButton    = expect string( results.inspectButton )
		int buttonIndex         = INSPECT_BUTTONS.find( inspectButton )
		bool activelyInspecting = false

		if ( buttonIndex == displayIndex )
			activelyInspecting = true

		
		if ( !activelyInspecting )
		{
			if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
				EffectStop( fxTrackerBeam[ "fxID" ], true, false )
		}
		else
		{
			bool inspectComplete = WaitForInspectCompleteOrBackout()

			if ( !inspectComplete )
			{
				if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
					EffectStop( fxTrackerBeam[ "fxID" ], true, false )
			}
			else
			{
				WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

				if ( EffectDoesExist( fxTrackerBeam[ "fxID" ] ) )
					EffectStop( fxTrackerBeam[ "fxID" ], true, false )
			}
		}

		WaitSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEndComplete" )

		int newFxIndexBeam = StartParticleEffectOnEntity( fileLevel.lootTickModel, GetParticleSystemIndex( TICK_FX_HOLO_BEAM_BASE ), FX_PATTACH_POINT_FOLLOW, animAttachID )
		EffectSetControlPointVector( newFxIndexBeam, 1, rarityColor )
		fxTrackerBeam[ "fxID" ] = newFxIndexBeam
	}
}



const float TURNTABLE_MAX_TURN_DEGREES = 360.0
const float TURNTABLE_MAX_PITCH_DEGREES_WEAPON = 60.0



void function TurntableModelController( entity model, entity mover, int itemType, entity additionalModel = null, float maxYaw = TURNTABLE_MAX_TURN_DEGREES )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )

	MenuModelData modelData
	ModelData_SetMover( modelData, mover )
	ModelData_SetBaseAngles( modelData, <0, fileLevel.cameraMover.GetAngles().y + 90, 0> )
	ModelData_SetModel( modelData, model )
	float[2] delta = [0.0, 0.0]
	modelData.rotationDelta[0] = delta[0]
	modelData.rotationDelta[1] = delta[1]

	vector focalPoint = model.GetOrigin()
	float zoomMinDist = 0.0
	float zoomMaxDist = 64.0
	if ( itemType == eItemType.weapon_skin || itemType == eItemType.melee_skin )
	{
		focalPoint = model.GetAttachmentOrigin( model.LookupAttachment( "MENU_ROTATE" ) )
		zoomMaxDist = 52.0
	}
	else if ( itemType == eItemType.weapon_charm )
	{
		focalPoint = GetCharmForWeaponEntity( model ).GetWorldSpaceCenter()
		zoomMinDist = 0.0
		zoomMaxDist = 30.0
	}
	else if ( itemType == eItemType.character_skin )
	{
		focalPoint = model.GetAttachmentOrigin( model.LookupAttachment( "HEADFOCUS" ) )
		zoomMaxDist = 64.0
	}
	else if ( itemType == eItemType.character_execution )
	{
		focalPoint = model.GetAttachmentOrigin( model.LookupAttachment( "HEADFOCUS" ) )
		zoomMaxDist = 52.0
	}
	else if ( itemType == eItemType.account_pack )
	{
		focalPoint = model.GetAttachmentOrigin( model.LookupAttachment( "HEADFOCUS" ) )
		zoomMaxDist = 52.0
	}
	else if ( itemType == eItemType.account_currency_bundle )
	{
		focalPoint = model.GetOrigin()
		zoomMaxDist = 38.0
	}
	else if ( itemType == eItemType.emote_icon )
	{
		zoomMaxDist = 0.0
	}

	CameraZoomData cameraData
	cameraData.mover = fileLevel.cameraMover
	vector camPos = fileLevel.cameraMover.GetOrigin()
	cameraData.startPos = camPos + (Normalize( focalPoint - camPos ) * zoomMinDist)
	cameraData.endPos = camPos + (Normalize( focalPoint - camPos ) * zoomMaxDist)
	cameraData.maxDist = Distance( cameraData.startPos, cameraData.endPos )
	cameraData.normVec = Normalize( cameraData.endPos - cameraData.startPos )

	thread CameraZoomThread( cameraData )

	OnThreadEnd(
		function() : ( model, additionalModel )
		{
			CameraZoomThreadEnd()

			HideEntityAndChildren( model )

			if ( IsValid( additionalModel ) )
				HideEntityAndChildren( additionalModel )

			ClearInspectMenuDetails()
		}
	)

	float maxPitchDegrees = 0.0
	if ( itemType == eItemType.weapon_skin || itemType == eItemType.weapon_charm || itemType == eItemType.melee_skin )
		maxPitchDegrees = TURNTABLE_MAX_PITCH_DEGREES_WEAPON

	bool hasStopped = false

	while( true )
	{
		bool hasPlayerTurned = TurntableUpdateAnglesFromInput( modelData, maxYaw, maxPitchDegrees, !hasStopped )

		if ( !hasStopped && hasPlayerTurned )
		{
			if ( itemType != eItemType.character_skin )
				mover.NonPhysicsStop()

			hasStopped = true
		}

		WaitFrame()
	}
}




bool function WaitForInspectCompleteOrBackout()
{
	array<string> signalsToWait = ["LootCeremonyInspectModeStartComplete", "LootCeremonyInspectModeEnd", "LootCeremonyExit", "LootCeremonyAnimSeqStart"]
	string resultSignal         = GetWaitMultipleSignal( fileLevel.signalDummy, signalsToWait, "LootCeremonyInspectCompleteOrBackout" )

	if ( resultSignal == "LootCeremonyInspectModeStartComplete" )
		return true

	return false
}




bool function WaitForInspectTimeCompleteOrBackout( float timeToWait )
{
	thread WaitForTimeComplete( timeToWait )
	array<string> signalsToWait = ["LootCeremonyTimeComplete", "LootCeremonyInspectModeEnd", "LootCeremonyExit", "LootCeremonyAnimSeqStart"]
	string resultSignal         = GetWaitMultipleSignal( fileLevel.signalDummy, signalsToWait, "LootCeremonyInspectTimeCompleteOrBackout" )

	if ( resultSignal == "LootCeremonyTimeComplete" )
		return true

	return false
}




bool function WaitForInspectVideoCompleteOrBackout()
{
	array<string> signalsToWait = ["LootCeremonyVideoComplete", "LootCeremonyInspectModeEnd", "LootCeremonyExit", "LootCeremonyAnimSeqStart"]
	string resultSignal         = GetWaitMultipleSignal( fileLevel.signalDummy, signalsToWait, "LootCeremonyInspectVideoCompleteOrBackout" )

	if ( resultSignal == "LootCeremonyVideoComplete" )
		return true

	return false
}




void function WaitForTimeComplete( float timeToWait )
{
	EndSignal( fileLevel.signalDummy, "LootCeremonyInspectModeEnd" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyExit" )
	EndSignal( fileLevel.signalDummy, "LootCeremonyAnimSeqStart" )

	wait timeToWait

	Signal( fileLevel.signalDummy, "LootCeremonyTimeComplete" )
}




























































































































































































































bool function IsSpecialItemPresentationModeActive()
{
	return fileLevel.specialItemPresentationModeActive
}
















































































































































































































































































































































































































































































































































































































































































































































































































































































const float BLACK_FADE_TIME = 0.25
const float BLACK_FADE_TIME_HOLD = 0.25












































































































































































































