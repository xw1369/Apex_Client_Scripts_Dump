global function Sh_Ranked_Init
global function Sh_Ranked_ItemRegistrationInit
global function GetCurrentRankedDivisionFromScoreAndLadderPosition
global function GetCurrentRankedDivisionFromScore
global function GetCurrentRankedDivisions
global function GetNextRankedDivisionFromScore
global function GetPlayerRankScore
global function GetPrevSeasonPeakPlayerRankScore
global function IsRankedInSeason
global function GetRankedPersistenceData
global function GetRankedGameData
global function Ranked_ShouldShowRankedBadge
global function Ranked_ShouldShowPreRankedBadge
global function Ranked_GetRankedLevelRequirement
global function Ranked_GetTiers
global function Ranked_GetCostForEntry

global function Ranked_GetRankedDivisionDataForTier
global function Ranked_GetNextTierData
global function Ranked_GetLadderPosition
global function GetDemotionProtectionBuffer
global function Ranked_GetHigherOfTwoTiers
global function Ranked_PlayedGamesInPeriod
global function Ranked_IsValidHistoricalRankedPeriodGUID
global function Ranked_GetHistoricalRankScore
global function Ranked_GetHistoricalFirstSplitRankScore
global function Ranked_GetHistoricalRankedDivisionFromScore
global function Ranked_GetHighestHistoricalRankedTierData 
global function Ranked_GetHistoricalRankedDivisionFromScoreAndLadderPosition
global function Ranked_GetHistoricalRankedTiers
global function Ranked_GetHistoricalLadderPosition
global function Ranked_GetHistoricalLadderOnlyDivision
global function Ranked_GetNewDivisionForNewSeasonOrSplitReset
global function Ranked_PeriodHasLadderOnlyDivision
global function Ranked_UpdateEHIRankScore
global function Ranked_UpdateEHIRankedLadderPosition
global function Ranked_GetNumPlayersOnLadder
global function Ranked_UpdateEHIRankScorePrevSeason
global function Ranked_UpdateEHIRankedLadderPositionPrevSeason
global function Ranked_GetStryderLadderNameForLatestRankedPeriod
global function SharedRanked_CompareDivision
global function SharedRanked_GetEmblemDisplayModeFromEmblemText
global function SharedRanked_GetNumPlayerOnLaddersOverridePlaylistVar
global function Ranked_PlayerDeservesRewardsInPeriod
global function Ranked_GetXProgMergedPersistenceData

global function Ranked_GetCurrentActiveRankedPeriod
global function Ranked_GetAllRanked2Pt0Periods
global function Ranked_GetSeasonForRanked2Pt0Period
global function Ranked_GetAllRankedPeriodsInAscendingChronologicalOrder
global function Ranked_HasActiveLadderOnlyDivision
global function Ranked_GetActiveLadderOnlyDivisionData


global function Ranked_IsPlayerAbandoning
global function SharedRanked_DidPlayerEverHaveAFullTeam
global function SharedRanked_GetAbandonPenaltyLength



global function Ranked_GetHistoricalRankScoreAcrossSplitsForPlayer
global function Ranked_GetHistoricalRankedPersistenceData
global function Ranked_RankedPartyMaxTierDifferential
global function Ranked_ShowRankedSummary





































global function Ranked_IsRankedV2FirstSplit
global function Ranked_IsRankedV2SecondSplit
global function Ranked_IsDisablePointGain





global const int SHARED_RANKED_LEVEL_REQUIREMENT = (20 - 1) 

global const int SHARED_RANKED_NUM_ABANDON_FORGIVENESS_GAMES = 3
global const int RANKED_RESET_DIVISION_COUNT = 6 
global const int RANKED_RESET_DIVISION_FLOOR = 4  

global const int SHARED_RANKED_ROOKIE_FLOOR_VALUE = 1
global const int SHARED_RANKED_INVALID_RANK_SCORE = -1
global const int SHARED_RANKED_INVALID_LADDER_POSITION = -1
global const string SHARED_RANKED_SPLIT_1_STRYDER_SUFFIX = "_split_1"
global const string SHARED_RANKED_SPLIT_2_STRYDER_SUFFIX = "_split_2"


global const string RANKED_SEASON_02_GUIDSTRING = "SAID00747315762" 
global const string RANKED_SEASON_03_GUIDSTRING = "SAID00091805734" 
global const string RANKED_SEASON_04_GUIDSTRING = "SAID00609587000" 
global const string RANKED_SEASON_05_GUIDSTRING = "SAID00638209737" 
global const string RANKED_SEASON_10_GUIDSTRING = "SAID01091892544" 
global const string RANKED_SEASON_13_GUIDSTRING = "SAID02144147554" 
global const string RANKED_SEASON_15_GUIDSTRING = "SAID00102643758" 
global const string RANKED_SEASON_16_GUIDSTRING = "SAID02005235415" 

global const string RANKED_2PT0_PERIOD_17_GUIDSTRING = "SAID01711148254" 
global const string RANKED_2PT0_PERIOD_19_GUIDSTRING = "SAID01234567890" 

global const int RANKED_2PT0_NON_SPLIT = 0
global const int RANKED_2PT0_SPLIT1 = 1
global const int RANKED_2PT0_SPLIT2 = 2

global const int DEMOTION_BUFFER_MAX = 3

global const asset RANKED_PLACEMENT_BADGE = $"ui/ranked_badge_placement.rpak"
global const asset RANKED_PLACEMENT_ICON = $"ui_image/rui/menu/ranked/rank_emblem_placement.rpak"
global const asset RANKED_PLACEMENT_LEVEL_UP_BADGE = $"ui/rank_emblem_rank_up_anim_placement.rpak"

global const string RANKED_LAST_INITIALIZED_PERIOD_GUID_VAR_NAME = "lastInitializedRankedPeriodGUID"
global const string RANKED_CURRENT_SCORE_PERSISTENCE_VAR_NAME = "currentRankedScore"
global const string RANKED_PROVISIONAL_MATCH_COUNT_PERSISTENCE_VAR_NAME = "rankedProvisionalMatchesCompleted"
global const string RANKED_PROVISIONAL_MATCH_HAS_PROGRESSED_OUT_PERSISTENCE_VAR_NAME = "rankedHasProgressedOutOfProvisional"
global const string RANKED_PROVISIONAL_MATCH_CONVAR_KILL_SWITCH = "ranked_disable_placement_matches"

global const string RANKED_TOP_5_STREAK_PERSISTENCE_VAR_NAME = "rankedTop5StreakCount"
global const string RANKED_PROVISONAL_MATCH_RESULTS = "rankedProvisionalMatchScores"
global const string RANKED_PROVISONAL_MATCH_RESULTS_FORMAT_STRINGS = RANKED_PROVISONAL_MATCH_RESULTS + "[%s]"

global const string RANKED_SHOW_RANKED_SUMMARY_PERSISTENCE_VAR_NAME = "showRankedSummary"
const array< string > XPROG_MERGED_PLATFORM_PERSISTENCE_FIELDS = [
	RANKED_CURRENT_SCORE_PERSISTENCE_VAR_NAME,
	RANKED_PROVISIONAL_MATCH_COUNT_PERSISTENCE_VAR_NAME,
	RANKED_PROVISIONAL_MATCH_HAS_PROGRESSED_OUT_PERSISTENCE_VAR_NAME,
	RANKED_SHOW_RANKED_SUMMARY_PERSISTENCE_VAR_NAME,

	RANKED_TOP_5_STREAK_PERSISTENCE_VAR_NAME,
	RANKED_PROVISONAL_MATCH_RESULTS + "[0]",
	RANKED_PROVISONAL_MATCH_RESULTS + "[1]",
	RANKED_PROVISONAL_MATCH_RESULTS + "[2]",
	RANKED_PROVISONAL_MATCH_RESULTS + "[3]",
	RANKED_PROVISONAL_MATCH_RESULTS + "[4]",
	RANKED_PROVISONAL_MATCH_RESULTS + "[5]",
	RANKED_PROVISONAL_MATCH_RESULTS + "[6]",
	RANKED_PROVISONAL_MATCH_RESULTS + "[7]",
	RANKED_PROVISONAL_MATCH_RESULTS + "[8]",
	RANKED_PROVISONAL_MATCH_RESULTS + "[9]",

]

global const string XPROG_PERSISTENCE_RANKED_STRUCT_NAME = "xProgRanked"
global const string XPROG_PERSISTENCE_PREFIX_FORMAT_STRING = XPROG_PERSISTENCE_MERGED_PLAT_STRUCT_NAME + "[ %s ]." + XPROG_PERSISTENCE_RANKED_STRUCT_NAME + "." 
global const string XPROG_PERSISTENCE_FORMAT_STRING = XPROG_PERSISTENCE_PREFIX_FORMAT_STRING + "%s" 


global const string RANKED_IGNORE_MAX_TIER_DIFFERENTIAL_PLAYLIST_VAR = "ranked_ignore_party_rank_difference"
global const string RANKED_PARTY_IGNORE_MAX_TIER_DIFFERENTIAL_PLAYLIST_VAR = "ranked_ignore_full_party_rank_difference"

global const string RANKED_DEV_PLAYTEST_PLAYLIST_VAR = "ranked_dev_playtest"
const string RANKED_PARTY_MAX_TIER_DIFFERENTIAL_PLAYLIST_VAR = "ranked_party_max_tier_differential"
const int RANKED_PARTY_MAX_TIER_DIFFERENTIAL = 3
global const int MAX_TEAM_SIZE = 3

global const float RANKED_LEAVER_PENALTY_TIME_LIMIT_SEC = 60.0

const array<string> RANKED_2PT0_PERSISTENCE_FIELDS = [
	RANKED_CURRENT_SCORE_PERSISTENCE_VAR_NAME,
	"highestRankedScore",
	"endSeriesLadderPosition",
	"rewardSeq",
]

global enum emblemDisplayMode 
{
	DISPLAY_DIVISION,
	DISPLAY_RP,
	DISPLAY_LADDER_POSITION,
	NONE,
}













































global const array<string> DIVISION_ORDERING_BY_LOC_KEY =
[
	"#RANKED_DIVISION_ROOKIE_IV",
	"#RANKED_DIVISION_ROOKIE_III",
	"#RANKED_DIVISION_ROOKIE_II",
	"#RANKED_DIVISION_ROOKIE_I",
	"#RANKED_DIVISION_BRONZE_IV",
	"#RANKED_DIVISION_BRONZE_III",
	"#RANKED_DIVISION_BRONZE_II",
	"#RANKED_DIVISION_BRONZE_I",
	"#RANKED_DIVISION_SILVER_IV",
	"#RANKED_DIVISION_SILVER_III",
	"#RANKED_DIVISION_SILVER_II",
	"#RANKED_DIVISION_SILVER_I",
	"#RANKED_DIVISION_GOLD_IV",
	"#RANKED_DIVISION_GOLD_III",
	"#RANKED_DIVISION_GOLD_II",
	"#RANKED_DIVISION_GOLD_I",
	"#RANKED_DIVISION_PLATINUM_IV",
	"#RANKED_DIVISION_PLATINUM_III",
	"#RANKED_DIVISION_PLATINUM_II",
	"#RANKED_DIVISION_PLATINUM_I",
	"#RANKED_DIVISION_DIAMOND_IV",
	"#RANKED_DIVISION_DIAMOND_III",
	"#RANKED_DIVISION_DIAMOND_II",
	"#RANKED_DIVISION_DIAMOND_I",
	"#RANKED_DIVISION_MASTER",
	"#RANKED_DIVISION_APEX_PREDATOR"
]

global const array<string> TIER_ORDERING_BY_LOC_KEY =
[
	"#RANKED_TIER_ROOKIE",
	"#RANKED_TIER_BRONZE",
	"#RANKED_TIER_SILVER",
	"#RANKED_TIER_GOLD",
	"#RANKED_TIER_PLATINUM",
	"#RANKED_TIER_DIAMOND",
	"#RANKED_TIER_MASTER",
	"#RANKED_TIER_APEX_PREDATOR"
]


global struct SharedRankedReward
{
	string previewName
	bool   previewIconShowBox
	asset  previewIcon
	asset  previewImage
	asset  rewardAsset
}


global struct SharedRankedTierData
{
	string                    name
	int                       scoreMin
	int                       index
	asset                     icon
	asset                     iconRuiAsset
	asset                     bgImage
	asset					  glowImage
	asset                     levelUpRuiAsset
	asset					  promotionalMetallicImage
	int                       entryCost = 9999999
	int 					  maxProtection
	int 					  minProtection
	bool					  allowsDemotion = true
	bool					  isTopEnd = false
	int						  lpDecayAmount = 1000
	string                    promotionAnnouncement
	bool                      isLadderOnlyTier = false
	array<SharedRankedReward> rewards
	
}


global struct SharedRankedDivisionData
{
	string                divisionName
	string                emblemText
	SharedRankedTierData& tier
	int                   scoreMin
	int                   index
	int                   emblemDisplayMode = emblemDisplayMode.DISPLAY_DIVISION
	bool                  isLadderOnlyDivision = false
	int 				  divisionEntryCost
}


struct RankedResetStruct
{
	string previousDivisionName
	string currentDivisionName
}




























struct
{
	bool                                               initialized = false
	bool                                               itemRegistrationInitialized = false
	array<SharedRankedTierData>                        rankedTiers
	array<SharedRankedDivisionData>                    rankedDivisions
	SharedRankedDivisionData ornull                    ladderOnlyDivision = null
	int                                                numPlayersOnLadder = 0
	table<string, int >                          	   historicalNumPlayersOnLadder
	table<string, SharedRankedDivisionData >           historicalLadderOnlyDivision
	table< string, array < SharedRankedTierData > >    historicalRankedTiers
	table< string, array< SharedRankedDivisionData > > historicalRankedDivisions





	SharedRankedDivisionData& topRankedDivisionData

	table<string, string > stryderLadderNameToPeriodGUIDStringTable









	array<ItemFlavor> allRanked2Pt0Periods
} file

void function Sh_Ranked_Init()
{
	

	if ( !file.initialized ) 
	{
		
		Sh_RankedScoring_Init()





		RegisterSignal( "Ranked_NotifyRankedPeriodScoreChanged" )
		file.initialized = true
	}


		Sh_RankedTrials_Init() 












		Remote_RegisterServerFunction( "ClientCallback_rankedPeriodRewardAcknowledged" )

		Remote_RegisterUIFunction( "ServerToUI_Ranked_NotifyRankedPeriodScoreChanged" ) 

		Remote_RegisterClientFunction ( "ServerToClient_Ranked_UpdatePlayerPrevRankedScore" , "entity", "int", -1, INT_MAX )
		Remote_RegisterClientFunction ( "ServerToClient_Ranked_UpdatePlayerPrevLadderPos" , "entity", "int", -1, INT_MAX )

		if ( !GameModeVariant_IsActive( eGameModeVariants.SURVIVAL_RANKED ) )
			return












}


void function Sh_Ranked_ItemRegistrationInit()
{




	AddCallback_RegisterRootItemFlavors( RegisterRanked2Pt0Periods )
	AddCallback_OnPreAllItemFlavorsRegistered( RankedTrials_RegisterAllRankedTrials )

	
	if ( !file.itemRegistrationInitialized ) 
	{




		AddCallback_OnItemFlavorRegistered( eItemType.calevent_rankedperiod, OnRankedPeriodRegistered )
		AddCallback_OnItemFlavorRegistered( eItemType.ranked_2pt0_period, OnRankedPeriodRegistered )
		AddCallbackOrMaybeCallNow_OnAllItemFlavorsRegistered( Ranked_AllItemFlavorsRegistered )
		file.itemRegistrationInitialized = true
	}
}

void function RegisterRanked2Pt0Periods()
{



	foreach ( asset rp2pt0 in GetBaseItemFlavorsFromArray( "ranked2Pt0Periods" ) )
	{
		if ( rp2pt0 == $"" )
			continue

		ItemFlavor ornull rp2Pt0Flavor = RegisterItemFlavorFromSettingsAsset( rp2pt0 )
		if ( rp2Pt0Flavor == null )
			printt( "Failed to register ItemFlavor from Settings Asset ", rp2pt0 )
		else
			file.allRanked2Pt0Periods.append( expect ItemFlavor( rp2Pt0Flavor ) )
	}
}


void function OnRankedPeriodRegistered( ItemFlavor rp )
{
	array< SharedRankedTierData > tierData
	array< SharedRankedDivisionData  > divisionData

	foreach ( var tierBlock in IterateSettingsAssetArray( ItemFlavor_GetAsset( rp ), "tiers" ) )
	{
		SharedRankedTierData tier
		tier.name                  = GetSettingsBlockString( tierBlock, "name" )
		tier.entryCost             = GetSettingsBlockInt( tierBlock, "entryCost" )
		tier.maxProtection         = GetSettingsBlockInt( tierBlock, "maxProtection" )
		tier.minProtection         = GetSettingsBlockInt( tierBlock, "minProtection" )
		tier.allowsDemotion        = GetSettingsBlockBool( tierBlock, "allowsDemotion" )
		tier.icon                  = GetSettingsBlockAsset( tierBlock, "icon" )
		tier.bgImage               = GetSettingsBlockAsset( tierBlock, "bgImage" )
		if ( ItemFlavor_GetType( rp ) == eItemType.ranked_2pt0_period )
		{
			tier.glowImage			   = GetSettingsBlockAsset( tierBlock, "glowImage" )
			tier.isTopEnd			   = GetSettingsBlockBool( tierBlock, "isTopEnd" )
			tier.promotionalMetallicImage = GetSettingsBlockAsset( tierBlock, "promotionalMetallicImage" )
		}
		tier.levelUpRuiAsset       = GetSettingsBlockStringAsAsset( tierBlock, "levelUpRuiAsset" )
		tier.iconRuiAsset          = GetSettingsBlockStringAsAsset( tierBlock, "iconRuiAsset" )
		tier.promotionAnnouncement = string( GetSettingsBlockStringAsAsset( tierBlock, "promotionAnnouncement" ) )

		tier.scoreMin = 99999999
		foreach ( var divBlock in IterateSettingsArray( GetSettingsBlockArray( tierBlock, "divisions" ) ) )
		{
			SharedRankedDivisionData data
			data.divisionName      = GetSettingsBlockString( divBlock, "name" )
			data.emblemText        = GetSettingsBlockString( divBlock, "emblemText" )
			data.scoreMin          = GetSettingsBlockInt( divBlock, "scoreMin" )
			data.divisionEntryCost = GetSettingsBlockInt ( divBlock, "divisionEntryCost")
			data.emblemDisplayMode = SharedRanked_GetEmblemDisplayModeFromEmblemText( data.emblemText )
			data.tier              = tier


			if ( data.scoreMin < tier.scoreMin )
				tier.scoreMin = data.scoreMin

			divisionData.append( data )
		}

		foreach ( var rewardBlock in IterateSettingsArray( GetSettingsBlockArray( tierBlock, "rewards" ) ) )
		{
			SharedRankedReward data
			data.previewName        = GetSettingsBlockString( rewardBlock, "previewName" )
			data.previewIcon        = GetSettingsBlockAsset( rewardBlock, "previewIcon" )
			data.previewIconShowBox = GetSettingsBlockBool( rewardBlock, "previewIconShowBox" )
			data.previewImage       = GetSettingsBlockAsset( rewardBlock, "previewImage" )
			data.rewardAsset        = GetSettingsBlockAsset( rewardBlock, "flavor" )

			tier.rewards.append( data )
		}

		tier.index = tierData.len()

		tierData.append( tier )
		Assert ( TIER_ORDERING_BY_LOC_KEY.contains(tier.name) , "Tier Name : " + tier.name + " is not found in TIER_ORDERING_BY_LOC_KEY." )
	}

	
	for ( int i = 0; i < tierData.len(); i++ )
	{
		tierData[i].isTopEnd = GetPlaylistVarBool( "defaults", "ranked_tier_isTopEnd_" + i, tierData[i].isTopEnd )
	}

	divisionData.sort( SharedRanked_CompareDivision )
	for ( int i = 0; i < divisionData.len(); i++ )
	{
		SharedRankedDivisionData data = divisionData[i]
		data.index = i

		Assert ( DIVISION_ORDERING_BY_LOC_KEY.contains(divisionData[i].divisionName) , "Divionsion name: " + divisionData[i].divisionName + " is not found in DIVISION_ORDERING_BY_LOC_KEY.")		
		divisionData[i].divisionEntryCost = GetCurrentPlaylistVarInt ( "ranked_division_entry_cost_" + i , divisionData[i].divisionEntryCost )
	}

	int ladderOnlyTiers = 0

	foreach ( var tierBlock in IterateSettingsAssetArray( ItemFlavor_GetAsset( rp ), "ladderOnlyTier" ) ) 
	{
		Assert( ladderOnlyTiers == 0 ) 
		++ladderOnlyTiers

		SharedRankedTierData ladderOnlyTier
		ladderOnlyTier.name                  = GetSettingsBlockString( tierBlock, "name" )
		ladderOnlyTier.entryCost             = GetSettingsBlockInt( tierBlock, "entryCost" )
		ladderOnlyTier.icon                  = GetSettingsBlockAsset( tierBlock, "icon" )
		ladderOnlyTier.bgImage               = GetSettingsBlockAsset( tierBlock, "bgImage" )
		if ( ItemFlavor_GetType( rp ) == eItemType.ranked_2pt0_period )
		{
			ladderOnlyTier.isTopEnd				 = GetSettingsBlockBool( tierBlock, "isTopEnd" )
			ladderOnlyTier.glowImage			 = GetSettingsBlockAsset( tierBlock, "glowImage" )
			ladderOnlyTier.promotionalMetallicImage = GetSettingsBlockAsset( tierBlock, "promotionalMetallicImage" )
		}
		ladderOnlyTier.levelUpRuiAsset       = GetSettingsBlockStringAsAsset( tierBlock, "levelUpRuiAsset" )
		ladderOnlyTier.iconRuiAsset          = GetSettingsBlockStringAsAsset( tierBlock, "iconRuiAsset" )
		ladderOnlyTier.promotionAnnouncement = string( GetSettingsBlockStringAsAsset( tierBlock, "promotionAnnouncement" ) )
		ladderOnlyTier.isLadderOnlyTier      = true
		ladderOnlyTier.index                 = tierData.len()

		int ladderOnlyDivisions = 0

		string rpGUIDString = ItemFlavor_GetGUIDString( rp )

		foreach ( var divBlock in IterateSettingsArray( GetSettingsBlockArray( tierBlock, "divisions" ) ) )
		{
			Assert( ladderOnlyDivisions == 0 ) 
			++ladderOnlyDivisions

			SharedRankedDivisionData data
			data.divisionName         = GetSettingsBlockString( divBlock, "name" )
			data.emblemText           = GetSettingsBlockString( divBlock, "emblemText" )
			data.scoreMin             = GetSettingsBlockInt( divBlock, "scoreMin" )
			data.divisionEntryCost    = GetSettingsBlockInt( divBlock, "divisionEntryCost" )
			data.emblemDisplayMode    = SharedRanked_GetEmblemDisplayModeFromEmblemText( data.emblemText )
			Assert( data.emblemDisplayMode == emblemDisplayMode.DISPLAY_LADDER_POSITION )
			data.tier                 = ladderOnlyTier
			data.isLadderOnlyDivision = true
			data.index                = divisionData.len()
			ladderOnlyTier.scoreMin   = data.scoreMin


			file.historicalNumPlayersOnLadder[ rpGUIDString ]  <- GetSettingsBlockInt( divBlock, "numPlayersOnLadder" )
			file.historicalLadderOnlyDivision[ rpGUIDString  ] <- data
		}

		Assert( ladderOnlyDivisions == 1 ) 

		foreach ( var rewardBlock in IterateSettingsArray( GetSettingsBlockArray( tierBlock, "rewards" ) ) )
		{
			SharedRankedReward data
			data.previewName        = GetSettingsBlockString( rewardBlock, "previewName" )
			data.previewIcon        = GetSettingsBlockAsset( rewardBlock, "previewIcon" )
			data.previewIconShowBox = GetSettingsBlockBool( rewardBlock, "previewIconShowBox" )
			data.previewImage       = GetSettingsBlockAsset( rewardBlock, "previewImage" )
			data.rewardAsset        = GetSettingsBlockAsset( rewardBlock, "flavor" )

			ladderOnlyTier.rewards.append( data )
		}
	}

	string rankedPeriodGUID = ItemFlavor_GetGUIDString( rp )
	file.historicalRankedTiers[ rankedPeriodGUID ] <- tierData
	file.historicalRankedDivisions[ rankedPeriodGUID ] <- divisionData

	if ( SharedRankedPeriod_HasSplits( rp ) )
	{
		string stryderFirstSplitLadderName = Ranked_GetStryderLadderNameForHistoricalRankedPeriod( rp, true )
		file.stryderLadderNameToPeriodGUIDStringTable[ stryderFirstSplitLadderName ] <- rankedPeriodGUID
		string stryderSecondSplitLadderName = Ranked_GetStryderLadderNameForHistoricalRankedPeriod( rp, false )
		file.stryderLadderNameToPeriodGUIDStringTable[ stryderSecondSplitLadderName ] <- rankedPeriodGUID
	}
	else
	{
		string stryderLadderName = Ranked_GetStryderLadderNameForHistoricalRankedPeriod( rp, false )
		file.stryderLadderNameToPeriodGUIDStringTable[ stryderLadderName ] <- rankedPeriodGUID
	}
}

ItemFlavor ornull function Ranked_GetCurrentActiveRankedPeriod()
{
	string currentPeriodGUIDString = Ranked_GetCurrentPeriodGUIDString()
	int currentPeriodGUID = ConvertItemFlavorGUIDStringToGUID( currentPeriodGUIDString )
	if ( IsValidItemFlavorGUID( currentPeriodGUID ) )
		return GetItemFlavorByGUID( currentPeriodGUID )

	return null
}


array<ItemFlavor> function Ranked_GetAllRankedPeriodsInAscendingChronologicalOrder()
{
	array<ItemFlavor> rankedPeriodList = clone( GetAllRankedPeriodCalEventFlavorsByType( eItemType.calevent_rankedperiod ) )
	array<ItemFlavor> ranked2Pt0PeriodList = clone( Ranked_GetAllRanked2Pt0Periods() )
	rankedPeriodList.extend( ranked2Pt0PeriodList )























	return rankedPeriodList
}


array<ItemFlavor> function Ranked_GetAllRanked2Pt0Periods()
{
	return file.allRanked2Pt0Periods
}

ItemFlavor function Ranked_GetSeasonForRanked2Pt0Period( ItemFlavor period )
{
	asset parentAsset = GetGlobalSettingsAsset( ItemFlavor_GetAsset( period ), "parentItemFlavor" )
	Assert( IsValidItemFlavorSettingsAsset( parentAsset ) )
	return GetItemFlavorByAsset( parentAsset )
}

int function SharedRanked_GetEmblemDisplayModeFromEmblemText( string emblemText )
{
	switch( emblemText )
	{
		case "#RANKED_DIVISION_I":
		case "#RANKED_DIVISION_II":
		case "#RANKED_DIVISION_III":
		case "#RANKED_DIVISION_IV":
		{
			return emblemDisplayMode.DISPLAY_DIVISION
		}

		case "SHOW_RP":
		{
			return emblemDisplayMode.DISPLAY_RP
		}

		case "LADDER_POSITION":
		{
			return emblemDisplayMode.DISPLAY_LADDER_POSITION
		}

		default:
		{
			return emblemDisplayMode.NONE
		}
	}

	unreachable
}


void function Ranked_AllItemFlavorsRegistered()
{
	Assert( IsValidItemFlavorGUID( ConvertItemFlavorGUIDStringToGUID( Ranked_GetCurrentPeriodGUIDString() ) ) )
	string latestRankedPeriodGUID = Ranked_GetCurrentPeriodGUIDString()
	file.rankedTiers     = file.historicalRankedTiers[ latestRankedPeriodGUID ]
	file.rankedDivisions = file.historicalRankedDivisions[ latestRankedPeriodGUID ]

	if ( latestRankedPeriodGUID in file.historicalLadderOnlyDivision )
	{
		file.ladderOnlyDivision    = file.historicalLadderOnlyDivision[ latestRankedPeriodGUID  ]
		file.topRankedDivisionData = file.historicalLadderOnlyDivision[ latestRankedPeriodGUID  ]
		file.numPlayersOnLadder    = file.historicalNumPlayersOnLadder[ latestRankedPeriodGUID ]
	}
	else
	{
		file.topRankedDivisionData = file.rankedDivisions.top()
	}
}


int function Ranked_GetNumPlayersOnLadder()
{
	Assert( Ranked_GetCurrentActiveRankedPeriod() != null )
	ItemFlavor latestRankedPeriod = expect ItemFlavor( Ranked_GetCurrentActiveRankedPeriod() )
	string playlistOverrideVar    = SharedRanked_GetNumPlayerOnLaddersOverridePlaylistVar( latestRankedPeriod )
	return GetCurrentPlaylistVarInt( playlistOverrideVar, file.numPlayersOnLadder )
}


string function SharedRanked_GetNumPlayerOnLaddersOverridePlaylistVar( ItemFlavor rankedPeriod )
{
	if ( ItemFlavor_GetType( rankedPeriod ) == eItemType.ranked_2pt0_period )
		return ItemFlavor_GetGUIDString( rankedPeriod ) + "_num_players_on_ladder"

	return ItemFlavor_GetCalEventRef( rankedPeriod ) + "_num_players_on_ladder"
}


SharedRankedTierData function Ranked_GetHighestHistoricalTierAcrossSplitsForPlayer( entity player, ItemFlavor rankedPeriod, bool highScore )
{
	Assert( SharedRankedPeriod_HasSplits( rankedPeriod ) )
	Assert( Ranked_GetCurrentActiveRankedPeriod() != rankedPeriod )

	string rankedPeriodGUID = ItemFlavor_GetGUIDString( rankedPeriod )

	int firstSplitRankedScore                 = SharedRankedPeriod_HasSplits( rankedPeriod ) ? Ranked_GetHistoricalFirstSplitRankScore( player, rankedPeriodGUID, highScore ) : 0
	int firstSplitLadderPosition              = SharedRankedPeriod_HasSplits( rankedPeriod ) ? Ranked_GetHistoricalLadderPosition( player, rankedPeriodGUID, true ) : SHARED_RANKED_INVALID_LADDER_POSITION
	SharedRankedTierData firstSplitRankedTier = Ranked_GetHistoricalRankedDivisionFromScoreAndLadderPosition( firstSplitRankedScore, firstSplitLadderPosition, rankedPeriodGUID ).tier

	int secondSplitRankedScore                 = Ranked_GetHistoricalRankScore ( player, rankedPeriodGUID, highScore )
	int secondSplitLadderPosition              = Ranked_GetHistoricalLadderPosition( player, rankedPeriodGUID, false )
	SharedRankedTierData secondSplitRankedTier = Ranked_GetHistoricalRankedDivisionFromScoreAndLadderPosition( secondSplitRankedScore, secondSplitLadderPosition, rankedPeriodGUID ).tier

	SharedRankedTierData highestTierAchieved = Ranked_GetHigherOfTwoTiers( firstSplitRankedTier, secondSplitRankedTier )

	return highestTierAchieved
}


int function Ranked_GetHistoricalRankScoreAcrossSplitsForPlayer( entity player, ItemFlavor rankedPeriod )
{
	Assert( SharedRankedPeriod_HasSplits( rankedPeriod ) )
	Assert( Ranked_GetCurrentActiveRankedPeriod() != rankedPeriod )

	string rankedPeriodGUID = ItemFlavor_GetGUIDString( rankedPeriod )

	int firstSplitRankedScore    = SharedRankedPeriod_HasSplits( rankedPeriod ) ? Ranked_GetHistoricalFirstSplitRankScore( player, rankedPeriodGUID, true ) : 0
	int secondSplitRankedScore   = Ranked_GetHistoricalRankScore ( player, rankedPeriodGUID, true )

	return maxint ( firstSplitRankedScore , secondSplitRankedScore )
}


bool function Ranked_PlayedGamesInPeriod( entity player, string rankedPeriodGUID )
{
	if ( !GetCurrentPlaylistVarBool( "ranked_end_series_stryder_check", true ) )
		return false

	int numberOfRankedGames = GetStat_Int( player, ResolveStatEntry( CAREER_STATS.rankedperiod_games_played, rankedPeriodGUID ) )
	if ( numberOfRankedGames == 0 )
		return false

	return true
}


SharedRankedTierData function Ranked_GetHigherOfTwoTiers( SharedRankedTierData firstTier, SharedRankedTierData secondTier )
{
	

	SharedRankedTierData highestTierAchieved = firstTier.index > secondTier.index ? firstTier : secondTier
	return highestTierAchieved
}




















string function Ranked_GetStryderLadderNameForLatestRankedPeriod()
{
	Assert( Ranked_GetCurrentActiveRankedPeriod() != null )
	ItemFlavor latestPeriod = expect ItemFlavor( Ranked_GetCurrentActiveRankedPeriod() )
	bool isFirstSplit = SharedRankedPeriod_IsFirstSplitActive( latestPeriod )

	return Ranked_GetStryderLadderNameForHistoricalRankedPeriod( latestPeriod, isFirstSplit )
}


string function Ranked_GetStryderLadderNameForHistoricalRankedPeriod( ItemFlavor rankedPeriod, bool isFirstSplit )
{
	Assert( ItemFlavor_GetType( rankedPeriod ) == eItemType.ranked_2pt0_period || ItemFlavor_GetType( rankedPeriod ) == eItemType.calevent_rankedperiod )

	if ( ItemFlavor_GetType( rankedPeriod ) == eItemType.ranked_2pt0_period )
		return ItemFlavor_GetGUIDString( rankedPeriod )

	
	string baseLadderName

	string periodGUIDString = ItemFlavor_GetGUIDString( rankedPeriod )

	switch( periodGUIDString )
	{
		case RANKED_SEASON_02_GUIDSTRING:
			baseLadderName = "calevent_rankedperiod01"
			break

		case RANKED_SEASON_03_GUIDSTRING:
			baseLadderName = "calevent_rankedperiod02"
			break

		case RANKED_SEASON_04_GUIDSTRING:
			baseLadderName = "calevent_rankedperiod03"
			break

		case RANKED_SEASON_05_GUIDSTRING:
			baseLadderName = "calevent_rankedperiod04"
			break

		default:
			baseLadderName = ItemFlavor_GetCalEventRef( rankedPeriod )
			break
	}

	if ( !SharedRankedPeriod_HasSplits( rankedPeriod ) )
		return baseLadderName

	if ( isFirstSplit )
		return baseLadderName + SHARED_RANKED_SPLIT_1_STRYDER_SUFFIX
	else
		return baseLadderName + SHARED_RANKED_SPLIT_2_STRYDER_SUFFIX

	unreachable

}


string function Ranked_GetSeasonGUIDStringFromStryderLadderName( string stryderLadderName )
{
	return file.stryderLadderNameToPeriodGUIDStringTable[ stryderLadderName ]
}


bool function Ranked_IsValidHistoricalRankedPeriodGUID( string rankedPeriodGUID )
{
	return ( rankedPeriodGUID in file.historicalRankedDivisions )
}


bool function Ranked_PeriodHasLadderOnlyDivision( string rankedPeriodGUIDString )
{
	return rankedPeriodGUIDString in file.historicalLadderOnlyDivision
}


SharedRankedDivisionData function Ranked_GetHistoricalLadderOnlyDivision( string rankedPeriodGUIDString )
{
	Assert( rankedPeriodGUIDString in file.historicalLadderOnlyDivision )
	return file.historicalLadderOnlyDivision[ rankedPeriodGUIDString  ]
}


int function Ranked_GetHistoricalNumPlayersOnLadder( string rankedPeriodGUIDString )
{
	Assert( rankedPeriodGUIDString in file.historicalNumPlayersOnLadder )
	ItemFlavor historicalRankedPeriod = GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( rankedPeriodGUIDString ) )
	string playlistOverrideVar        = SharedRanked_GetNumPlayerOnLaddersOverridePlaylistVar( historicalRankedPeriod )
	return  GetCurrentPlaylistVarInt( playlistOverrideVar, file.historicalNumPlayersOnLadder[ rankedPeriodGUIDString ] )
}


int function SharedRanked_CompareDivision( SharedRankedDivisionData a, SharedRankedDivisionData b )
{
	if ( a == b )
		return 0

	
	if ( a.scoreMin != b.scoreMin )
		return a.scoreMin - b.scoreMin

	Assert( false, "Cannot have ranks with the same scoreMin " + a.divisionName + " " + b.divisionName )

	unreachable
}


bool function Ranked_HasActiveLadderOnlyDivision()
{
	return file.ladderOnlyDivision != null
}


SharedRankedDivisionData function Ranked_GetActiveLadderOnlyDivisionData()
{
	Assert( file.ladderOnlyDivision != null )
	return (expect SharedRankedDivisionData( file.ladderOnlyDivision ))
}


SharedRankedDivisionData function GetCurrentRankedDivisionFromScoreAndLadderPosition( int score, int ladderPosition )
{
	int numPlayersOnLadder = Ranked_GetNumPlayersOnLadder()
	if ( (ladderPosition != SHARED_RANKED_INVALID_LADDER_POSITION) && (ladderPosition > 0) && (numPlayersOnLadder > 0) && (ladderPosition <= numPlayersOnLadder) )
	{
		SharedRankedDivisionData ladderDivisionData = expect SharedRankedDivisionData ( file.ladderOnlyDivision )

		if ( ladderDivisionData.scoreMin > score ) 
			return GetCurrentRankedDivisionFromScore( score )
		else
			return (ladderDivisionData)
	}

	return GetCurrentRankedDivisionFromScore( score )
}

array<SharedRankedDivisionData> function GetCurrentRankedDivisions()
{
	return file.rankedDivisions
}


SharedRankedDivisionData function GetCurrentRankedDivisionFromScore( int score )
{
	if ( score <= 0 )
	{
		Assert( file.rankedDivisions.len() > 0 )
		
		Assert( file.rankedDivisions[ 0 ].scoreMin == 1 || file.rankedDivisions[ 0 ].scoreMin == 0  )
		return file.rankedDivisions[ 0 ]
	}

	bool foundRank = false
	SharedRankedDivisionData data

	for ( int i = 0; i < file.rankedDivisions.len(); i++ )
	{
		if ( file.rankedDivisions[i].scoreMin > score )
			break

		foundRank = true

		data = file.rankedDivisions[ i ]
	}

	Assert( foundRank )
	return data
}


SharedRankedDivisionData ornull function GetNextRankedDivisionFromScore( int score )
{
	if ( score <= 0 )
		score = 1 

	bool foundRank = false
	SharedRankedDivisionData data

	int i = 0
	for ( ; i < file.rankedDivisions.len(); i++ )
	{
		if ( file.rankedDivisions[i].scoreMin > score )
			break

		foundRank = true

		data = file.rankedDivisions[ i ]
	}

	if ( i >= file.rankedDivisions.len() )
	{
		return null
	}

	data = file.rankedDivisions[ i ]

	if ( data.isLadderOnlyDivision )
		return null

	Assert( foundRank )


	return data
}


	int function Ranked_GetCostForEntry ( SharedRankedDivisionData currentRank )
	{
		return GetCurrentPlaylistVarInt ( "Ranked_EnryCost_Override_" + currentRank.index , abs ( currentRank.divisionEntryCost ))
	}







int function Ranked_GetHistoricalRankScore( entity player, string rankedSeasonGUID, bool highScore = false )
{
	
	






	if ( !IsConnected() )
		return 0



		Assert ( player == GetLocalClientPlayer() )






	int score
	if ( highScore )
	{
		score = expect int ( Ranked_GetHistoricalRankedPersistenceData( player, "highestRankedScore", rankedSeasonGUID ) )
	}
	else
	{
			score = expect int ( Ranked_GetHistoricalRankedPersistenceData( player, RANKED_CURRENT_SCORE_PERSISTENCE_VAR_NAME, rankedSeasonGUID ) )
	}

	return score
}


int function Ranked_GetHistoricalFirstSplitRankScore( entity player, string rankedSeasonGUID, bool highScore = false )
{
	Assert( SharedRankedPeriod_HasSplits( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( rankedSeasonGUID ) ) ) )
	if ( !SharedRankedPeriod_HasSplits( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( rankedSeasonGUID ) ) ) )
		return 0

	






	if ( !IsConnected() )
		return 0



		Assert ( player == GetLocalClientPlayer() )






	int score
	if ( highScore )
	{
		score = expect int ( Ranked_GetHistoricalRankedPersistenceData( player, "firstSplitHighScore", rankedSeasonGUID ) )
	}
	else
	{
		score = expect int ( Ranked_GetHistoricalRankedPersistenceData( player, "firstSplitRankedScore", rankedSeasonGUID ) )
	}

	return score
}


SharedRankedDivisionData function Ranked_GetHistoricalRankedDivisionFromScore( int rankScore, string rankedSeasonGUID )
{
	Assert( rankedSeasonGUID in file.historicalRankedDivisions )

	array< SharedRankedDivisionData > historicalRankedDivisionData = file.historicalRankedDivisions[ rankedSeasonGUID  ]

	if ( rankScore <= 0 )
	{
		Assert( historicalRankedDivisionData.len() > 0 )
			
		Assert( historicalRankedDivisionData[ 0 ].scoreMin == 1 || historicalRankedDivisionData[ 0 ].scoreMin == 0  )
		return historicalRankedDivisionData[ 0 ]
	}

	bool foundRank = false
	SharedRankedDivisionData data

	for ( int i = 0; i < historicalRankedDivisionData.len(); i++ )
	{
		if ( historicalRankedDivisionData[i].scoreMin > rankScore )
			break

		foundRank = true

		data = historicalRankedDivisionData[ i ]
	}

	Assert( foundRank )
	return data
}


SharedRankedTierData function Ranked_GetHighestHistoricalRankedTierData( entity player )
{
	SharedRankedTierData highestTier
	int highestRankScore = 0
	int highestLadderPos = 0

	array< ItemFlavor > rankedPeriods = GetAllRankedPeriodCalEventFlavorsByType( eItemType.calevent_rankedperiod )

	Assert ( rankedPeriods.len() > 0, "No Rank Period Flavor is found"  )

	for  ( int i = 0 ; i < rankedPeriods.len(); i++)
	{
		ItemFlavor period = rankedPeriods[i]
		string periodGUID       				= ItemFlavor_GetGUIDString( period )
		int endRankScore        				= Ranked_GetHistoricalRankScore( player, periodGUID )
		int firstSplitRankScore				 	= SharedRankedPeriod_HasSplits( period ) ? Ranked_GetHistoricalFirstSplitRankScore( player, periodGUID ) : 0
		int bestRankScore       				= firstSplitRankScore > endRankScore ? firstSplitRankScore : endRankScore
		SharedRankedTierData thisTier			= Ranked_GetHistoricalRankedDivisionFromScore (bestRankScore, periodGUID).tier

		if ( i == 0 ) 
		{
			highestTier = thisTier
		}

		if ( DIVISION_ORDERING_BY_LOC_KEY.find( highestTier.name ) < DIVISION_ORDERING_BY_LOC_KEY.find( thisTier.name ) )
		{
			highestTier = thisTier
		}

	}
	return highestTier
}


int function Ranked_RankedPartyMaxTierDifferential()
{
	return GetCurrentPlaylistVarInt( RANKED_PARTY_MAX_TIER_DIFFERENTIAL_PLAYLIST_VAR, RANKED_PARTY_MAX_TIER_DIFFERENTIAL )
}


bool function Ranked_ShowRankedSummary()
{




	bool rpGainDisabled = false

		rpGainDisabled = RankedRumble_IsLatestGameRankedRumble( GetLocalClientPlayer() )

	return !rpGainDisabled && Ranked_GetXProgMergedPersistenceData( GetLocalClientPlayer(), RANKED_SHOW_RANKED_SUMMARY_PERSISTENCE_VAR_NAME ) != 0
}


SharedRankedDivisionData function Ranked_GetHistoricalRankedDivisionFromScoreAndLadderPosition( int rankScore, int ladderPosition, string rankedSeasonGUID )
{
	if ( Ranked_PeriodHasLadderOnlyDivision( rankedSeasonGUID ) )
	{
		int historicalNumPlayersOnLadder = Ranked_GetHistoricalNumPlayersOnLadder( rankedSeasonGUID )
		if ( ladderPosition != SHARED_RANKED_INVALID_LADDER_POSITION && ladderPosition > 0 && ladderPosition <= historicalNumPlayersOnLadder ) 
			return Ranked_GetHistoricalLadderOnlyDivision( rankedSeasonGUID )
	}

	return Ranked_GetHistoricalRankedDivisionFromScore( rankScore, rankedSeasonGUID )

	unreachable
}

array<SharedRankedTierData> function Ranked_GetHistoricalRankedTiers( string rankedSeasonGUID )
{
	return file.historicalRankedTiers[rankedSeasonGUID]
}

int function Ranked_GetHistoricalLadderPosition( entity player, string rankedSeasonGUID, bool forFirstSplit = false )
{
	Assert( rankedSeasonGUID in file.historicalRankedDivisions )
	ItemFlavor historicalRankedPeriod = GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( rankedSeasonGUID ) )

	if ( !SharedRankedPeriod_HasSplits( historicalRankedPeriod ) || !forFirstSplit )
		return expect int ( Ranked_GetHistoricalRankedPersistenceData( player, "endSeriesLadderPosition", rankedSeasonGUID ) )

	if ( SharedRankedPeriod_HasSplits( historicalRankedPeriod ) && forFirstSplit )
		return expect int ( Ranked_GetHistoricalRankedPersistenceData( player, "endFirstSplitLadderPosition", rankedSeasonGUID ) )

	unreachable
}

bool function Ranked_PlayerDeservesRewardsInPeriod(entity player, string rankedPeriodGUID )
{
	
	return Ranked_GetHistoricalRankedPersistenceData( player, "rewardSeq", rankedPeriodGUID ) != GRX_INVALID_SEQUENCE_NUMBER
}


var function Ranked_GetHistoricalRankedPersistenceData( entity player, string persistenceField, string rankedSeasonGUID )
{
#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return null
#endif

	Assert( rankedSeasonGUID in file.historicalRankedTiers )
	if ( ItemFlavor_GetType( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( rankedSeasonGUID ) ) ) == eItemType.ranked_2pt0_period )
	{
		Assert( RANKED_2PT0_PERSISTENCE_FIELDS.contains( persistenceField ) )
		if ( !(RANKED_2PT0_PERSISTENCE_FIELDS.contains( persistenceField )) )
			return null



			return player.GetPersistentVar( "rankedPeriodData[" + rankedSeasonGUID + "]." + persistenceField )

	}
	else
	{



			return player.GetPersistentVar( "allRankedData[" + rankedSeasonGUID + "]." + persistenceField )

	}

	unreachable
}


int function GetPrevSeasonPeakPlayerRankScore( entity player )
{






	if ( !IsConnected() )
		return 0



































		Assert( !IsLobby() )
		EHI playerEHI = ToEHI( player )
		return GetEHIScriptStruct( playerEHI ).rankScorePrevSeason











































	unreachable
}


int function GetPlayerRankScore( entity player )
{






	if ( !IsConnected() )
		return 0









































		Assert( !IsLobby() )
		EHI playerEHI = ToEHI( player )
		return GetEHIScriptStruct( playerEHI ).rankScore




































	unreachable
}






























bool function Ranked_IsPlayerAbandoning( entity player )

{
	if ( !GameModeVariant_IsActive( eGameModeVariants.SURVIVAL_RANKED ) )
		return false

	if ( !GetCurrentPlaylistVarBool( "ranked_match_abandon_penalty", true ) )
		return false

	if ( bool( GetRankedGameData( player, "lastGameRankedForgiveness" ) ) )
		return false

	
	
	

	if ( Ranked_IsMatchOverForPlayer( player ) )
		return false

	if ( Ranked_IsDeadAndCanExitWithoutPenalty( player ) )
		return false

	if ( GetGameState() >= eGameState.Prematch && !SharedRanked_DidPlayerEverHaveAFullTeam( player ) ) 
		return false

	return true
}




bool function SharedRanked_DidPlayerEverHaveAFullTeam( entity player )

{
	return player.GetPlayerNetBool( "rankedDidPlayerEverHaveAFullTeam" )
}





int function SharedRanked_GetAbandonPenaltyLength( entity player )
{
	if( !IsValid( player ) )
		return 0

	int numGamesAbandoned = expect int ( player.GetPersistentVar( "numPenalizedAbandons" ) ) + 1
	if ( numGamesAbandoned == 0 )
		return 0

	int banLengthInSeconds = 0

	if ( GetCurrentPlaylistVarBool( "ranked_abandon_stacking_penalties", false ) )
	{
		switch( numGamesAbandoned )
		{
			case 1:
				banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_1", 60 * 5 ) 
				break

			case 2:
				banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_2", 60 * 10 ) 
				break

			case 3:
				banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_3", 60 * 20 )  
				break

			case 4:
				banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_4", 60 * 45 ) 
				break

			case 5:
				banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_5", 60 * 90 ) 
				break

			case 6:
				banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_6", 60 * 180 ) 
				break

			case 7:
				banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_7", 60 * 360 ) 
				break

			case 8:
				banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_8", 60 * 720 ) 
				break

			case 9:
				banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_9", 60 * 1440 ) 
				break

			case 10:
				banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_10", 60 * 1440 * 3 ) 
				break

			case 11:
				banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_11", 60 * 1440 * 5 )  
				break

			case 12:
			default:
				banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_12", 60 * 1440 * 7 ) 
				break
		}
	}
	else
	{
		banLengthInSeconds = GetCurrentPlaylistVarInt( "ranked_abandon_penalty_1", 60 * 10 ) 
	}

	return banLengthInSeconds
}












bool function Ranked_IsMatchOverForPlayer( entity player )

{
	if ( GetGameState() >= eGameState.WinnerDetermined )
		return true

	
	if ( GetGameState() >= eGameState.Playing && GetPlayerArrayOfTeam_Alive( player.GetTeam() ).len() == 0 ) 
		return true

	if ( PlayerMatchState_GetFor( player ) >= ePlayerMatchState.NORMAL )
	{
		switch ( player.GetPlayerNetInt( "respawnStatus" ) )
		{
			case eRespawnStatus.PICKUP_DESTROYED:

				if ( Perk_CanTeammateCraftPlayerBanner( player ) )
					return false

			case eRespawnStatus.SQUAD_ELIMINATED: 
				return true
		}
	}

	return false
}




bool function Ranked_IsDeadAndCanExitWithoutPenalty( entity player )
{
	if ( IsAlive( player ) )
		return false

	if ( PlayerMatchState_GetFor( player ) < ePlayerMatchState.NORMAL )
		return false

	
	
	
	
	
	

	int respawnStatus = player.GetPlayerNetInt( "respawnStatus" )
	float abandonPenaltyWaitPeriod = GetCurrentPlaylistVarFloat( "ranked_respawn_banner_pickedup_timeout", RANKED_LEAVER_PENALTY_TIME_LIMIT_SEC )
	float timeOfDeath = player.GetDeathTime()

	bool bannerCanBeCrafted = Perk_CanTeammateCraftPlayerBanner( player )



	float exitWithoutAbandonTime = 0.0

	
	
	if ( respawnStatus == eRespawnStatus.PICKUP_DESTROYED )
	{
		if ( !bannerCanBeCrafted )
			return true

		exitWithoutAbandonTime = timeOfDeath + RESPAWN_DNA_LIFETIME + abandonPenaltyWaitPeriod
		return Time() > exitWithoutAbandonTime
	}

	
	
	if ( respawnStatus == eRespawnStatus.WAITING_FOR_DELIVERY )
	{
		float timeBannerRecovered = player.GetPlayerNetTime( "respawnBannerPickedUpTime" )
		Assert( timeBannerRecovered > -1 )

		bool bannerRecoveredBeforeBoxTimerExpired = ( timeBannerRecovered - timeOfDeath ) <= RESPAWN_DNA_LIFETIME

		if ( bannerRecoveredBeforeBoxTimerExpired )
			exitWithoutAbandonTime = timeBannerRecovered + abandonPenaltyWaitPeriod
		else
			exitWithoutAbandonTime = timeOfDeath + RESPAWN_DNA_LIFETIME + abandonPenaltyWaitPeriod

		return Time() > exitWithoutAbandonTime
	}

	
	
	return false
}

bool function Ranked_HasPlayerWaitedTooLongAfterBannerWasPickedUp( entity player )
{
	if ( IsAlive( player ) )
		return false

	if ( PlayerMatchState_GetFor( player ) < ePlayerMatchState.NORMAL )
		return false

	if ( player.GetPlayerNetInt( "respawnStatus" ) !=  eRespawnStatus.WAITING_FOR_DELIVERY )
		return false

	Assert( player.GetPlayerNetTime( "respawnBannerPickedUpTime" ) > -1 )
	float timeSinceBeaconPickedUp = Time() - player.GetPlayerNetTime( "respawnBannerPickedUpTime" )

	return (timeSinceBeaconPickedUp > GetCurrentPlaylistVarFloat( "ranked_respawn_banner_pickedup_timeout", 150.0 ))
}






















































int function Ranked_GetXProgMergedPersistenceData( entity player, string persistenceField )
{
	Assert( XPROG_MERGED_PLATFORM_PERSISTENCE_FIELDS.contains( persistenceField ) )
	string platformId = GetMergedPlatformIdForPlayer( player )
	string persistenceKey = format( XPROG_PERSISTENCE_FORMAT_STRING, platformId, persistenceField )





	return SafeGetPersistentVarAsInt( player, persistenceKey )

}












int function GetRankedPersistenceData( entity player, string persistenceField )
{
#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return 0
#endif

	
	string ornull currentSeasonRefOrNull = GetCurrentStatRankedPeriodRefOrNullByType( eItemType.calevent_rankedperiod )
	if ( currentSeasonRefOrNull != null )
	{
		expect string( currentSeasonRefOrNull )
		if ( ItemFlavor_GetType( GetItemFlavorByGUID( ConvertItemFlavorGUIDStringToGUID( currentSeasonRefOrNull ) ) ) == eItemType.ranked_2pt0_period )
		{
			Assert( RANKED_2PT0_PERSISTENCE_FIELDS.contains( persistenceField ) )
			if ( !(RANKED_2PT0_PERSISTENCE_FIELDS.contains( persistenceField )) )
				return 0

			if ( XPROG_MERGED_PLATFORM_PERSISTENCE_FIELDS.contains( persistenceField ) )
			{
				return Ranked_GetXProgMergedPersistenceData( player, persistenceField )
			}
			else
			{



				return player.GetPersistentVarAsInt( "rankedPeriodData[" + currentSeasonRefOrNull + "]." + persistenceField )

			}
		}
		else
		{



			return player.GetPersistentVarAsInt( "allRankedData[" + currentSeasonRefOrNull + "]." + persistenceField )

		}
	}

	return 0
}

int function GetRankedGameData( entity player, string persistenceField )
{
#if DEV
		if ( DEV_ShouldIgnorePersistence() )
			return 0
#endif




		return player.GetPersistentVarAsInt( "rankedGameData." + persistenceField )

}


int function GetDemotionProtectionBuffer( entity player )
{
	return expect int ( player.GetPersistentVar( "demotionBuffer" ) )
}


bool function IsRankedInSeason()
{
	string ornull currentSeasonRefOrNull = GetCurrentStatRankedPeriodRefOrNullByType( eItemType.calevent_rankedperiod )

	if ( currentSeasonRefOrNull == null )
		return false

	return true
}

int function Ranked_GetRankedLevelRequirement()
{
	
	return GetPlaylistVarInt ( "defaults" , "ranked_level_requirement_0_base" , SHARED_RANKED_LEVEL_REQUIREMENT )
}

array<SharedRankedTierData> function Ranked_GetTiers()
{
	return file.rankedTiers
}


SharedRankedTierData ornull function Ranked_GetNextTierData( SharedRankedTierData data )
{
	if ( data.isLadderOnlyTier )
		return null

	if ( data.index + 1 < file.rankedTiers.len() )
		return file.rankedTiers[ data.index + 1 ]

	return null
}


array< SharedRankedDivisionData > function Ranked_GetRankedDivisionDataForTier( SharedRankedTierData tier )
{
	if ( tier.isLadderOnlyTier )
	{
		Assert( file.ladderOnlyDivision != null )
		return [ expect SharedRankedDivisionData( file.ladderOnlyDivision ) ]
	}

	array< SharedRankedDivisionData > data

	for ( int i = 0; i < file.rankedDivisions.len(); i++ )
	{
		if ( file.rankedDivisions[ i ].tier == tier )
			data.append( file.rankedDivisions[ i ] )
	}

	return data
}







































































































































































































































































































































































































































































































































void function Ranked_UpdateEHIRankScore( EHI playerEHI, int rankScore )

{
	EHIScriptStruct ehiss = GetEHIScriptStruct( playerEHI )
	ehiss.rankScore = rankScore
}


void function Ranked_UpdateEHIRankScorePrevSeason( EHI playerEHI, int rankScore )

{
	EHIScriptStruct ehiss = GetEHIScriptStruct( playerEHI )
	ehiss.rankScorePrevSeason = rankScore

}


void function Ranked_UpdateEHIRankedLadderPosition( EHI playerEHI, int rankedLadderPosition )

{
	EHIScriptStruct ehiss = GetEHIScriptStruct( playerEHI )
	ehiss.rankedLadderPosition = rankedLadderPosition
}


void function Ranked_UpdateEHIRankedLadderPositionPrevSeason( EHI playerEHI, int rankedLadderPosition )

{
	EHIScriptStruct ehiss = GetEHIScriptStruct( playerEHI )
	ehiss.rankedLadderPositionPrevSeason = rankedLadderPosition
}





int function Ranked_GetLadderPosition( entity player )
{







		Assert( !IsLobby() )
		EHI playerEHI = ToEHI( player )
		return GetEHIScriptStruct( playerEHI ).rankedLadderPosition





















	unreachable
}





































SharedRankedDivisionData function Ranked_GetNewDivisionForNewSeasonOrSplitReset( entity player, ItemFlavor rankedPeriod, bool isSplitReset )
{
	string rankedPeriodRef = ItemFlavor_GetGUIDString( rankedPeriod )

	ItemFlavor previousRankedPeriod
	if ( isSplitReset )
		previousRankedPeriod = rankedPeriod
	else
		previousRankedPeriod = expect ItemFlavor ( GetPrecedingRankedPeriod( rankedPeriod ) )
	string previousRankedPeriodRef  = ItemFlavor_GetGUIDString( previousRankedPeriod )

	int resetDivisionCount
	switch ( rankedPeriodRef )
	{
		case RANKED_SEASON_13_GUIDSTRING:
			
			
			resetDivisionCount = isSplitReset ? 4 : 2
			break

		default:
			resetDivisionCount = RANKED_RESET_DIVISION_COUNT
			break
	}

	
	int previousRankedScore             = Ranked_GetHistoricalRankScore( player, previousRankedPeriodRef )
	SharedRankedDivisionData divData    = Ranked_GetHistoricalRankedDivisionFromScore( previousRankedScore, previousRankedPeriodRef ) 

	int resetDivisionIndex = maxint( 0,  divData.index - resetDivisionCount )

	
	if ( divData.index >= RANKED_RESET_DIVISION_FLOOR )
	{
		resetDivisionIndex = maxint( RANKED_RESET_DIVISION_FLOOR, resetDivisionIndex )
	}
	SharedRankedDivisionData newDivData = file.historicalRankedDivisions[ rankedPeriodRef ][ resetDivisionIndex ]

	return newDivData
}

int function Ranked_GetRankedV2SplitStatus( ItemFlavor rankPeriodItemFlav )
{
	if ( ItemFlavor_GetType( rankPeriodItemFlav ) == eItemType.ranked_2pt0_period )
	{
		var settingsBlock = ItemFlavor_GetSettingsBlock( rankPeriodItemFlav )
		return ( GetSettingsBlockString( settingsBlock, "rankv2split" ) ).tointeger()
	}
	return RANKED_2PT0_NON_SPLIT
}

bool function Ranked_IsRankedV2FirstSplit( ItemFlavor rankPeriodItemFlav )
{
	return Ranked_GetRankedV2SplitStatus( rankPeriodItemFlav ) == RANKED_2PT0_SPLIT1
}

bool function Ranked_IsRankedV2SecondSplit( ItemFlavor rankPeriodItemFlav )
{
	return Ranked_GetRankedV2SplitStatus( rankPeriodItemFlav ) == RANKED_2PT0_SPLIT2
}

bool function Ranked_IsDisablePointGain( entity player )
{

	return RankedRumble_IsLatestGameRankedRumble( player ) || GetConVarBool( "ranked_disable_point_gain" )



}
























































































































































































































































































































































































































bool function Ranked_ShouldShowRankedBadge ()
{
	return GetCurrentPlaylistVarBool ( "Ranked_ShowRank" , true )
}

bool function Ranked_ShouldShowPreRankedBadge ()
{
	if  ( Ranked_ShouldShowRankedBadge () && GetCurrentPlaylistVarBool ( "ranked_show_prevrank" , false ) )
		return true

	return false
}

