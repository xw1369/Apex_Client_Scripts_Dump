


global function ShPing_Init



global function CodeCallback_PingOnDown
global function CodeCallback_PingOnUp
global function IsPingEnabledForPlayer
global function IsPingDibsEnabledForPlayer
global function GetLootDroneForHitEnt
global function GetLootRollerForHitEnt

global function MapPing_Modify_DistanceCheck_Enabled
global function MapPing_DistanceCheck_GetModifier
global function MapPing_DistanceCheck_GetDistanceRange



global function CaptureObjectivePing_IsUsingCaptureObjectivePings
global function CaptureObjectivePing_GetObjectiveNameStringsArray
global function CaptureObjectivePing_GetObjectiveIndexFromWaypoint
global function CaptureObjectivePing_AddCallback_SetGetCaptureObjectiveIDFromWaypointFunction
global function CaptureObjectivePing_AddCallback_SetIsCaptureObjectivePingObjectiveWaypoint
global function CaptureObjectivePing_GetStarterPingsArray
global function CaptureObjectivePing_GetPingCountForObjectiveForTeamOrAlliance



global function DoubleTapEnemyPingEnabled
global function Ping_SetMapWaypoint
global function Ping_ClearMapWaypoint
global function CancelLatestWaypoint
global function Ping_Interrupt
global function Ping_GetMenuOptionTextForPing
global function Ping_GetShortTextForPing
global function Ping_GetSortModifier
global function Ping_ExecutePendingNewPingWithOverride
global function Ping_GetPendingNewPingTargetEnt
global function Send_PingLoot


global function IsUpdatedCommsMenuActive
global function GetUpdatedCommsMenuRevision


global function Ping_GetPendingPingReplyWaypoint
global function Ping_ExecutePendingPingReplyWithOverride
global function Ping_GetOptionsForPendingReply

global function Ping_GetCommsActionForWaypointReply

global function Ping_IconForPing_Hud
global function Ping_IconForPing_Minimap
global function Ping_IconForPing_Bigmap
global function Ping_IconForPing_IsAdditive
global function Ping_IconScaleForPing
global function Ping_GetLabelForPingType
global function Ping_GetPromptForPing
global function Ping_LineColorForPing_Hud
global function Ping_IconColorForPing_Hud
global function Ping_RuiForPing_Hud
global function Ping_ItemFlavorForPing

global function Ping_TicketIDIsLocallyCanceled

global function AddCallback_OnPingCreatedByAnyPlayer
global function ExecuteCallbacks_OnPingCreatedByAnyPlayer

global function Ping_GetSoundForLocationPing
global function Ping_GetSoundForItemPing

global function Ping_HandleWaypointDelete

global function PingGroundLoot

global function AddOnscreenPromptFunction
global function OnPingUp
global function TryOnscreenPromptFunction

global function AddCallback_OnPingSpawnRequest


global function CaptureObjectivePing_GetObjectiveNameFromObjectiveID_Localized
global function CaptureObjectivePing_AddCallback_SetIsCaptureObjectivePingCommsActionFunction
global function CaptureObjectivePing_GetIsCaptureObjectivePingCommsAction
global function ServerCallback_CaptureObjectivePing_UpdateLastPingedObjective
global function ServerCallback_CaptureObjectivePing_UpdateObjectivePingCounts
global function ServerCallback_CaptureObjectivePing_UpdateObjectivePingText
global function CaptureObjectivePing_SetObjectivePing
global function CaptureObjectivePing_AddCallback_SetGetObjectivesArrayFunction
global function CaptureObjectivePing_GetLastPingedObjective
global function CaptureObjectivePing_AddCallback_OnObjectivePingCoundChanged




#if DEV
global function DEV_PingAllLoot_Client
#endif






























global function PingFlavor_GetInnerIcon
global function PingFlavor_GetInnerShadowIcon
global function PingFlavor_GetOuterIcon
global function PingFlavor_GetOuterShadowIcon
global function PingFlavor_GetAnimIcon
global function PingFlavor_GetDrawHeightLine


global function PingFlavor_GetColor




global enum pingWheelRevision
{
	ORIGINAL,
	UPDATED_REVISION_1,
	UPDATED_REVISION_2,
	UPDATED_REVISION_3,
	UPDATED_REVISION_4,
	UPDATED_REVISION_5
}

global enum pingWheelIndex
{
	INVALID = -1,
	

	DEFAULT, 
	BLEEDING_OUT, 

	
	PING_MAIN_1, 
	PING_MAIN_2, 
	PING_SKYDIVE, 

	
	PING_MAP, 


	PING_TRANSPORT_PORAL,


	_count
}

global enum ePingType
{
	LOCATION,
	LOCATION_TRAINING,

	WE_GO,

	I_GO,
	I_WATCHING,
	I_LOOTING,
	I_DEFENDING,
	I_ATTACKING,

	NEED_HEALTH,

	ABILITY_ME,
	ABILITY_ALLY_0, 
	ABILITY_ALLY_1,
	ABILITY_ALLY_2,

	AREA_CLEAR,
	AREA_VISITED,

	ENEMY_GENERAL,
	ENEMY_SPECIFIC,
	ENEMY_REVIVING,
	ENEMY_LOOTSOURCE,
	
	FRIENDLY_TRAP,
	NEUTRAL_FENCE,

	ENEMY_TRAP,
	ENEMY_SMOKE,
	ENEMY_SHIELD,
	ENEMY_TELEPORTER,
	ENEMY_TESLA_TRAP,
	ENEMY_TROPHY_SYSTEM,
	ENEMY_SILENCE_BOMB,

	LOOT,
	MAP_WAYPOINT,
	DOOR,
	DOOR_OPEN,
	DEATH_BOX,
	LOOT_BIN,
	LOOT_BIN_EXTENDED,
	CAREPACKAGE,
	ZIPLINE,
	SURVEYBEACON,
	HOVERTANK,
	FLYER,
	FLYER_CAGED,
	JUMPTOWER,
	GEYSER,
	LAVA,

	ABILITY_DRONEMEDIC,
	ABILITY_DOMESHIELD,
	ABILITY_WORMHOLE,
	ABILITY_JUMPPAD,

	DEPLOYABLE_MEDIC,

	RESPAWN_STATION,
	RESPAWN_DROPSHIP,
	RESPAWN_BANNER,
	RESPAWN_CARD,

	EVAC_DROPSHIP,

	BLEEDOUT,
	SELF_REVIVE,

	BLOODHOUND_POI_TRAVELER,
	BLOODHOUND_POI_TRAVELER_RECENT,
	BLOODHOUND_POI_BATTLE,
	BLOODHOUND_POI_BATTLE_RECENT,
	BLOODHOUND_POI_LOOTING,
	BLOODHOUND_POI_LOOTING_RECENT,
	BLOODHOUND_POI_WOUNDED,
	BLOODHOUND_POI_WOUNDED_RECENT,

	JUMP_PAD,
	SKYDIVE_LAUNCHER,

	CRYPTO_DRONE,

	RAMPART_WALL,
	RAMPART_TURRET,

	DEATH_TOTEM,

	_assertion_marker, 

	RESPAWN_MOBILE,
	NEUTRAL_TROPHY_SYSTEM,


		WE_ATTACK,
		I_ULTIMATE,
		WE_FALLBACK,
		ENEMY_AUDIO,
		ENEMY_FIGHTING,
		DONT_REVIVE,
		WE_AVOID,
		WE_DEFEND,
		WE_ABILITY,
		WE_REGROUP,







		LOOT_CREEP_INFECTED,
		LOOT_CREEP_SPIDER,



		CAREPACKAGE_INSIGHT,
		CAREPACKAGE_INSIGHT_LOOTED,
		CAREPACKAGE_INSIGHT_FUTURE,
		MUNITIONS_BOX,
		MUNITIONS_BOX_LOOT,
		SUPPORT_BOX,
		SUPPORT_BOX_LOOT,
		ENCRYPTED_CONSOLE,








		LOOT_VAULT,
		LOOT_VAULT_OPEN,
		LOOT_VAULT_HAS_KEY_SQUAD,
		LOOT_VAULT_HAS_KEY_SELF,
		LOOT_VAULT_REVEAL,



		SHIP_VAULT,
		SHIP_VAULT_HAS_KEY_SQUAD,
		SHIP_VAULT_HAS_KEY_SELF,
		SHIP_VAULT_REVEAL,


		LOOT_DRONE,


		STORY_MARVIN,
		LOOT_MARVIN,


		CHARGE_PYLON,


		PHASE_RUNNER,



		BOXING_RING,


		LOOT_ROLLER,


		HOVERVEHICLE,
		HOVERVEHICLE_ALLY,
		HOVERVEHICLE_ENEMY,
		HOVERVEHICLE_NAG,



		TRAIN,



		EVAC_SHIP,
		EVAC_ZONE,













		TRAIN_OBJECTIVE,
		STATION,


		SPAWN_REGION,


		PING_REPLICATOR_INCOMING,
		PING_REPLICATOR,
		PING_MATERIALS,
		CRAFTING_GENERIC,
		PING_REPLICATOR_NOONE_USED,
		PING_REPLICATOR_ALL_USED,
		PING_REPLICATOR_PLAYER_USED,
		PING_REPLICATOR_TEAMMATE_USED,
		PING_REPLICATOR_DISPENSER_INCOMING,



	VOID_RING,
	ABILITY_BLACK_MARKET,

	QUEST_OBJECTIVE,
	QUEST_DRILL,

	OBJECTIVE,

	DRONE_PING_BANNER_0,
	DRONE_PING_BANNER_1,
	DRONE_PING_BANNER_2,
	DRONE_PING_BANNER_3,
	DRONE_PING_BANNER_MANY,

	VALK_ULT_COME_HERE,
	VALK_ULT_ENEMY_TAKING_OFF,

	ABILITY_SPACE_ELEVATOR,
	ABILITY_BLACK_HOLE,

	ABILITY_SHIELD_MINE,


	HOLOSPRAY_LIKE,





	VANTAGE_SPOTS_ENEMY,
	VANTAGE_COMPANION,
	ENEMY_VANTAGE_COMPANION,

	ABILITY_BARRICADE,
	ABILITY_BARRICADE_OPEN,
	ABILITY_PIERCING_SPIKES,
	ABILITY_DARK_VEIL,





	ASH_PASSIVE_PING_DEATHBOX,
	ASH_PASSIVE_ID_ATTACKER,
	ASH_PASSIVE_ID_DEATHBOX,
	PING_PHASE_BREACH,
	OPENED_PHASE_BREACH,
	ENEMY_TETHERED,








		EXPLOSIVEHOLD,
		EXPLOSIVEHOLD_OPEN,
		EXPLOSIVEHOLD_REQUEST,



		PING_MY_LAST_DEATH_BOX,
		MARK_MY_LAST_DEATH_BOX,



		MARK_MY_LAST_DEATH_LOCATION,


	NON_PINGABLE_SPAWN_LOCATION,
	PING_CAPTURE_OBJECTIVE_DEFEND,
	PING_CAPTURE_OBJECTIVE_ATTACK,


		ENEMY_HEALING_HEALTH,
		ENEMY_HEALING_SHIELD,


	MAGGIE_WRECKING_BALL,

	ABILITY_MOBILE_SHIELD,
	ENEMY_MOBILE_SHIELD,
	ABILITY_CASTLE_WALL,
	ENEMY_CASTLE_WALL,
	ABILITY_CASTLE_WALL_ENERGIZED,
	ENEMY_CASTLE_WALL_ENERGIZED,


		BLOODHOUND_WHITE_RAVEN,
		BLOODHOUND_WHITE_RAVEN_TARGET_LOC,


	PATHFINDER_STATUE,

	PING_PROWLER,
	PING_SPIDER,


		PING_PROWLER_DEN,
		PING_PROWLER_DEN_EMPTY,
		PING_SPIDER_EGGS,
		PING_SPIDER_EGGS_HATCHED,







	ABILITY_ECHO_LOCATOR,
	PING_ABILITY_ECHO_LOCATOR_ENEMY,
	PING_ABILITY_ECHO_LOCATOR_FRIENDLY,


		RAMPART_TT_MURAL,
		RAMPART_TT_VEND,



		PING_GRAVITYCANNON,


	PING_GONDOLA,


		PING_IMC_ARMORY_EXT,
		PING_IMC_ARMORY_PANEL,


	PING_PANEL,
	PING_PANEL_COOLDOWN,
	PING_PANEL_INACTIVE,


		MEDBAY,
		MEDBAY_COOLDOWN,
		MEDBAY_DISABLED,


	CAREPACKAGE_INCOMING,


		ZIPRAIL,



		REDEPLOY_BALLOON,





















		REV_SHELL,



		THE_HUNT_ITEM,
		THE_HUNT_AREA_HUNTER,
		THE_HUNT_AREA_PREY,


	TOXIC_GAS,

	MULTILOCATION,


		REDEYED_REV,
		EVAC_AREA,
		LEGEND_START_AREA,


	RAMPART_TT_VENDING,


		LOOT_TICK_GH,







		UPGRADE_STATION,



		TRANSPORT_PORTAL_REMOTE,
		TRANSPORT_PORTAL_FRIENDLY,
		TRANSPORT_PORTAL_ENEMY,
		CHASE_PORTAL_FRIENDLY,
		CHASE_PORTAL_ENEMY,
		PHASE_DOOR,



		ENEMY_POI,


		MULTI_ENEMY_POI,







	_count
}




global enum ePingReply
{
	BLANK,

	JOIN,

	OK,
	NEGATIVE,
	I_CANNOT,
	THANKS,
	HOLD_ON,

	COMING_TO_HELP,

	OWNER_ANNOUNCE,
	OWNER_CANCEL,

	LOOT_DIBS,
	LOOT_UNDIBS,

	RESPAWN_YES,

	GENERAL_WAYPOINT_CALLOUT,

	SPAWN_HERE,

	ABILITY_DOMESHIELD,
	ABILITY_JUMPPAD,
	ABILITY_WORMHOLE,
	SKYDIVE_LAUNCHER,

	REPLY_HOLOSPRAY_LIKE,

	RECOVER_DEATHBOX,


	CAPTURE_OBJECTIVE_PING_DEFEND,
	CAPTURE_OBJECTIVE_PING_ATTACK,


	CAREPACKAGE_INSIGHT_REPLY,
	CAREPACKAGE_INSIGHT_FUTURE_REPLY,






	_count
}














































global struct ReplyCommsActionInfo
{
	int commsAction = eCommsAction.BLANK
	int commsFlags = eCommsFlags.NONE
}



global struct PingHitEntData
{
	entity hitEnt
	string scriptName
	string entTargetName
	asset entModel
	entity parentEnt
	asset parentModel
	string parentScriptName
	string parentTargetName
	bool isParentValid
}



struct PingTraceResults
{
	entity player
	vector endPos
	vector surfaceNormal
	float  hitDist
	entity hitEnt
	bool   success = false

	TraceResults& tr
}




struct OnscreenPromptData
{
	int                             priority
	float                           timeout
	string                          hint



	void functionref(entity player) onscreenPromptFunction
}




struct KeyColorData
{
	int colorID
	int optionalParam
}




struct
{

		table< string, array<OnscreenPromptData> > onscreenPromptFunctions
		var                                        warnRui

		int                    specificPingCount
		float                  nextSpecificPingTime
		table< string, float > lastOnscreenPromptFunctionTriggerTime

		array< void functionref( entity, entity ) > spawnWPFunctionCallbacks

		
		bool functionref( int, entity ) getIsCommsActionForCaptureObjectivePingFunction
		array < void functionref( entity, int, int ) > onObjectivePingCountChangedCallbackFunctions
		array < entity > functionref() getCaptureObjectivesArrayFunction
		entity	lastLocalCaptureObjectivePing









	
	int functionref( entity ) getCaptureObjectiveIDFromWaypointFunction
	bool functionref( entity ) getIsCaptureObjectivePingObjectiveWPFunction
	array < table< entity, int > > objectiveToCaptureObjectivePingCountTableArray 
	array<entity> captureObjectivePingStarterPings

	bool devPrintsOn = false
} file





const string PING_SOUND_LOCATION_1P = "UI_MapPing_Location_1P"
const string PING_SOUND_LOCATION_3P = "UI_DownedAlert_Friendly"

const string PING_SOUND_ENEMY_1P = "UI_MapPing_Enemy_1P"
const string PING_SOUND_ENEMY_3P = "UI_MapPing_Enemy_3P"

const string PING_SOUND_ITEM_3P = "UI_MapPing_Item_3P"
const string PING_SOUND_ITEM_1P = "UI_MapPing_Item_1P"


global const float PING_EMOTE_REPLY_CULL_DISTANCE = 1500.0 

global const string PING_SOUND_LOCAL_CONFIRM = "UI_MapPing_Local_Confirm_1P"
global const string PING_SOUND_UNDO = "UI_MapPing_Undo_1P"
global const string PING_SOUND_ACKNOWLEDGE = "UI_MapPing_Acknowledge_1P"

global const vector PING_COLOR_FRIENDLY = <FRIENDLY_R, FRIENDLY_G, FRIENDLY_B>
const int PING_TRACE_DISTANCE = 90000

const string CMDNAME_PING_MAP_WAYPOINT = "ClientCallback_PingMapWaypoint"
const string CMDNAME_PING_NEW_LOOT_DEATHBOX = "ClientCallback_PingNewLootDeathbox"
const string CMDNAME_PING_NEW_LOOT_GRABBER = "ClientCallback_PingNewLootGrabber"
const string CMDNAME_PING_NEW_LOOT_OUTSIDE_DEATHBOX = "ClientCallback_PingNewLootOutsideDeathbox"
const string CMDNAME_PING_REPLY = "ClientCallback_PingReply"
const string CMDNAME_CANCEL_PING_BY_TICKETID = "ClientCallback_CancelPingByTicketID"

const string IMC_ARMORY_PROXY_NAME = "mdl/tropics/spectre_shack_01_proxy.rmdl"
global const string IMC_ARMORY_PANEL_SCRIPTNAME = "spectreshack_control_v4"

global const string PHASEDRIVER_PANEL_SCRIPTNAME = "panel_phasedriver"
global const string PHASEDRIVER_PANEL_COOLDOWN_SCRIPTNAME = "panel_phasedriver_cooldown"




string function Ping_GetSoundForLocationPing( entity wp, int pingType, bool isOurs, bool isSameTeam )
{
	switch( pingType )
	{
		case ePingType.ENEMY_GENERAL:
		case ePingType.ENEMY_REVIVING:

		case ePingType.ENEMY_HEALING_HEALTH:
		case ePingType.ENEMY_HEALING_SHIELD:

		case ePingType.ENEMY_SPECIFIC:
		case ePingType.ENEMY_TRAP:
		case ePingType.ENEMY_TESLA_TRAP:
		case ePingType.ENEMY_TROPHY_SYSTEM:
		case ePingType.ENEMY_SMOKE:
		case ePingType.TOXIC_GAS:
		case ePingType.ENEMY_TELEPORTER:
		case ePingType.ENEMY_SHIELD:
		case ePingType.ENEMY_TETHERED:
		case ePingType.ASH_PASSIVE_ID_ATTACKER:
			return (isOurs ? PING_SOUND_ENEMY_1P : PING_SOUND_ENEMY_3P)








		case ePingType.ABILITY_DOMESHIELD:
		case ePingType.ABILITY_DRONEMEDIC:
		case ePingType.ABILITY_WORMHOLE:
		case ePingType.ABILITY_JUMPPAD:
		case ePingType.SKYDIVE_LAUNCHER:


		case ePingType.EVAC_SHIP:
		case ePingType.EVAC_ZONE:












		case ePingType.QUEST_OBJECTIVE:
		case ePingType.QUEST_DRILL:


		case ePingType.SPAWN_REGION:





		case ePingType.MAGGIE_WRECKING_BALL:
		case ePingType.ABILITY_MOBILE_SHIELD:
		case ePingType.ABILITY_CASTLE_WALL:


		case ePingType.BLOODHOUND_WHITE_RAVEN:
		case ePingType.BLOODHOUND_WHITE_RAVEN_TARGET_LOC:




		case ePingType.VOID_RING:
		case ePingType.ABILITY_SPACE_ELEVATOR:
		case ePingType.ABILITY_ECHO_LOCATOR:







		case ePingType.MULTI_ENEMY_POI:

			return ""

		case ePingType.ABILITY_BLACK_MARKET:
		{
			if ( isSameTeam )
			{
				entity blackMarket = wp.GetParent()
				if ( IsValid( blackMarket ) && GradeFlagsHas( blackMarket, eGradeFlags.IS_BUSY ) && Distance2D( GetLocalViewPlayer().EyePosition(), wp.GetOrigin() ) < 3800.0 )
					return ""
			}
		}

		case ePingType.HOLOSPRAY_LIKE:
			return "UI_MapPing_HoloSpray_1P"

		case ePingType.OPENED_PHASE_BREACH:
			return (isOurs ? "" : PING_SOUND_LOCATION_3P)
	}

	if ( !isSameTeam )
	{
		switch ( pingType )
		{
			case ePingType.BLEEDOUT:
			case ePingType.SELF_REVIVE:
				if ( !isSameTeam )
					return "ui_mapping_item_3p"
				break
		}
	}

	return (isOurs ? PING_SOUND_LOCATION_1P : PING_SOUND_LOCATION_3P)
}




string function Ping_GetSoundForItemPing( int pingType, bool isOurs )
{
	return (isOurs ? PING_SOUND_ITEM_1P : PING_SOUND_ITEM_3P)
}




void function ShPing_Init()
{
	AddCallback_RegisterRootItemFlavors( void function() {
		foreach ( asset pingAsset in GetBaseItemFlavorsFromArray( "pings" ) )
			RegisterItemFlavorFromSettingsAsset( pingAsset )
	} )


		Remote_RegisterServerFunction( CMDNAME_PING_MAP_WAYPOINT, "int", INT_MIN, INT_MAX, "int", INT_MIN, INT_MAX, "int", INT_MIN, INT_MAX, "bool" )
		Remote_RegisterServerFunction( CMDNAME_PING_NEW_LOOT_DEATHBOX, "typed_entity", "prop_survival", "typed_entity", "prop_death_box", "int", INT_MIN, INT_MAX, "vector", -MAX_WORLD_COORD, MAX_WORLD_COORD, 32 )
		Remote_RegisterServerFunction( CMDNAME_PING_NEW_LOOT_GRABBER, "typed_entity", "prop_survival", "typed_entity", "prop_loot_grabber", "int", INT_MIN, INT_MAX, "vector", -MAX_WORLD_COORD, MAX_WORLD_COORD, 32 )
		Remote_RegisterServerFunction( CMDNAME_PING_NEW_LOOT_OUTSIDE_DEATHBOX, "typed_entity", "prop_survival", "int", INT_MIN, INT_MAX, "vector", -MAX_WORLD_COORD, MAX_WORLD_COORD, 32 )
		Remote_RegisterServerFunction( CMDNAME_PING_REPLY, "typed_entity", "player_waypoint", "int", 0, ePingReply._count - 1 )
		Remote_RegisterServerFunction( CMDNAME_CANCEL_PING_BY_TICKETID, "int", INT_MIN, INT_MAX )

		
		if ( CaptureObjectivePing_IsUsingCaptureObjectivePings() )
		{
			bool isUsingAlliances = AllianceProximity_IsUsingAlliances()
			int maxNumAlliances = AllianceProximity_GetMaxNumAlliances()
			int pingCountMax = isUsingAlliances ? AllianceProximity_GetMaxNumPlayersPerAlliance() + 1 : GetExpectedSquadSize() + 1
			int firstTeamOrAllianceIndex = isUsingAlliances ? ALLIANCE_A : TEAM_MULTITEAM_FIRST
			int teamOrAllianceIndexMax = isUsingAlliances ? ALLIANCE_A + maxNumAlliances : TEAM_MULTITEAM_FIRST + MAX_TEAMS
			Remote_RegisterClientFunction( "ServerCallback_CaptureObjectivePing_UpdateLastPingedObjective", "entity", "entity", "entity", "bool" )
			Remote_RegisterClientFunction( "ServerCallback_CaptureObjectivePing_UpdateObjectivePingCounts", "entity", "int", firstTeamOrAllianceIndex, teamOrAllianceIndexMax, "int", 0, pingCountMax )
			Remote_RegisterClientFunction( "ServerCallback_CaptureObjectivePing_UpdateObjectivePingText", "entity", "int", 0, ePingType._count, "int", 0, pingCountMax, "bool" )
			Remote_RegisterServerFunction( "ClientCallback_CaptureObjectivePing_PingObjective", "typed_entity", "player_waypoint" )
			if ( isUsingAlliances )
				file.objectiveToCaptureObjectivePingCountTableArray.resize( maxNumAlliances )
			else
				file.objectiveToCaptureObjectivePingCountTableArray.resize( teamOrAllianceIndexMax )
		}



		RegisterSignal( "UpdateOnscreenPromptHintAfterDelay" )

		AddOnDeathCallback( "player", OnDeathCallback )
		AddCallback_OnBleedoutStarted( OnBleedoutStarted )
		AddCallback_OnBleedoutEnded( OnBleedoutEnded )

		AddScoreboardShowCallback( Ping_Interrupt )

		AddCallback_OnPingCreatedByAnyPlayer( OnPingCreatedByAnyPlayer_VocalizeNewPing )
		SetCallback_PingSpecificType( Ping_HandleSpecificPingCommand )

		AddCallback_OnCommsMenuStateChanged( OnCommsMenuChanged )
		AddCallback_OnPlayerLifeStateChanged( OnLifeStateChanged )

		
		if ( CaptureObjectivePing_IsUsingCaptureObjectivePings() )
		{
			AddCallback_OnFindFullMapAimEntity( CaptureObjectivePing_GetObjectiveUnderAim, CaptureObjectivePing_PingObjectiveUnderAim )
			AddCreateCallback( PLAYER_WAYPOINT_CLASSNAME, CaptureObjectivePing_OnPlayerWaypointCreated )
			AddDestroyCallback( PLAYER_WAYPOINT_CLASSNAME, CaptureObjectivePing_OnPlayerWaypointDestroyed )
		}
















}


























































bool function Ping_ShouldExecutePing( entity player )
{
	if ( InPrediction() && !IsFirstTimePredicted() )
		return false

	if ( Freelance_IsHubLevel() )
		return false

	if ( GetGameState() == eGameState.WinnerDetermined || GetGameState() > eGameState.Epilogue )
		return false

	if ( TryOnscreenPromptFunction( player, "ping" ) )
		return false

	if ( !PingIsAllowed( player ) )
		return false

	return true
}




void function CodeCallback_PingOnDown( entity player )
{

		if ( !Ping_ShouldExecutePing( player ) )
			return

		OnPingDown( player )

}




void function CodeCallback_PingOnUp( entity player )
{

		if ( InPrediction() && !IsFirstTimePredicted() )
			return

		OnPingUp( player )

}




bool function IsPingEnabledForPlayer( entity player )
{
	return player.GetPlayerNetBool( "pingEnabled" ) && GetCurrentPlaylistVarBool( "is_pinging_enabled", true )
}




bool function IsPingDibsEnabledForPlayer( entity player )
{
	if ( !IsValid( player ) )
		return false


		if ( IsPlayerShadowZombie( player ) )
			return false


	return true
}































































































































bool function ConsiderPingTraceFailed( TraceResults tr )
{
	if ( tr.hitSky )
		return true
	if ( tr.fraction >= 0.99 )
		return true

	return false
}




PingTraceResults function DoPingTrace( entity player )
{
	const int colGroup = TRACE_COLLISION_GROUP_NONE
	
	
	const int colMask = TRACE_MASK_VISIBLE_AND_NPCS | CONTENTS_BLOCKLOS | CONTENTS_BLOCK_PING | CONTENTS_HITBOX

	TraceResults tr = PingTraceForPlayer( player, PING_TRACE_DISTANCE, colMask, colGroup )

	PingTraceResults result
	if ( ConsiderPingTraceFailed( tr ) )
	{
		result.success = false
	}
	else
	{
		result.player = player
		result.endPos = SanitizePingTraceEndPos(tr.endPos)
		result.surfaceNormal = tr.surfaceNormal
		result.hitDist = (tr.fraction * PING_TRACE_DISTANCE)
		result.hitEnt = tr.hitEnt
		result.success = true
	}
	result.tr = tr

#if DEV
		printf( "PING (%s) -  Dist:%.1f, %s, pos:%s, norm:%s, contents:0x%x", (IsServer() ? "SERVER" : "CLIENT"), result.hitDist, (IsValid( result.hitEnt ) ? ("[" + result.hitEnt + "]   '" + result.hitEnt.GetScriptName() + "'") : ""), string( tr.endPos ), string( tr.surfaceNormal ), tr.contents )
#endif

	return result
}



vector function SanitizePingTraceEndPos(vector endPos)
{
	float posX = Clamp( endPos.x, -64000, 64000  ) 
	float posY = Clamp( endPos.y, -64000, 64000  ) 
	float posZ = Clamp( endPos.z, -64000, 64000  ) 
	return <posX, posY, posZ>
}







asset function PingFlavor_GetInnerIcon( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.ping )

	return GetGlobalSettingsAsset( ItemFlavor_GetAsset( flavor ), "innerIcon" )
}




asset function PingFlavor_GetInnerShadowIcon( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.ping )

	return GetGlobalSettingsAsset( ItemFlavor_GetAsset( flavor ), "innerShadowIcon" )
}




asset function PingFlavor_GetOuterIcon( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.ping )

	return GetGlobalSettingsAsset( ItemFlavor_GetAsset( flavor ), "outerIcon" )
}




asset function PingFlavor_GetOuterShadowIcon( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.ping )

	return GetGlobalSettingsAsset( ItemFlavor_GetAsset( flavor ), "shadowIcon" )
}




asset function PingFlavor_GetAnimIcon( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.ping )

	return GetGlobalSettingsAsset( ItemFlavor_GetAsset( flavor ), "animIcon" )
}




bool function PingFlavor_GetDrawHeightLine( ItemFlavor flavor )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.ping )

	return GetGlobalSettingsBool( ItemFlavor_GetAsset( flavor ), "drawHeightLine" )
}




KeyColorData function GetKeyColorDataForString( string keyColor, int optionalParam )
{
	int colorID = COLORID_DEFAULT

	KeyColorData keyColorData
	keyColorData.colorID = COLORID_DEFAULT
	keyColorData.optionalParam = 0

	switch ( keyColor )
	{
		case "none":
			break

		case "member":
			keyColorData.colorID = COLORID_MEMBER_COLOR0
			keyColorData.optionalParam = optionalParam
			break

		case "enemy":
		case "hostile":
			keyColorData.colorID = COLORID_ENEMY
			break

		case "friendly":
			keyColorData.colorID = COLORID_FRIENDLY
			break

		case "loot_common":
			keyColorData.colorID = COLORID_LOOT_TIER1
			break

		case "loot_rare":
			keyColorData.colorID = COLORID_LOOT_TIER2
			break

		case "loot_epic":
			keyColorData.colorID = COLORID_LOOT_TIER3
			break

		case "loot_legendary":
			keyColorData.colorID = COLORID_LOOT_TIER4
			break

		case "loot_heirloom":
			keyColorData.colorID = COLORID_LOOT_TIER5
			break

		case "bleedout":
			keyColorData.colorID = COLORID_HUD_BLEEDOUT_COLOR
			break

		case "heal":
			keyColorData.colorID = COLORID_HUD_HEAL_COLOR
			break

		default:
			Assert( false, "Unhandled key color \"" + keyColor + "\n from Bakery" )
	}

	return keyColorData
}




vector function PingFlavor_GetColor( ItemFlavor flavor, int optionalParam = -1 )
{
	Assert( ItemFlavor_GetType( flavor ) == eItemType.ping )

	string colorKey = GetGlobalSettingsString( ItemFlavor_GetAsset( flavor ), "colorKey" )
	if ( colorKey == "none" )
		return GetGlobalSettingsVector( ItemFlavor_GetAsset( flavor ), "defaultColor" )

	KeyColorData keyColorData = GetKeyColorDataForString( colorKey, optionalParam )
	return GetKeyColor( keyColorData.colorID, keyColorData.optionalParam ) / 255.0
}




int function GetCommsActionForOwnerAnnounce( entity player, entity wp )
{
	int pingType = Waypoint_GetPingTypeForWaypoint( wp )
	switch( pingType )
	{
		case ePingType.ABILITY_DRONEMEDIC:
			return eCommsAction.PING_FRIENDLY_HEALTH

		case ePingType.ABILITY_DOMESHIELD:
			return eCommsAction.PING_FRIENDLY_SHIELD

		case ePingType.ABILITY_WORMHOLE:
			return eCommsAction.PING_FRIENDLY_TELEPORTER

		case ePingType.OPENED_PHASE_BREACH:
			return eCommsAction.PING_PHASE_BREACH

		case ePingType.ENEMY_TETHERED:
			return eCommsAction.PING_ENEMY_SPOTTED_SPECIFIC











		case ePingType.ABILITY_JUMPPAD:
		case ePingType.ABILITY_SPACE_ELEVATOR:



			return eCommsAction.PING_WE_GO

		case ePingType.VOID_RING:
	}

	return eCommsAction.PING_LOCATION
}




ReplyCommsActionInfo function Ping_GetCommsActionForWaypointReply( entity player, entity wp, int pingReply )
{
	ReplyCommsActionInfo result
	if ( !IsValid( wp ) )
		return result

	bool playerIsOwner = (IsValid( player ) && (player == wp.GetOwner()))
	switch( pingReply )
	{
		case ePingReply.JOIN:
			result.commsAction = eCommsAction.REPLY_JOIN
			break

		case ePingReply.OK:
			result.commsAction = eCommsAction.REPLY_YES
			break

		case ePingReply.NEGATIVE:
			result.commsAction = eCommsAction.REPLY_NO
			break

		case ePingReply.THANKS:
			result.commsAction = eCommsAction.REPLY_THANKS
			break

		case ePingReply.I_CANNOT:
			result.commsAction = eCommsAction.REPLY_I_CANNOT
			break

		case ePingReply.HOLD_ON:
			result.commsAction = eCommsAction.PING_HOLD_ON
			break

		case ePingReply.COMING_TO_HELP:
			result.commsAction = eCommsAction.REPLY_COMING_TO_HELP
			break

		case ePingReply.OWNER_ANNOUNCE:
			if ( playerIsOwner )
				result.commsAction = GetCommsActionForOwnerAnnounce( player, wp )
			break

		case ePingReply.OWNER_CANCEL:
			if ( playerIsOwner )
			{
				int pingType        = Waypoint_GetPingTypeForWaypoint( wp )
				bool shouldBeUrgent = (pingType == ePingType.AREA_CLEAR)








				if ( shouldBeUrgent )
					result.commsFlags = (result.commsFlags | eCommsFlags.FORCE_URGENT)

				result.commsAction = eCommsAction.CANCELED_PING
			}
			break

		case ePingReply.LOOT_DIBS:
			result.commsAction = eCommsAction.REPLY_LOOT_DIBS
			break

		case ePingReply.LOOT_UNDIBS:
			result.commsAction = eCommsAction.REPLY_LOOT_UNDIBS
			break

		case ePingReply.RESPAWN_YES:
			result.commsAction = eCommsAction.REPLY_RESPAWN_YES
			break

		case ePingReply.GENERAL_WAYPOINT_CALLOUT:
			result.commsAction = eCommsAction.PING_LOCATION
			break



		case ePingReply.SPAWN_HERE:
			result.commsAction = eCommsAction.REPLY_SPAWNREGION
			break


		case ePingReply.ABILITY_WORMHOLE:
			result.commsAction = eCommsAction.PING_ENEMY_TELEPORTER
			break

		case ePingReply.ABILITY_DOMESHIELD:
			result.commsAction = eCommsAction.PING_ENEMY_SHIELD
			break

		case ePingReply.ABILITY_JUMPPAD:
			result.commsAction = eCommsAction.PING_I_WATCHING
			break

		case ePingReply.SKYDIVE_LAUNCHER:
			result.commsAction = eCommsAction.PING_SKYDIVE_LAUNCHER
			break

		case ePingReply.REPLY_HOLOSPRAY_LIKE:
			result.commsAction = eCommsAction.REPLY_HOLOSPRAY_LIKE
			result.commsFlags = (result.commsFlags | eCommsFlags.BROADCAST_TO_WAYPOINT_OWNER)
			break


		case ePingReply.RECOVER_DEATHBOX:
			result.commsAction = eCommsAction.PING_MY_LAST_DEATHBOX
			break


		case ePingReply.CAPTURE_OBJECTIVE_PING_DEFEND:
			if ( CaptureObjectivePing_DidPlayerPingSameObjective( player, wp, wp.GetParent() ) )
			{
				result.commsAction = eCommsAction.CANCELED_PING
			}
			else
			{

					if ( GameMode_IsActive( eGameModes.CONTROL ) )
						result.commsAction = eCommsAction.PING_CONTROL_OBJECTIVE_DEFEND

			}
			break

		case ePingReply.CAPTURE_OBJECTIVE_PING_ATTACK:
			if ( CaptureObjectivePing_DidPlayerPingSameObjective( player, wp, wp.GetParent() ) )
			{
				result.commsAction = eCommsAction.CANCELED_PING
			}
			else
			{

					if ( GameMode_IsActive( eGameModes.CONTROL ) )
						result.commsAction = eCommsAction.PING_CONTROL_OBJECTIVE_ATTACK



					if ( GameModeVariant_IsActive( eGameModeVariants.FREEDM_LOCKDOWN ) )
						result.commsAction = eCommsAction.PING_TREASUREHUNT_OBJ_ATTACK






			}
			break


		case ePingReply.CAREPACKAGE_INSIGHT_FUTURE_REPLY:
			result.commsAction = eCommsAction.REPLY_CAREPACKAGE_INSIGHT_FUTURE
			break

		case ePingReply.CAREPACKAGE_INSIGHT_REPLY:
			result.commsAction = eCommsAction.REPLY_CAREPACKAGE_INSIGHT
			break








		default:
			result.commsAction = eCommsAction.BLANK
	}

	return result
}




struct PingCommandParams
{
	entity hitEnt
	int    pingType
}




void function OnDeathCallback( entity player )
{
	if ( IsLocalClientPlayer( player ) )
		Ping_Interrupt()
}




void function OnBleedoutStarted( entity victim, float endTime )
{
	if ( victim != GetLocalViewPlayer() )
		return
	Ping_Interrupt()
}




void function OnBleedoutEnded( entity victim )
{
	if ( victim != GetLocalViewPlayer() )
		return
	Ping_Interrupt()
}




entity function GetZiplineUseEntity( entity player )
{
	entity useEnt = player.GetUsePromptEntity()
	if ( !IsValid( useEnt ) )
		return null

	if ( useEnt.IsRopeZipline() || useEnt.IsZipline() )
	{
		







		return useEnt
	}

	return null
}


entity function GetZiprailUseEntity( entity player )
{
	entity useEnt = player.GetUsePromptEntity()
	if ( !IsValid( useEnt ) )
		return null

	if ( useEnt.IsZipline() && useEnt.Zipline_IsCurvedZipline() )
	{
		







		return useEnt
	}

	return null
}





struct PendingPing
{
	int    newPing_pingType
	vector newPing_origin
	entity newPing_pingedEnt

	entity reply_waypoint

	bool  allowQuickPing
	float timeStamp

	int  newPing_wheelIndex
}




PendingPing s_pendingPing
bool s_pendingPingIsValid = false




void function SetPendingNewPing( int pingType, vector origin, entity pingedEnt, bool allowQuickPing, int wheelIndex)
{
	s_pendingPing.newPing_pingType = pingType
	s_pendingPing.newPing_origin = origin
	s_pendingPing.newPing_pingedEnt = pingedEnt

	s_pendingPing.newPing_wheelIndex = wheelIndex

	s_pendingPing.reply_waypoint = null

	s_pendingPing.allowQuickPing = allowQuickPing
	s_pendingPing.timeStamp = Time()
	s_pendingPingIsValid = true

	PendingPingMarkerStart( origin, pingType )
}




void function SetPendingPingReply( entity wp )
{
	s_pendingPing.reply_waypoint = wp

	s_pendingPing.allowQuickPing = true        
	s_pendingPing.timeStamp = Time()
	s_pendingPingIsValid = true

	
}




void function ClearPendingPing()
{
	PendingPingMarkerStop()
	s_pendingPingIsValid = false
}




bool function HasPendingPing()
{
	return s_pendingPingIsValid
}




entity function Ping_GetPendingNewPingTargetEnt()
{
	if ( s_pendingPingIsValid )
		return s_pendingPing.newPing_pingedEnt

	return null
}




bool function PingIsAllowed( entity player )
{
	if ( IsWatchingReplay() )
		return false
	if ( !IsAlive( player ) )
		return false
	if ( IsScoreboardShown() )
		return false
	if ( GetPlayerIs3pEmoting( player ) )
		return false
	if ( Time() < s_onDownLockoutTime )
		return false
	if ( GetGameState() == eGameState.WinnerDetermined || GetGameState() > eGameState.Epilogue )
		return false
	if ( GetGameState() == eGameState.PickLoadout )
		return false
	if ( GetGameState() == eGameState.WaitingForPlayers && !GetCurrentPlaylistVarBool( "survival_staging_area_enabled", false ) )
		return false
	if ( !IsPingEnabledForPlayer( player ) )
		return false
	if ( Crafting_IsPlayerCrafting() )
		return false

	return true
}




bool function DoubleTapEnemyPingEnabled()
{
	return GetConVarBool( "hud_setting_pingDoubleTapEnemy" )
}



bool function IsWaypointCulledEmote(entity player, entity wp)
{
	if ( wp.GetWaypointType() == eWaypoint.EMOTE_ICON || wp.GetWaypointType() == eWaypoint.SKYDIVE_EMOTE_ICON )
	{
		float frac = TraceLineSimple( player.CameraPosition(), wp.GetOrigin(), player )
		if ( Distance( player.GetOrigin() , wp.GetOrigin() ) > PING_EMOTE_REPLY_CULL_DISTANCE || frac < 1.0 )
			return true
	}

	return false
}




vector s_lastPingDownViewVector = <0, 0, 0>
float s_doubleTapTimer = -60.0
void function OnPingDown( entity player )
{
	if ( GetConVarBool( "sv_cheats" ) && InputIsButtonDown( BUTTON_TRIGGER_LEFT ) && InputIsButtonDown( BUTTON_STICK_LEFT ) )
	{
		PingTraceResults tr = DoPingTrace( player )
		if ( tr.success )
		{
			vector pos = tr.endPos
			GetLocalViewPlayer().ClientCommand( format( "GoToMapPoint %.3f %.3f %.3f", pos.x, pos.y, pos.z ) )
			ScreenFlash( 0.0, 0.0, 0.0, 0.1, 0.5 )
			EmitSoundOnEntity( GetLocalViewPlayer(), "dropship_mp_epilogue_warpout" )
		}
		return
	}

	if ( HasPendingPing() )
		ClearPendingPing()
	Assert( !HasPendingPing() )







	
	entity spottedEnemy = null
	{
		entity aaTarget = GetAimAssistCurrentTarget()
		if ( PlayerHasPassive( player, ePassives.PAS_VANTAGE ) && SniperRecon_IsTracking( player ) )
		 {
			 entity bestTarget = SniperRecon_GetBestTarget( player )
			 if ( IsValid( bestTarget ) && bestTarget.IsPlayer() )
			 {
				 PingCommandExecuteEnemySpotted( bestTarget, -1 )
				 spottedEnemy = bestTarget
			 }
		 }
		else if ( IsValid( aaTarget ) )
		{
			PingCommandExecuteEnemySpotted( aaTarget, -1 )
			spottedEnemy = aaTarget
		}

		
	}

	bool canDoStandardPings      = true
	bool canUpdateDoubleTapTimer = true

	

		if( PlayerHasPassive( player, ePassives.PAS_TRACKING_VISION ) )
		{
			entity focusedWp = GetFocusedWaypointEnt()
			if ( !IsValid( focusedWp ) || Waypoint_GetPingTypeForWaypoint( focusedWp ) != ePingType.BLOODHOUND_WHITE_RAVEN )
			{
				entity ravenTarget = GetWhiteRavenPingTarget( player )
				if( IsValid( ravenTarget ) && ( canDoStandardPings ) )
				{
					vector pingOrigin = ravenTarget.GetOrigin() + <0,0,25>
					int pingType      = ePingType.BLOODHOUND_WHITE_RAVEN
					int ticketId = GetNewTicketID()
					PingCommandExecuteUsePrompt( pingType, pingOrigin, player, ticketId )
					DoLocalPingConfirm( pingOrigin, pingType, player, true )

					canDoStandardPings = false
				}
			}

		}


	
	if ( canDoStandardPings )
	{
		entity focusedWp = GetFocusedWaypointEnt()
		if ( IsValid( focusedWp ) && Waypoint_GetPingTypeForWaypoint( focusedWp ) == ePingType.ABILITY_ECHO_LOCATOR )
		{
			PingTraceResults tr = DoPingTrace( player )
			if ( tr.success )
			{
				float sinceLastPing   = (Time() - s_doubleTapTimer)
				float viewDeflection  = player.GetViewVector().Dot( s_lastPingDownViewVector )
				bool isOverRecentPing = sinceLastPing < 0.7 && viewDeflection > 0.999

				bool allowQuickPing      = !IsValid( spottedEnemy )
				PingCommandParams params = GetPingParamsForHitEnt( tr.hitEnt, player, tr )

				SetPendingNewPing( params.pingType, tr.endPos, params.hitEnt, allowQuickPing, CommsMenu_GetMenuForNewPing(player) )
				PingCommandQueueTrace()

				if ( !isOverRecentPing )
					CommsMenu_OpenMenuForNewPing( player, tr.endPos )

				canDoStandardPings = false
			}
		}
	}

	
	if ( canDoStandardPings )
	{
		entity focusedWp = GetFocusedWaypointEnt()
		if ( IsValid( focusedWp ) && !Waypoint_IsPOI( focusedWp ) && !IsWaypointCulledEmote( player, focusedWp ) )
		{
			SetPendingPingReply( focusedWp )

			if ( Waypoint_ShowPingWheel( focusedWp ) )
			{
				CommsMenu_OpenMenuForPingReply( player, focusedWp )
			}

			canDoStandardPings = false
		}
	}

	
	if ( canDoStandardPings )
	{
		entity ziplineEnt = GetZiplineUseEntity( player )

		if ( IsValid( ziplineEnt ) )
		{
			int pingType      =  ePingType.ZIPLINE

			if ( GetZiprailUseEntity( player ) != null )
				pingType = ePingType.ZIPRAIL

			vector pingOrigin = player.GetUsePromptPosition()
			entity pingEnt    = player.GetUsePromptEntity()

			int ticketId = GetNewTicketID()


				entity balloonProp = GetRedeployBalloonForHitEnt( ziplineEnt )
				if ( IsValid( balloonProp ) )
				{
					pingEnt   = balloonProp
					pingType = ePingType.REDEPLOY_BALLOON
				}


			PingCommandExecuteUsePrompt( pingType, pingOrigin, pingEnt, ticketId )
			DoLocalPingConfirm( pingOrigin, pingType, pingEnt, true )

			canDoStandardPings = false
		}
	}


	if( canDoStandardPings )
	{
		PerkPingInfo pingInfo = Perks_GetPerkPingInfo()
		if( IsValid( pingInfo.ent ) )
		{
			int pingType      = pingInfo.pingType
			entity pingEnt    = pingInfo.ent
			int ticketId = GetNewTicketID()

			vector pingPos = pingEnt.GetOrigin() + <0,0, pingInfo.originUpOffset>
			PingCommandExecuteUsePrompt( pingType, pingPos + <0,0,-72>, pingEnt, ticketId )
			DoLocalPingConfirm( pingPos, pingType, pingEnt, true )

			canDoStandardPings = false
		}
	}



	if( canDoStandardPings )
	{
		DeathBoxPingInfo pingInfo = DeathBoxInsight_GetCurrentPingInfo()
		if( IsValid( pingInfo.deathbox ) && IsValid( pingInfo.loot ) )
		{
			DoPlayerDefaultPingForLootEntity( player, pingInfo.loot, pingInfo.deathbox )
			canDoStandardPings = false
		}
	}

	if( canDoStandardPings )
	{
		entity pingEnt = UpgradeCore_GetHighlightedHarvester()
		if( IsValid( pingEnt ) )
		{
			int pingType = ePingType.UPGRADE_STATION
			int ticketId = GetNewTicketID()
			vector pingPos = pingEnt.GetOrigin() + <0,0, EVO_HARVESTER_ICON_UP_OFFSET>
			PingCommandExecuteUsePrompt( pingType, pingPos + <0,0,-72>, pingEnt, ticketId )
			DoLocalPingConfirm( pingPos, pingType, pingEnt, true )
			canDoStandardPings = false
		}
	}




















	
	if ( canDoStandardPings )
	{
		entity useEnt = GetPropSurvivalUseEntity( player )
		entity crosshairEnt = GetCrosshairEntity( player )
		if ( IsValid( useEnt ) && (!player.IsInputCommandHeld( IN_ZOOM ) || useEnt != player.GetUsePromptEntity()) )
		{
			DoPlayerDefaultPingForLootEntity( player, useEnt, null )
			canDoStandardPings = false
		}
		else if ( IsValid( crosshairEnt ) )
		{
			DoPlayerDefaultPingForLootEntity( player, crosshairEnt, null )
			canDoStandardPings = false
		}
	}

	float sinceLastPing   = (Time() - s_doubleTapTimer)
	float viewDeflection  = player.GetViewVector().Dot( s_lastPingDownViewVector )
	bool isOverRecentPing = sinceLastPing < 0.7 && viewDeflection > 0.999
	bool isDoubleTap      = (sinceLastPing < 0.35) && DoubleTapEnemyPingEnabled()

	
	if ( isDoubleTap && !IsValid( spottedEnemy ) ) 
	{
		PingTraceResults tr = DoPingTrace( player )
		
		if ( tr.success )
		{
			CancelLatestWaypoint( player )
			PingCommandQueueTrace()

			PingCommandExecuteQueued( ePingType.ENEMY_GENERAL, -1, 0 ) 
		}
		canDoStandardPings = false
	}

	
	if ( canDoStandardPings && !IsValid( spottedEnemy ) )
	{
		entity waypoint = GetFocusedWaypointEnt()
		if ( IsValid( waypoint ) && Waypoint_IsPOI( waypoint ) )
		{
			CancelLatestWaypoint( player )
			int ticketId = GetNewTicketID()
			int pingType = GetPingTypeFromPOIType( waypoint )
			PingCommandExecuteUsePrompt( pingType, waypoint.GetOrigin(), waypoint, ticketId )
			canDoStandardPings = false
		}
	}

	if ( canDoStandardPings )
	{
		PingTraceResults tr = DoPingTrace( player )
		if ( tr.success )
		{
			bool allowQuickPing      = !IsValid( spottedEnemy )
			PingCommandParams params = GetPingParamsForHitEnt( tr.hitEnt, player, tr )


			if ( params.pingType == ePingType.ZIPLINE || params.pingType == ePingType.ZIPRAIL )



			{
				Assert( player.HasZiplinePingInRange(), "Trying to ping a zipline but there isn't one in ping range! This is a script error" )

				vector pingPosition = player.GetZiplinePingPosition()
				int ticketId = GetNewTicketID()


					entity balloonProp = GetRedeployBalloonForHitEnt( params.hitEnt )
					if ( IsValid( balloonProp ) )
					{
						params.hitEnt   = balloonProp
						params.pingType = ePingType.REDEPLOY_BALLOON
					}


				PingCommandExecuteUsePrompt( params.pingType, pingPosition, params.hitEnt, ticketId )
				DoLocalPingConfirm( pingPosition, params.pingType, params.hitEnt, true )
			}

			else if ( params.pingType == ePingType.TRANSPORT_PORTAL_REMOTE )
			{
				params.pingType = ePingType.TRANSPORT_PORTAL_FRIENDLY

				vector pingPosition = params.hitEnt.GetOrigin()
				int ticketId = GetNewTicketID()

				PingCommandExecuteUsePrompt( params.pingType, pingPosition, params.hitEnt, ticketId )
				DoLocalPingConfirm( pingPosition, params.pingType, params.hitEnt, true )
			}

			else
			{
				
				if ( params.pingType == ePingType.PING_CAPTURE_OBJECTIVE_ATTACK || params.pingType == ePingType.PING_CAPTURE_OBJECTIVE_DEFEND )
				{
					if ( CaptureObjectivePing_GetStarterPingsArray().contains( params.hitEnt ) )
					{
						SetPendingPingReply( params.hitEnt )
						if ( Waypoint_ShowPingWheel( params.hitEnt ) )
							CommsMenu_OpenMenuForPingReply( player, params.hitEnt )

						return
					}
				}

				SetPendingNewPing( params.pingType, tr.endPos, params.hitEnt, allowQuickPing, CommsMenu_GetMenuForNewPing(player) )
				PingCommandQueueTrace()

				if ( !isOverRecentPing )
					CommsMenu_OpenMenuForNewPing( player, tr.endPos )
			}
		}
		else
		{

				if ( player.HasZiplinePingInRange() )
				{
					entity ziplineEnt = player.GetZiplinePingEntity();

					int pingType = ePingType.ZIPLINE;

						if ( IsZiprail( ziplineEnt ) )
						{
							pingType =  ePingType.ZIPRAIL;
						}

					vector pingPosition = player.GetZiplinePingPosition()
					int ticketId = GetNewTicketID()


						entity balloonProp = GetRedeployBalloonForHitEnt( ziplineEnt )
						if ( IsValid( balloonProp ) )
						{
							ziplineEnt   = balloonProp
							pingType = ePingType.REDEPLOY_BALLOON
						}

					PingCommandExecuteUsePrompt( pingType, pingPosition, ziplineEnt, ticketId )
					DoLocalPingConfirm( pingPosition, pingType, ziplineEnt, true )
				}

		}
	}

	if ( canUpdateDoubleTapTimer )
		s_doubleTapTimer = Time()

	s_lastPingDownViewVector = player.GetViewVector()
}




void function ExecutePendingPing( entity player )
{
	Assert( HasPendingPing() )

	if ( s_pendingPing.reply_waypoint != null )
	{
		ExecutePendingPingReply( player )
		return
	}

	PendingPing pp = s_pendingPing
	int ticketId   = GetNewTicketID()

	PingCommandExecuteQueued( pp.newPing_pingType, ticketId, pp.newPing_wheelIndex)
	DoLocalPingConfirm( pp.newPing_origin, pp.newPing_pingType, pp.newPing_pingedEnt, true )
	ClearPendingPing()
}




void function Ping_ExecutePendingNewPingWithOverride( int pingTypeOverride, int pingWheelType = 0 )
{
	entity player = GetLocalClientPlayer()
	if ( !IsValid( player ) )
		return
	if ( !HasPendingPing() )
		return

	PendingPing pp = s_pendingPing
	int ticketId   = GetNewTicketID()

	PingCommandExecuteQueued( pingTypeOverride, ticketId,  pingWheelType)
	DoLocalPingConfirm( pp.newPing_origin, pingTypeOverride, pp.newPing_pingedEnt, true )
	ClearPendingPing()
}




void function ExecutePendingPingReply( entity player )
{
	Assert( HasPendingPing() )

	PendingPing pp = s_pendingPing
	Assert( pp.reply_waypoint != null )

	entity wp = pp.reply_waypoint
	if ( IsValid( wp ) )
	{
		array<int> replies = GetReplyOptionsForWaypoint( player, wp )
		if ( (replies.len() > 0) && (replies[0] != ePingReply.BLANK) )
			Send_PingReply( player, wp, replies[0] )
	}

	ClearPendingPing()
}




entity function Ping_GetPendingPingReplyWaypoint()
{
	if ( !HasPendingPing() )
		return null

	return s_pendingPing.reply_waypoint
}




void function Ping_ExecutePendingPingReplyWithOverride( int pingReply )
{
	entity player = GetLocalClientPlayer()
	if ( !IsValid( player ) )
		return
	if ( !HasPendingPing() )
		return

	PendingPing pp = s_pendingPing
	entity wp      = pp.reply_waypoint
	if ( !IsValid( wp ) )
		return

	Send_PingReply( player, wp, pingReply )
	ClearPendingPing()
}




array<int> function GetReplyOptionsForWaypoint( entity player, entity wp )
{
	array<int> results

	if ( !IsValid( wp ) || !IsPingEnabledForPlayer( player ) )
		return results

	entity wpOwner = wp.GetOwner()
	bool areOwner  = (wpOwner == player)
	int wpType     = wp.GetWaypointType()
	int pingType   = Waypoint_GetPingTypeForWaypoint( wp )
	switch ( wpType )
	{
		case eWaypoint.PING_LOCATION:
		{
			if ( areOwner )
			{
				
				switch ( pingType )
				{
					case ePingType.ENEMY_SPECIFIC:
					case ePingType.ENEMY_REVIVING:

					case ePingType.ENEMY_HEALING_HEALTH:
					case ePingType.ENEMY_HEALING_SHIELD:

					case ePingType.ASH_PASSIVE_ID_ATTACKER:

					case ePingType.MAGGIE_WRECKING_BALL:
					case ePingType.ABILITY_MOBILE_SHIELD:
					case ePingType.ABILITY_CASTLE_WALL:

					case ePingType.BLOODHOUND_WHITE_RAVEN_TARGET_LOC:









					case ePingType.ABILITY_ECHO_LOCATOR:
					case ePingType.ENEMY_TETHERED:
						results.append( ePingReply.BLANK )
						break

					case ePingType.ABILITY_DRONEMEDIC:
					case ePingType.ABILITY_DOMESHIELD:
					case ePingType.ABILITY_WORMHOLE:
					case ePingType.ABILITY_JUMPPAD:



					case ePingType.ABILITY_SPACE_ELEVATOR:
					case ePingType.VOID_RING:
					case ePingType.OPENED_PHASE_BREACH:



						if ( wp.wp.haveConfirmed )
							results.append( ePingReply.BLANK )
						else
							results.append( ePingReply.OWNER_ANNOUNCE )
						break


					case ePingType.MARK_MY_LAST_DEATH_BOX:
						results.append( ePingReply.RECOVER_DEATHBOX )
						break







					case ePingType.THE_HUNT_AREA_HUNTER:
						results.append( ePingReply.JOIN )
						break

					case ePingType.THE_HUNT_AREA_PREY:
						results.append( ePingReply.JOIN )
						break

					default:
						results.append( ePingReply.OWNER_CANCEL )
				}
			}
			else
			{
				switch ( pingType )
				{
					case ePingType.ENEMY_SPECIFIC:
						results.append( ePingReply.OK )
						results.append( ePingReply.NEGATIVE )
						results.append( ePingReply.HOLD_ON )
						break
					case ePingType.ASH_PASSIVE_ID_ATTACKER:




						results.append( ePingReply.OK )
						break

					case ePingType.ABILITY_DRONEMEDIC:
					case ePingType.ABILITY_DOMESHIELD:
					case ePingType.ABILITY_WORMHOLE:
					case ePingType.ABILITY_JUMPPAD:
					case ePingType.ABILITY_BLACK_MARKET:




					case ePingType.ABILITY_SPACE_ELEVATOR:
					case ePingType.VOID_RING:
					case ePingType.OPENED_PHASE_BREACH:



						results.append( ePingReply.THANKS )
						break

					case ePingType.MAGGIE_WRECKING_BALL:
					case ePingType.VANTAGE_COMPANION:
					case ePingType.ABILITY_MOBILE_SHIELD:
					case ePingType.ABILITY_CASTLE_WALL:
					case ePingType.ABILITY_ECHO_LOCATOR:
					case ePingType.ENEMY_TETHERED:
						results.append( ePingReply.BLANK )
						break

					case ePingType.BLOODHOUND_WHITE_RAVEN:
					case ePingType.BLOODHOUND_WHITE_RAVEN_TARGET_LOC:






					case ePingType.RESPAWN_BANNER:
						results.append( ePingReply.RESPAWN_YES )
						break

					case ePingType.SELF_REVIVE:
						results.append( ePingReply.OK )
						break

					case ePingType.PING_MY_LAST_DEATH_BOX:

					case ePingType.I_GO:
					case ePingType.I_WATCHING:
					case ePingType.I_LOOTING:
					case ePingType.I_DEFENDING:

					case ePingType.WE_ATTACK:
					case ePingType.I_ULTIMATE:
					case ePingType.WE_FALLBACK:
					case ePingType.ENEMY_AUDIO:
					case ePingType.ENEMY_FIGHTING:
					case ePingType.DONT_REVIVE:
					case ePingType.WE_AVOID:
					case ePingType.WE_DEFEND:
					case ePingType.WE_ABILITY:
					case ePingType.WE_REGROUP:

					case ePingType.I_ATTACKING:
						if ( wp.wp.haveConfirmed )
							results.append( ePingReply.BLANK )
						results.append( ePingReply.JOIN )
						results.append( ePingReply.OK )
						results.append( ePingReply.NEGATIVE )
						results.append( ePingReply.HOLD_ON )
						break

					case ePingType.NEED_HEALTH:
						if ( wp.wp.haveConfirmed )
							results.append( ePingReply.BLANK )
						results.append( ePingReply.OK )
						results.append( ePingReply.I_CANNOT )
						break

					case ePingType.ENEMY_GENERAL:
						results.append( ePingReply.OK )
						results.append( ePingReply.NEGATIVE )
						results.append( ePingReply.HOLD_ON )
						break
					case ePingType.AREA_VISITED:
						if ( wp.wp.haveConfirmed )
							results.append( ePingReply.BLANK )
						results.append( ePingReply.OK )
						break

					case ePingType.BLEEDOUT:
						if ( wp.wp.haveConfirmed )
							results.append( ePingReply.BLANK )
						results.append( ePingReply.COMING_TO_HELP )
						results.append( ePingReply.NEGATIVE )
						results.append( ePingReply.I_CANNOT )
						break

					case ePingType.PING_CAPTURE_OBJECTIVE_DEFEND:
							results.append( ePingReply.CAPTURE_OBJECTIVE_PING_DEFEND )
						break

					case ePingType.PING_CAPTURE_OBJECTIVE_ATTACK:
							results.append( ePingReply.CAPTURE_OBJECTIVE_PING_ATTACK )
						break



















					default:
						if ( wp.wp.haveConfirmed )
							results.append( ePingReply.BLANK )
						results.append( ePingReply.OK )
						results.append( ePingReply.NEGATIVE )
						results.append( ePingReply.I_CANNOT )
						results.append( ePingReply.HOLD_ON )
				}
			}
		}
			break

		case eWaypoint.PING_LOOT:
		{
			if ( areOwner )
			{
				results.append( ePingReply.OWNER_CANCEL )
			}
			else
			{
				entity dibsPlayer = Waypoint_GetLootPingDibsPlayer( wp )
				if ( dibsPlayer == null )
					results.append( ePingReply.LOOT_DIBS )
				else if ( dibsPlayer == player )
					results.append( ePingReply.LOOT_UNDIBS )
				else
					results.append( ePingReply.BLANK )
			}
		}
			break

		case eWaypoint.BUTTON:
		case eWaypoint.OBJECTIVE_ENT:
		case eWaypoint.OBJECTIVE_POS:
		case eWaypoint.CUSTOM_TYPE:
			
			
			results.append( ePingReply.GENERAL_WAYPOINT_CALLOUT )
			break

		case eWaypoint.BASIC_LOCATION:
			switch ( pingType )
			{

				case ePingType.SPAWN_REGION:
					results.append( ePingReply.SPAWN_HERE )
					break


				case ePingType.SKYDIVE_LAUNCHER:
					results.append( ePingReply.SKYDIVE_LAUNCHER )
					break
			}
			break

		case eWaypoint.EMOTE_ICON:
			results.append( ePingReply.REPLY_HOLOSPRAY_LIKE )
			break


		case eWaypoint.CONTROL_OBJECTIVE:


		case eWaypoint.TREASUREHUNT_OBJECTIVE:




			switch ( pingType )
			{
				case ePingType.PING_CAPTURE_OBJECTIVE_DEFEND:
					results.append( ePingReply.CAPTURE_OBJECTIVE_PING_DEFEND )
					break
				case ePingType.PING_CAPTURE_OBJECTIVE_ATTACK:
					results.append( ePingReply.CAPTURE_OBJECTIVE_PING_ATTACK )
					break
			}
			break
	}

	return results
}




array<int> function Ping_GetOptionsForPendingReply( entity player )
{
	array<int> blank

	if ( !HasPendingPing() )
		return blank

	PendingPing pp = s_pendingPing
	entity wp      = pp.reply_waypoint
	if ( IsValid( wp ) )
	{
		array<int> results = GetReplyOptionsForWaypoint( player, wp )
		return results
	}

	return blank
}




const float QUICK_PING_PRESS_TIME = 0.5
void function OnPingUp( entity player )
{
	
	if ( false )
	{
		if ( HasPendingPing() )
		{
			float elapsed = (Time() - s_pendingPing.timeStamp)
			if ( (elapsed > QUICK_PING_PRESS_TIME) )
				return
		}

		if ( CommsMenu_HasValidSelection() )
			return
	}

	
	if ( Crafting_IsDispenserCraftingEnabled() && Crafting_IsPlayerCrafting() )
		return

	bool doMakeMenuCloseSound = true
	bool doDebounceLookStick  = false
	if ( HasPendingPing() )
	{
		if ( CommsMenu_HasValidSelection() )
		{
			CommsMenu_ExecuteSelection( eWheelInputType.NONE )
			doDebounceLookStick = true
			doMakeMenuCloseSound = false
		}
		else
		{
			
			

			float elapsed = (Time() - s_pendingPing.timeStamp)
			if ( s_pendingPing.allowQuickPing && (elapsed < QUICK_PING_PRESS_TIME) )
			{

				s_pendingPing.newPing_wheelIndex = 0 

				ExecutePendingPing( player )
				doMakeMenuCloseSound = false
			}
		}

		ClearPendingPing()
	}

	CommsMenu_Shutdown( doMakeMenuCloseSound )
	if ( doDebounceLookStick )
		player.SetLookStickDebounce()
}




bool function ThrottleClientPing()
{
	float time = Time()
	if ( time < file.nextSpecificPingTime )
	{
		file.specificPingCount++
		return true
	}

	if ( time - file.nextSpecificPingTime > 1.0 )
		file.specificPingCount = 0

	file.specificPingCount++
	file.nextSpecificPingTime = time + min( 0.02 * file.specificPingCount, 0.2 )

	return false
}




void function Ping_HandleSpecificPingCommand( entity player, string pingType )
{
	if ( !Ping_ShouldExecutePing( player ) )
		return

	int pingTypeEnum = ePingType._count;
	if ( pingType == "ENEMY" )
		pingTypeEnum = ePingType.ENEMY_GENERAL
	if ( pingType == "GOING" )
		pingTypeEnum = ePingType.I_GO
	if ( pingType == "LOOTING" )
		pingTypeEnum = ePingType.I_LOOTING
	if ( pingType == "DEFENDING" )
		pingTypeEnum = ePingType.WE_DEFEND
	if ( pingType == "WATCHING" )
		pingTypeEnum = ePingType.I_WATCHING
	if ( pingType == "AREA_VISITED" )
		pingTypeEnum = ePingType.AREA_VISITED
	if ( pingType == "REGROUP" )
		pingTypeEnum = ePingType.WE_REGROUP
	if ( pingType == "AVOID" )
		pingTypeEnum = ePingType.WE_AVOID
	if ( pingType == "ATTACK" )
		pingTypeEnum = ePingType.WE_ATTACK
	if ( pingType == "ENEMY_AUDIO" )
		pingTypeEnum = ePingType.ENEMY_AUDIO

	if ( pingTypeEnum == ePingType._count )
		return

	
	CommsMenu_Shutdown( false )

	if ( pingTypeEnum == ePingType.ENEMY_GENERAL )
	{
		if ( PlayerHasPassive(player, ePassives.PAS_VANTAGE ) && SniperRecon_IsTracking( player ) )
		{
			entity bestTarget = SniperRecon_GetBestTarget( player )
			if ( IsValid( bestTarget ) && bestTarget.IsPlayer() )
			{
				PingCommandExecuteEnemySpotted( bestTarget, -1 )
				PingCommandQueueTrace()
				return
			}
		}
	}

	PingTraceResults tr = DoPingTrace( player )
	if ( tr.success )
	{
		PingCommandParams params = GetPingParamsForHitEnt( tr.hitEnt, player, tr )
		SetPendingNewPing( params.pingType, tr.endPos, params.hitEnt, false, CommsMenu_GetMenuForNewPing(player) )
		PingCommandQueueTrace()
		Ping_ExecutePendingNewPingWithOverride( pingTypeEnum )
	}
}




void function Ping_HandleWaypointDelete( entity wp )
{
	if ( Ping_GetPendingPingReplyWaypoint() == wp )
		Ping_Interrupt()
}







bool function IsDoorScriptName( string scriptName )
{
	switch( scriptName )
	{
		case "survival_door_model":
		case "survival_door_plain":
		case "survival_door_sliding":
		case "survival_door_blockable":
		case "survival_door_code":
			return true
	}

	return false
}




entity function GetDoorForHitEnt( entity hitEnt )
{
	if ( IsDoor( hitEnt ) )
		return hitEnt

	entity parentEnt = hitEnt.GetParent()
	if ( IsValid( parentEnt ) && IsDoor( parentEnt ) )
		return parentEnt

	return null
}







bool function IsTrapName( string scriptName )
{
	switch( scriptName )
	{
		case DIRTY_BOMB_TARGETNAME:
		case "tesla_trap":
		case "tesla_trap_proxy":
		case SILENCE_TRACE_SCRIPTNAME:
		case TROPHY_SYSTEM_NAME:
		case TETHER_BLOCKER_SCRIPTNAME:
			return true
	}

	return false
}




entity function GetTrapForHitEnt( PingHitEntData hitEntData )
{
	if ( IsTrapName( hitEntData.scriptName ) )
		return hitEntData.hitEnt

	if ( hitEntData.isParentValid && IsTrapName( hitEntData.parentScriptName ) )
		return hitEntData.parentEnt

	return null
}







bool function IsSmokeName( string scriptName )
{
	switch( scriptName )
	{
		case BANGALORE_SMOKESCREEN_SCRIPTNAME:
		case SILENCE_TRACE_SCRIPTNAME:
			return true
	}

	return false
}




entity function GetSmokeForHitEnt( entity hitEnt )
{
	if ( IsSmokeName( hitEnt.GetScriptName() ) )
		return hitEnt

	entity parentEnt = hitEnt.GetParent()
	if ( IsValid( parentEnt ) && IsSmokeName( parentEnt.GetScriptName() ) )
		return parentEnt

	return null
}




bool function IsToxicSmokeName( string scriptName )
{
	switch( scriptName )
	{
		case POISON_SMOKESCREEN_SCRIPTNAME:
			return true
	}

	return false
}




entity function GetToxicSmokeForHitEnt( entity hitEnt )
{
	if ( IsToxicSmokeName( hitEnt.GetScriptName() ) )
		return hitEnt

	entity parentEnt = hitEnt.GetParent()
	if ( IsValid( parentEnt ) && IsToxicSmokeName( parentEnt.GetScriptName() ) )
		return parentEnt

	return null
}







bool function IsReviveShieldName( string scriptName )
{
	switch( scriptName )
	{
		case REVIVE_SHIELD_SCRIPTNAME:
			return true
	}

	return false
}




entity function GetReviveShieldForHitEnt( entity hitEnt )
{
	if ( IsReviveShieldName( hitEnt.GetScriptName() ) )
		return hitEnt

	entity parentEnt = hitEnt.GetParent()
	if ( IsValid( parentEnt ) && IsReviveShieldName( parentEnt.GetScriptName() ) )
		return parentEnt

	return null
}







entity function GetSurveyBeaconForHitEnt( PingHitEntData hitEntData )
{
	if ( SurveyBeacon_IsSurveyBeacon( hitEntData.hitEnt ) )
		return hitEntData.hitEnt

	if ( hitEntData.isParentValid && SurveyBeacon_IsSurveyBeacon( hitEntData.parentEnt ) )
		return hitEntData.parentEnt

	return null
}







bool function IsTeleporterName( string scriptName )
{
	switch( scriptName )
	{
		case PHASETUNNEL_BLOCKER_SCRIPTNAME:
		case PHASETUNNEL_PRE_BLOCKER_SCRIPTNAME:
			return true
	}
	return false
}




entity function GetHitEntForScriptName( PingHitEntData pingHitEnt, string targetName )
{
	if ( pingHitEnt.scriptName == targetName )
		return pingHitEnt.hitEnt

	if ( pingHitEnt.isParentValid && pingHitEnt.parentScriptName == targetName )
		return pingHitEnt.parentEnt

	return null
}

entity function GetHitEntForTargetName( PingHitEntData pingHitEnt, string targetName )
{
	if ( pingHitEnt.entTargetName == targetName )
		return pingHitEnt.hitEnt

	if ( pingHitEnt.isParentValid && pingHitEnt.parentTargetName == targetName )
		return pingHitEnt.hitEnt

	return null
}




entity function GetTeleporterForHitEnt( PingHitEntData pingHitEnt )
{
	if ( IsTeleporterName( pingHitEnt.scriptName ) )
		return pingHitEnt.hitEnt

	if ( pingHitEnt.isParentValid && IsTeleporterName( pingHitEnt.parentScriptName ) )
		return pingHitEnt.parentEnt

	return null
}







bool function IsGeyserName( string scriptName )
{
	switch( scriptName )
	{
		case GEYSER_PING_SCRIPT_NAME:
			return true
	}
	return false
}




entity function GetGeyserForHitEnt( entity hitEnt )
{
	if ( IsGeyserName( hitEnt.GetScriptName() ) )
		return hitEnt

	entity parentEnt = hitEnt.GetParent()
	if ( IsValid( parentEnt ) && IsGeyserName( parentEnt.GetScriptName() ) )
		return parentEnt

	return null
}







bool function IsJumpTowerName( string scriptName )
{
	switch( scriptName )
	{
		case JUMPTOWER_PING_NAME:
			return true
	}
	return false
}




entity function GetJumpTowerForHitEnt( entity hitEnt )
{
	if ( IsJumpTowerName( hitEnt.GetScriptName() ) )
		return hitEnt

	entity parentEnt = hitEnt.GetParent()
	if ( IsValid( parentEnt ) && IsJumpTowerName( parentEnt.GetScriptName() ) )
		return parentEnt

	return null
}







entity function GetDeathBoxFromFlyerForHitEnt( entity hitEnt )
{
	if ( !IsValid( hitEnt ) )
		return null


		if ( !(hitEnt instanceof C_DynamicProp) )
			return null

		if ( hitEnt.GetModelName() != FLYER_MODEL )
			return null

		array<entity> children = hitEnt.GetChildren()
		entity deathBoxFromFlyer = null

		if ( children.len() == 0 )
			return null

		foreach ( child in children )
		{
			if ( child.GetTargetName() != DEATH_BOX_TARGETNAME )
				continue

			deathBoxFromFlyer = child
			break
		}

		return deathBoxFromFlyer



	return null
}




entity function GetFlyerForHitEnt( entity hitEnt )
{
	if ( !IsValid( hitEnt ) )
		return null

	if ( IsFlyer( hitEnt ) )
		return hitEnt

	return null

}


























entity function GetLootDroneForHitEnt( entity hitEnt )
{
	if ( !IsValid( hitEnt ) )
		return null

	if ( hitEnt.GetModelName().tolower() == LOOT_DRONE_MODEL.tolower() )
		return hitEnt

	return null
}




bool function IsUpdatedCommsMenuActive()
{
	return GetCurrentPlaylistVarBool( "new_comms_enabled", true )
}

bool function MapPing_SnapToGround_Enabled()
{
	return GetCurrentPlaylistVarBool( "mapping_snatoground_enabled", true )
}

bool function MapPing_Modify_DistanceCheck_Enabled()
{
	return GetCurrentPlaylistVarBool( "mapping_distance_check_modifier_enabled", true )
}

float function MapPing_DistanceCheck_GetModifier()
{
	return GetCurrentPlaylistVarFloat( "mapping_distance_check_modifier", 0.5 )
}

float function MapPing_DistanceCheck_GetDistanceRange()
{
	return GetCurrentPlaylistVarFloat( "mapping_distance_check_range", 2000.0 )
}

int function GetUpdatedCommsMenuRevision()
{
	bool newCommsActive = IsUpdatedCommsMenuActive()
	int revisionActive = GetCurrentPlaylistVarInt("new_comms_revision", 4)

	if(newCommsActive)
	{
		switch( revisionActive )
		{
			case 1:
				return pingWheelRevision.UPDATED_REVISION_1
				break

			case 2:
				return pingWheelRevision.UPDATED_REVISION_2
				break

			case 3:
				return pingWheelRevision.UPDATED_REVISION_3
				break

			case 4:
				return pingWheelRevision.UPDATED_REVISION_4
				break

			case 5:
				return pingWheelRevision.UPDATED_REVISION_5
				break
		}
	}

	return pingWheelRevision.ORIGINAL
}





entity function GetBoxingRingForHitEnt( entity hitEnt )
{
	printt( "\t| Get boxing ring for hit ent called! Hit ent:", hitEnt, "hit ent is ping vol?", hitEnt.GetModelName() == "mdl/test/davis_test/pathfinder_tt_ring_shield.rmdl" )
	if ( !IsValid( hitEnt ) )
		return null
	
	string modelName = hitEnt.GetModelName()
	if ( hitEnt.GetModelName() == "mdl/test/davis_test/pathfinder_tt_ring_shield.rmdl" )
		return hitEnt

	return null
}




entity function GetChargePylonForHitEnt( entity hitEnt )
{
	if ( !IsValid( hitEnt ) )
		return null
	if ( hitEnt.GetModelName().tolower() == CHARGE_PYLON_PING_MODEL.tolower() )
		return hitEnt

	return null
}



entity function GetHitEntForModel( PingHitEntData hitEntData, string modelName )
{
	if( !IsValid( hitEntData.hitEnt ) )
		return null

	if ( hitEntData.entModel.tolower() == modelName.tolower() )
		return hitEntData.hitEnt

	return null
}




entity function GetHoverVehicleForHitEnt( entity hitEnt )
{
	if ( !IsValid( hitEnt ) )
		return null
	if ( EntIsHoverVehicle( hitEnt ) )
		return hitEnt

	entity parentEnt = hitEnt.GetParent()
	if ( IsValid( parentEnt ) && EntIsHoverVehicle( parentEnt ) )
		return parentEnt

	return null
}




entity function GetLootRollerForHitEnt( entity hitEnt )
{
	if ( !IsValid( hitEnt ) )
		return null

	if ( hitEnt.GetModelName().tolower() == LOOT_ROLLER_MODEL.tolower() )
		return hitEnt

	return null
}







entity function GetVaultPanelEntityForHitEnt( entity hitEnt )
{
	if ( !IsValid( hitEnt ) )
		return null

	if ( IsVaultPanel( hitEnt ) )
		return hitEnt

	if ( IsVaultDoor( hitEnt ) )
	{
		return GetVaultPanelFromDoor( hitEnt )
	}

	return null
}







entity function GetTrainForHitEnt( entity hitEnt, string scriptName )
{
	if ( !IsValid( hitEnt ) || !hitEnt.HasKey( "script_name" ) )
		return null

	if ( hitEnt.GetScriptName() == scriptName )
		return hitEnt

	return null
}







entity function GetBlackMarketForHitEnt( entity hitEnt )
{
	if ( !IsValid( hitEnt ) || !hitEnt.HasKey( "script_name" ) )
		return null

	if ( hitEnt.GetScriptName() == BLACK_MARKET_SCRIPTNAME )
		return hitEnt

	return null
}



entity function GetEchoLocatorForHitEnt( entity hitEnt )
{
	if ( !IsValid( hitEnt ) || !hitEnt.HasKey( "script_name" ) )
		return null

	if ( hitEnt.GetScriptName() == ECHO_LOCATOR_SCRIPT_NAME )
		return hitEnt

	return null
}





entity function GetCryptoSatelliteForHitEnt( entity hitEnt )
{
	if ( !IsValid( hitEnt ) )
		return null

	if ( !IsValid( hitEnt.GetParent() ) )
		return null

	
	hitEnt = hitEnt.GetParent()

	if ( !IsValid( hitEnt ) || !hitEnt.HasKey( "script_name" ) )
		return null
	if ( hitEnt.GetScriptName() == "crypto_tt_satellite_prop" )
		return hitEnt

	return null
}





entity function GetExplosiveHoldForHitEnt( entity hitEnt )
{
	if ( !IsValid( hitEnt ) )
		return null

	if ( hitEnt.GetModelName() == EXPLOSIVE_HOLD_PROXY )
		return hitEnt

	entity parentEnt = hitEnt.GetParent()
	if ( IsValid( parentEnt ) )
	{
		if ( parentEnt.GetModelName() == EXPLOSIVE_HOLD_PROXY )
			return parentEnt
		else if ( parentEnt.GetScriptName() == EXPLOSIVE_HOLD_PANEL_SCRIPTNAME )
			return parentEnt
	}

	return null
}




bool function EntIsADynamicProp( entity ent )
{
	if ( !IsValid( ent ) )
		return false





		if ( ent instanceof C_DynamicProp )
			return true

	return false
}




PingCommandParams function GetPingParamsForHitEnt( entity hitEnt, entity player, PingTraceResults tr )
{
	int defaultPingType = ePingType.WE_GO 
	int ms              = PlayerMatchState_GetFor( player )
	if ( (ms == ePlayerMatchState.SKYDIVE_PRELAUNCH) || (ms == ePlayerMatchState.SKYDIVE_FALLING) )
		defaultPingType = ePingType.WE_GO

	entity processedHitEnt = hitEnt

	PingHitEntData hitEntData

	hitEntData.isParentValid = false

	entity oldParent = hitEnt.GetParent()

	if ( IsValid( oldParent ) )
	{
		if ( oldParent.IsPlayer() || oldParent.IsNPC() )
		{
			processedHitEnt = oldParent
		}
		else
		{
			hitEntData.parentEnt = oldParent

			hitEntData.isParentValid = true
		}
	}

	entity newParent = processedHitEnt.GetParent()

	if( IsValid( newParent ) )
	{
		hitEntData.parentEnt = newParent

		hitEntData.isParentValid = true
	}

	if( hitEntData.isParentValid )
	{
		hitEntData.parentModel = hitEntData.parentEnt.GetModelName()

		hitEntData.parentScriptName = hitEntData.parentEnt.GetScriptName()

		hitEntData.parentTargetName = processedHitEnt.GetTargetName()
	}

	hitEntData.hitEnt = processedHitEnt

	hitEntData.scriptName = processedHitEnt.GetScriptName()

	hitEntData.entModel = processedHitEnt.GetModelName()

	hitEntData.entTargetName = processedHitEnt.GetTargetName()


	PingCommandParams result
	if ( !IsValid( processedHitEnt ) || processedHitEnt.IsWorld() )
	{
		
		if ( IsValid( tr.tr ) )
		{
			string lavaFlow = tr.tr.surfaceName

			if ( lavaFlow == LAVA_FLOW_SURFACE_NAME )
			{
				result.hitEnt = null
				result.pingType = ePingType.LAVA
				return result
			}
		}
		
		if ( PlayerHasPassive( player, ePassives.PAS_VALK ) )
		{
			if ( StatusEffect_HasSeverity( player, eStatusEffect.skyward_embark ) )
			{
				result.hitEnt = player
				result.pingType = ePingType.VALK_ULT_COME_HERE
				return result
			}
		}

			entity localViewPlayer = GetLocalViewPlayer()
			bool isCrypto          = PlayerHasPassive( localViewPlayer, ePassives.PAS_CRYPTO )

			bool activeCamera      = IsValid( localViewPlayer.p.cryptoActiveCamera )





			if ( isCrypto && activeCamera )



			{
				if ( ClApexScreens_PosInStaticBanner( tr.endPos ) )
				{
					int count = localViewPlayer.GetPlayerNetInt( "cameraNearbyEnemySquads" )
					if ( count <= 3 )
					{
						result.hitEnt = null
						result.pingType = ePingType.DRONE_PING_BANNER_0 + count
						return result
					}
					else
					{
						result.hitEnt = null
						result.pingType = ePingType.DRONE_PING_BANNER_MANY
						return result
					}
				}
			}

			if ( player.HasZiplinePingInRange() )
			{
				result.hitEnt = player.GetZiplinePingEntity()

				result.pingType = ePingType.ZIPLINE

				if ( IsZiprail( result.hitEnt ) )
				{
					result.pingType =  ePingType.ZIPRAIL
				}

				return result
			}


			entity transportPortal = TransportPortal_GetReceiverPlayerIsLookingAt( player )
			if ( IsValid( transportPortal ) )
			{
				result.hitEnt = transportPortal
				result.pingType = ePingType.TRANSPORT_PORTAL_REMOTE
				return result
			}




		result.hitEnt = null
		result.pingType = defaultPingType
		return result
	}

	int playerTeam = player.GetTeam()
	int hitEntTeam = processedHitEnt.GetTeam()
	bool hitEntIsEnemy = IsEnemyTeam( playerTeam, hitEntTeam )
	bool hitEntIsPlayer = processedHitEnt.IsPlayer()
	bool hitEntIsNPC = processedHitEnt.IsNPC()
	string hitEntScriptName = processedHitEnt.GetScriptName()

	
	{
		if ( (hitEntIsPlayer || hitEntIsNPC) && hitEntIsEnemy )
		{
			result.hitEnt = processedHitEnt
			if ( hitEntIsNPC && (processedHitEnt.GetAISettingsName() == "npc_frag_drone_treasure_tick") )
			{

					printt("RESULT: " + result.hitEnt.GetScriptName())
					if ( result.hitEnt.GetScriptName() == GOLDEN_HORSE_LOOT_TICK_SCRIPT_NAME )
					{
						result.pingType = ePingType.LOOT_TICK_GH
						return result
					}


				result.pingType = ePingType.ENEMY_LOOTSOURCE
				return result
			}
			else
			{

					if ( hitEntIsPlayer )
					{
						entity hoverVehicle = HoverVehicle_GetVehicleOccupiedByPlayer( processedHitEnt )
						if ( IsValid( hoverVehicle ) )
						{
							result.hitEnt = hoverVehicle
							result.pingType = ePingType.HOVERVEHICLE_ENEMY
							return result
						}
					}


				if ( hitEntIsPlayer )
				{
					int healthKitType = processedHitEnt.GetPlayerNetInt( "healingKitTypeCurrentlyBeingUsed" )
					bool isHealing = healthKitType >= 0

					if ( processedHitEnt.ContextAction_IsReviving() || processedHitEnt.ContextAction_IsBeingRevived() )
					{
						result.pingType = ePingType.ENEMY_REVIVING
					}

					else if ( isHealing )
					{
						if ( Consumable_IsHealthItem( healthKitType ) )
							result.pingType = ePingType.ENEMY_HEALING_HEALTH
						else if ( Consumable_IsShieldItem( healthKitType ) )
							result.pingType = ePingType.ENEMY_HEALING_SHIELD
						else
							result.pingType = ePingType.ENEMY_SPECIFIC

					}

					else if ( processedHitEnt.Player_IsSkywardLaunching() )
					{
						result.pingType = ePingType.VALK_ULT_ENEMY_TAKING_OFF
					}
					else if ( SniperRecon_IsTracking( player ) )
					{
						entity bestTarget = SniperRecon_GetBestTarget( player )
						if ( IsValid( bestTarget ) )
						{
							result.hitEnt = bestTarget
							result.pingType = ePingType.VANTAGE_SPOTS_ENEMY
						}
					}
					else
					{
						result.pingType = ePingType.ENEMY_SPECIFIC
					}
					return result
				}
			}

		}

		if ( processedHitEnt.IsPlayerDecoy() && hitEntIsEnemy )
		{
			result.hitEnt = processedHitEnt
			result.pingType = ePingType.ENEMY_SPECIFIC
			return result
		}


		if ( hitEntIsNPC && ( hitEntScriptName == LOOT_MARVIN_SCRIPTNAME ) || hitEntScriptName == STORY_MARVIN_SCRIPTNAME )
		{
			result.hitEnt = processedHitEnt
			if ( hitEntScriptName == STORY_MARVIN_SCRIPTNAME )
				result.pingType = ePingType.STORY_MARVIN
			else
				result.pingType = ePingType.LOOT_MARVIN

			return result
		}

	}


	{
		if ( hitEntData.entModel == IMC_ARMORY_PROXY_NAME )
		{
			result.hitEnt = processedHitEnt
			result.pingType = ePingType.PING_IMC_ARMORY_EXT
			return result
		}

		entity shackObject = GetHitEntForScriptName( hitEntData, IMC_ARMORY_PANEL_SCRIPTNAME )
		if( IsValid( shackObject ) )
		{
			result.hitEnt = shackObject
			
			result.pingType = ePingType.PING_PANEL
			return result
		}
	}


	{
		if( hitEntScriptName.find( PHASEDRIVER_PANEL_SCRIPTNAME ) >= 0 )
		{
			if( hitEntScriptName == PHASEDRIVER_PANEL_COOLDOWN_SCRIPTNAME )
			{
				result.pingType = ePingType.PING_PANEL_COOLDOWN
			}
			else
			{
				result.pingType = ePingType.PING_PANEL
			}

			result.hitEnt = processedHitEnt
			return result
		}
	}

	{
		if( hitEntScriptName.find( GENERIC_PING_PANEL_SCRIPTNAME ) >= 0 )
		{
			if ( hitEntScriptName == GENERIC_PING_PANEL_SCRIPTNAME_COOLDOWN )
			{
				result.pingType = ePingType.PING_PANEL_COOLDOWN
			}
			else if ( hitEntScriptName == GENERIC_PING_PANEL_SCRIPTNAME_INACTIVE )
			{
				result.pingType = ePingType.PING_PANEL_INACTIVE
			}
			else
			{
				result.pingType = ePingType.PING_PANEL
			}

			result.hitEnt = processedHitEnt
			return result
		}
	}
	
	{
		entity lootBin = GetHitEntForScriptName( hitEntData, LOOT_BIN_SCRIPTNAME ) 
		if ( IsValid( lootBin ) )
		{
			result.hitEnt = lootBin

			if( Perk_MunitionsBox_IsEntMunitionsBox( lootBin ) )
			{
				result.pingType = ePingType.MUNITIONS_BOX
			}
			else if ( SupportBin_EntityIsSupportBin( lootBin ) )
			{
				result.pingType = ePingType.SUPPORT_BOX
			}
			else

			if ( LootBin_HasSecretCompartment( lootBin ) )
				result.pingType = ePingType.LOOT_BIN_EXTENDED
			else
				result.pingType = ePingType.LOOT_BIN
			return result
		}
	}


		entity nextZoneBeacon = Perk_NextZoneSurveyBeacon_GetNextZoneBeaconForEntHit( processedHitEnt )
		if( IsValid( nextZoneBeacon ) )
		{
			result.hitEnt = nextZoneBeacon
			result.pingType = ePingType.ENCRYPTED_CONSOLE
			return result
		}



	
	{
		entity doorEnt = GetDoorForHitEnt( processedHitEnt )
		if ( IsValid( doorEnt ) )
		{

				if ( IsVaultDoor( doorEnt ) )
				{
					entity vaultPanel = GetVaultPanelFromDoor( doorEnt )

					UniqueVaultData vaultData

					if ( IsValid( vaultPanel ) )
					{
						result.hitEnt = vaultPanel
 						vaultData = GetUniqueVaultData( vaultPanel )
					}
					else
						result.hitEnt = doorEnt

					result.pingType = vaultData.pingVault

					entity playerWithKey = VaultPanel_GetTeammateWithKey( playerTeam )
					if ( IsValid( playerWithKey ) )
					{
						if ( playerWithKey == player )
							result.pingType = vaultData.pingVaultHasKeySelf
						else
							result.pingType = vaultData.pingVaultHasKeySquad
					}

					if ( IsDoorOpen( doorEnt ) )
						result.pingType = ePingType.LOOT_VAULT_OPEN

					return result
				}


			if( IsReinforced( doorEnt ) )
			{
				result.hitEnt = doorEnt
				result.pingType = ( IsDoorOpen( doorEnt ) ? ePingType.ABILITY_BARRICADE_OPEN : ePingType.ABILITY_BARRICADE )
				return result
			}

			result.hitEnt = doorEnt
			result.pingType = ( IsDoorOpen( doorEnt ) ? ePingType.DOOR_OPEN : ePingType.DOOR )
			return result
		}
	}

	{
		entity doorEnt = GetHitEntForTargetName( hitEntData, PASSIVE_REINFORCE_REBUILT_DOOR_SCRIPT_NAME )
		if( IsValid( doorEnt ) )
		{
			result.hitEnt = doorEnt
			result.pingType = ePingType.ABILITY_BARRICADE
			return result
		}

	}

	{
		entity spikesEnt = GetHitEntForTargetName( hitEntData, SPIKE_STRIP_CORE_SPIKE_NAME )
		if( IsValid( spikesEnt ) )
		{
			result.hitEnt = spikesEnt
			result.pingType = ePingType.ABILITY_PIERCING_SPIKES
			return result
		}

	}

	{
		entity wallEnt = GetHitEntForTargetName( hitEntData, FERRO_WALL_SEGMENT_TARGET_NAME )
		if( IsValid( wallEnt ) )
		{
			result.hitEnt = wallEnt
			result.pingType = ePingType.ABILITY_DARK_VEIL
			return result
		}
	}

	
	{
		entity trapEnt = GetTrapForHitEnt( hitEntData )
		if ( IsValid( trapEnt ) )
		{
			result.hitEnt = trapEnt
			int team = trapEnt.GetTeam()
			if ( team == TEAM_UNASSIGNED )
			{
				entity owner = trapEnt.GetOwner()
				if ( IsValid( owner ) )
					team = owner.GetTeam()
			}

			switch( hitEntData.scriptName )
			{
				case "tesla_trap":
				case "tesla_trap_proxy":
					result.pingType = IsEnemyTeam( playerTeam, team ) ? ePingType.ENEMY_TESLA_TRAP : ePingType.NEUTRAL_FENCE
					break

				case TROPHY_SYSTEM_NAME:
					result.pingType = IsEnemyTeam( playerTeam, team ) ? ePingType.ENEMY_TROPHY_SYSTEM : ePingType.NEUTRAL_TROPHY_SYSTEM
					break

				case DIRTY_BOMB_TARGETNAME:
				case TETHER_BLOCKER_SCRIPTNAME:
					result.pingType = IsEnemyTeam( playerTeam, team ) ? ePingType.ENEMY_TRAP : ePingType.FRIENDLY_TRAP
					break

				case SILENCE_TRACE_SCRIPTNAME:
					result.pingType = IsEnemyTeam( playerTeam, team ) ? ePingType.ENEMY_SILENCE_BOMB : ePingType.FRIENDLY_TRAP
					break

				default:
					result.pingType = IsEnemyTeam( playerTeam, team ) ? ePingType.ENEMY_TRAP : ePingType.LOCATION
					break
			}

			return result
		}
	}

	
	{
		entity smokeEnt = GetSmokeForHitEnt( processedHitEnt )
		if ( IsValid( smokeEnt ) )
		{
			result.hitEnt = smokeEnt
			result.pingType = IsEnemyTeam( playerTeam, smokeEnt.GetTeam() ) ? ePingType.ENEMY_SMOKE : ePingType.LOCATION
			return result
		}
	}

	
	{
		entity toxicSmokeEnt = GetToxicSmokeForHitEnt( processedHitEnt )
		if ( IsValid( toxicSmokeEnt ) )
		{
			result.hitEnt = toxicSmokeEnt
			result.pingType = IsEnemyTeam( playerTeam, toxicSmokeEnt.GetTeam() ) ? ePingType.TOXIC_GAS : ePingType.LOCATION
			return result
		}
	}

	
	{
		entity shieldEnt = GetHitEntForScriptName( hitEntData, BUBBLE_SHIELD_SCRIPTNAME ) 
		if ( IsValid( shieldEnt ) )
		{
			result.hitEnt = shieldEnt
			result.pingType = IsEnemyTeam( playerTeam, shieldEnt.GetTeam() ) ? ePingType.ENEMY_SHIELD : ePingType.LOCATION 
			return result
		}
	}

	
	{
		entity reviveShieldEnt = GetHitEntForScriptName( hitEntData, REVIVE_SHIELD_SCRIPTNAME )
		if ( IsValid( reviveShieldEnt ) )
		{
			result.hitEnt = reviveShieldEnt
			result.pingType = IsEnemyTeam( playerTeam, reviveShieldEnt.GetTeam() ) ? ePingType.ENEMY_REVIVING : ePingType.LOCATION
			return result
		}
	}

	
	{
		entity podEnt = GetHitEntForScriptName( hitEntData, CARE_PACKAGE_SCRIPTNAME )
		if ( IsValid( podEnt ) )
		{
			result.hitEnt = podEnt
			result.pingType = ePingType.CAREPACKAGE
			return result
		}
	}

	
	{
		entity beaconEnt = GetSurveyBeaconForHitEnt( hitEntData )
		if ( IsValid( beaconEnt ) )
		{
			result.hitEnt = beaconEnt
			result.pingType = ePingType.SURVEYBEACON
			return result
		}
	}

	
	{
		entity tpEnt = GetTeleporterForHitEnt( hitEntData )
		if ( IsValid( tpEnt ) )
		{
			result.hitEnt = tpEnt
			result.pingType = IsEnemyTeam( playerTeam, tpEnt.GetTeam() ) ? ePingType.ENEMY_TELEPORTER : ePingType.LOCATION
			return result
		}
	}

	
	{
		entity respawnEnt = GetHitEntForTargetName( hitEntData, RESPAWN_CHAMBER_TARGETNAME )

		if ( IsValid( respawnEnt ) )
		{
			result.hitEnt = respawnEnt
			result.pingType = ePingType.RESPAWN_STATION
			return result
		}
	}

	
	{
		entity healDroneEnt = GetHitEntForScriptName( hitEntData, DEPLOYABLE_MEDIC_SCRIPT_NAME )

		if ( IsValid( healDroneEnt ) )
		{
			result.hitEnt = healDroneEnt
			result.pingType = ePingType.DEPLOYABLE_MEDIC
			return result
		}
	}

	
	{ 
		entity respawnEnt = GetHitEntForTargetName( hitEntData, MOBILE_RESPAWN_BEACON_TARGETNAME )
		if ( IsValid( respawnEnt ) )
		{
			result.hitEnt = respawnEnt
			result.pingType = ePingType.RESPAWN_MOBILE
			return result
		}
	}














		{
			if ( hitEntScriptName == HARVESTER_SCRIPTNAME )
			{
				result.hitEnt = processedHitEnt
				result.pingType = ePingType.PING_MATERIALS
				return result
			}
			else if ( hitEntScriptName == WORKBENCH_CLUSTER_SCRIPTNAME )
			{
				if ( Crafting_IsDispenserCraftingEnabled() )
				{
					int notifyType = Dispensers_GetReplicatorStateForPlayer( player, processedHitEnt )
					switch( notifyType )
					{
						case eCrafting_Dispenser_StateType.NO_ONE_HAS_USED:
							result.hitEnt = processedHitEnt
							result.pingType = ePingType.PING_REPLICATOR_NOONE_USED
							return result
						case eCrafting_Dispenser_StateType.ALL_USED:
							result.hitEnt = processedHitEnt
							result.pingType = ePingType.PING_REPLICATOR_ALL_USED
							return result
						case eCrafting_Dispenser_StateType.PLAYER_HAS_USED:
							result.hitEnt = processedHitEnt
							result.pingType = ePingType.PING_REPLICATOR_PLAYER_USED
							return result
						case eCrafting_Dispenser_StateType.TEAMMATE_HAS_USED:
							result.hitEnt = processedHitEnt
							result.pingType = ePingType.PING_REPLICATOR_TEAMMATE_USED
							return result
						default:
							result.hitEnt = processedHitEnt
							result.pingType = ePingType.PING_REPLICATOR
							return result
					}
				}
				else
				{
					result.hitEnt = processedHitEnt
					result.pingType = ePingType.PING_REPLICATOR
					return result
				}
			}
			else if ( hitEntScriptName == WORKBENCH_CLUSTER_AIRDROPPED_SCRIPTNAME )
			{
				if ( Crafting_IsDispenserCraftingEnabled() )
				{
					result.hitEnt = processedHitEnt
					result.pingType = ePingType.PING_REPLICATOR_DISPENSER_INCOMING
					return result
				}
				else
				{
					result.hitEnt = processedHitEnt
					result.pingType = ePingType.PING_REPLICATOR_INCOMING
					return result
				}
			}








		}



		{
			if ( hitEntScriptName == UPGRADE_CORE_CONSOLE_SCRIPT_NAME )
			{
				result.hitEnt = processedHitEnt
				result.pingType = ePingType.UPGRADE_STATION
				return result
			}
		}


	
	{
		entity dropship = GetHitEntForTargetName( hitEntData, RESPAWN_DROPSHIP_TARGETNAME )
		if ( IsValid( dropship ) )
		{
			result.hitEnt = dropship
			result.pingType = ePingType.RESPAWN_DROPSHIP
			return result
		}
	}
	

		{
			entity dropship = GetHitEntForTargetName( hitEntData, EVAC_DROPSHIP_TARGETNAME )
			if ( IsValid( dropship ) )
			{
				result.hitEnt = dropship
				result.pingType = ePingType.EVAC_DROPSHIP
				return result
			}
		}














	
	{
		entity deathBox = GetHitEntForTargetName( hitEntData, DEATH_BOX_TARGETNAME )
		if ( IsValid( deathBox ) )
		{
			result.hitEnt = deathBox
			result.pingType = ePingType.DEATH_BOX
			return result
		}
	}

	{
		entity hoverTank = GetHitEntForTargetName( hitEntData, "hover_tank" )
		if ( IsValid( hoverTank ) )
		{
			result.hitEnt = hoverTank
			result.pingType = ePingType.HOVERTANK
			return result
		}
	}

	{
		entity jumpTower = GetHitEntForScriptName( hitEntData, JUMPTOWER_PING_NAME )
		if ( IsValid( jumpTower ) )
		{
			result.hitEnt = jumpTower
			result.pingType = ePingType.JUMPTOWER
			return result
		}
	}

	{
		entity geyser = GetHitEntForScriptName( hitEntData, GEYSER_PING_SCRIPT_NAME )
		if ( IsValid( geyser ) )
		{
			result.hitEnt = geyser
			result.pingType = ePingType.GEYSER
			return result
		}
	}

	{
		entity jumpPad = GetHitEntForScriptName( hitEntData, JUMP_PAD_SCRIPTNAME )
		if ( !IsValid( jumpPad ) )
		{
			jumpPad = GetHitEntForScriptName( hitEntData, JUMP_PAD_NEUTRAL_SCRIPTNAME )
		}
		if ( IsValid( jumpPad ) )
		{
			result.hitEnt = jumpPad
			result.pingType = ePingType.JUMP_PAD
			return result
		}
	}

	{
		entity skydiveLauncher = GetHitEntForTargetName( hitEntData, SKYDIVE_LAUNCHER_TARGETNAME )
		if ( IsValid( skydiveLauncher ) )
		{
			result.hitEnt = skydiveLauncher
			result.pingType = ePingType.SKYDIVE_LAUNCHER
			return result
		}
	}


	{
		
		entity ziprailLauncher = GetHitEntForScriptName( hitEntData, "ziprail_launcher_prop" )
		if ( IsValid ( ziprailLauncher ) )
		{









				result.hitEnt = hitEnt

			result.pingType = ePingType.JUMP_PAD
			return result
		}
	}



	{
		entity shell = GetHitEntForTargetName( hitEntData, REV_SHELL_TARGETNAME )
		if ( IsValid( shell ) )
		{
			result.hitEnt = shell
			result.pingType = ePingType.REV_SHELL
			return result
		}

	}



		{
			entity huntDataPad = GetHitEntForTargetName( hitEntData, HUNT_DATAPAD_TARGETNAME )
			if ( IsValid( huntDataPad ) )
			{
				result.hitEnt = huntDataPad
				result.pingType = ePingType.THE_HUNT_ITEM
				return result
			}
		}



	{
		entity drone = GetHitEntForTargetName( hitEntData, CRYPTO_DRONE_TARGETNAME )
		if ( IsValid( drone ) )
		{
			result.hitEnt = drone
			result.pingType = ePingType.CRYPTO_DRONE
			return result
		}
	}

	{
		entity companion = GetHitEntForScriptName( hitEntData, VANTAGE_COMPANION_SCRIPTNAME )
		if ( IsValid( companion ) )
		{
			result.hitEnt = companion
			result.pingType = IsEnemyTeam( playerTeam, companion.GetTeam() ) ? ePingType.ENEMY_VANTAGE_COMPANION : ePingType.VANTAGE_COMPANION
			return result
		}
	}

	{
		entity wall = GetHitEntForTargetName( hitEntData, BASE_WALL_SCRIPT_NAME )
		if ( IsValid( wall ) )
		{
			int team = wall.GetTeam()
			if ( team == TEAM_UNASSIGNED )
			{
				entity owner = wall.GetOwner()
				if ( IsValid( owner ) )
					team = owner.GetTeam()
			}

			result.hitEnt = wall
			result.pingType = ePingType.RAMPART_WALL
			return result
		}
	}

	{
		entity blackhole = GetHitEntForScriptName( hitEntData, BLACKHOLE_PROP_SCRIPTNAME )
		if ( IsValid( blackhole ) )
		{
			int team = blackhole.GetTeam()
			if ( team == TEAM_UNASSIGNED )
			{
				entity owner = blackhole.GetOwner()
				if ( IsValid( owner ) )
					team = owner.GetTeam()
			}

			result.hitEnt = blackhole
			result.pingType = ePingType.ABILITY_BLACK_HOLE
			return result
		}
	}
	{
		entity spaceElevator = GetHitEntForScriptName( hitEntData, SPACE_ELEVATOR_SCRIPTNAME )
		if ( IsValid( spaceElevator ) )
		{
			int team = spaceElevator.GetTeam()
			if ( team == TEAM_UNASSIGNED )
			{
				entity owner = spaceElevator.GetOwner()
				if ( IsValid( owner ) )
					team = owner.GetTeam()
			}

			result.hitEnt = spaceElevator
			result.pingType = ePingType.ABILITY_SPACE_ELEVATOR
			return result
		}
	}

	{
		entity turret = GetHitEntForTargetName( hitEntData, MOUNTED_TURRET_PLACEABLE_SCRIPT_NAME )
		if ( IsValid( turret ) )
		{
			int team = turret.GetTeam()
			if ( team == TEAM_UNASSIGNED )
			{
				entity owner = turret.GetOwner()
				if ( IsValid( owner ) )
					team = owner.GetTeam()
			}

			result.hitEnt = turret
			result.pingType = ePingType.RAMPART_TURRET
			return result
		}
	}

	{
		entity totem = GetHitEntForTargetName( hitEntData, DEATH_TOTEM_TARGETNAME )
		if ( IsValid( totem ) )
		{
			result.hitEnt = totem
			result.pingType = ePingType.DEATH_TOTEM
			return result
		}
	}


	{ 
		entity chasePortal = GetHitEntForScriptName( hitEntData, TRANSPORT_PORTAL_ALLY_PORTAL_SCRIPTNAME )
		if ( IsValid( chasePortal ) )
		{
			result.pingType = IsFriendlyTeam( playerTeam, chasePortal.GetTeam() ) ? ePingType.CHASE_PORTAL_FRIENDLY : ePingType.CHASE_PORTAL_ENEMY
			result.hitEnt = chasePortal
			return result
		}
	}
	{ 
		entity receiver = GetHitEntForScriptName( hitEntData, TRANSPORT_PORTAL_RECEIVER_SCRIPTNAME )
		if ( IsValid( receiver ) )
		{
			result.pingType = IsFriendlyTeam( receiver.GetTeam(), playerTeam ) ? ePingType.TRANSPORT_PORTAL_FRIENDLY : ePingType.TRANSPORT_PORTAL_ENEMY
			result.hitEnt = receiver

			return result
		}
	}
	{ 
		entity translocator = GetHitEntForScriptName( hitEntData, TRANSPORT_PORTAL_TRANSLOCATOR_TRACE_BLOCKER_SCRIPTNAME )
		if ( IsValid( translocator ) )
		{
			result.pingType = IsFriendlyTeam( translocator.GetTeam(), playerTeam ) ? ePingType.TRANSPORT_PORTAL_FRIENDLY : ePingType.TRANSPORT_PORTAL_ENEMY
			result.hitEnt = translocator.GetOwner()

			return result
		}
	}
	{ 
		entity phaseDoor = GetHitEntForScriptName( hitEntData, PHASE_DOOR_ROOT_ENT_SCRIPTNAME )
		if ( !IsValid( phaseDoor ) )
		{
			phaseDoor = GetHitEntForScriptName( hitEntData, PHASE_DOOR_WARMUP_ENT_SCRIPTNAME )
		}
		if ( IsValid( phaseDoor ) )
		{
			result.pingType = ePingType.PHASE_DOOR
			result.hitEnt = phaseDoor

			return result
		}
	}



	bool halloweenMode = false

		halloweenMode = GameModeVariant_IsActive( eGameModeVariants.SURVIVAL_SHADOW_ARMY )




	if ( halloweenMode )
	{
		entity lootCreepInfected = GetHitEntForTargetName( hitEntData, "loot_creep_infected" )
		if ( IsValid( lootCreepInfected ) )
		{
			result.hitEnt = lootCreepInfected
			result.pingType = ePingType.LOOT_CREEP_INFECTED
			return result
		}

		entity lootCreepSpider = GetHitEntForTargetName( hitEntData, "loot_creep_spider" )
		if ( IsValid( lootCreepSpider ) )
		{
			result.hitEnt   = lootCreepSpider
			result.pingType = ePingType.LOOT_CREEP_SPIDER
			return result
		}
	}


	{
		entity totemEnt = GetHitEntForModel( hitEntData, "mdl/props/revenant_totem/revenant_totem.rmdl" )
		if ( IsValid( totemEnt ) )
		{
			result.hitEnt = totemEnt
			result.pingType = ePingType.DEATH_TOTEM
			return result
		}
	}

	{ 
		if ( GetCurrentPlaylistVarInt( "enableFlyers", 1 ) == 1 )
		{
			entity flyer = GetFlyerForHitEnt( processedHitEnt )
			if ( IsValid( flyer ) )
			{
				result.hitEnt = flyer
				if ( IsCagedFlyer( flyer ) ) 
				{
					result.pingType = ePingType.FLYER_CAGED
				}
				else
				{
					result.pingType = ePingType.FLYER
				}
				return result
			}
		}
	}

	{ 
	    if ( IsProwler( processedHitEnt ) )
		{
			result.hitEnt   = processedHitEnt
			result.pingType = ePingType.PING_PROWLER
			return result
		}


			entity den = GetProwlerDenForHitEnt( processedHitEnt )
			if ( IsValid( den ) )
			{
				result.hitEnt   = processedHitEnt
				result.pingType = den.GetScriptName() == PROWLER_DEN_SCRIPT_NAME ? ePingType.PING_PROWLER_DEN : ePingType.PING_PROWLER_DEN_EMPTY
				return result
			}

	}

	{ 
		if ( IsSpider( processedHitEnt ) )
		{
			result.hitEnt   = processedHitEnt
			result.pingType = ePingType.PING_SPIDER
			return result
		}


			entity eggs = GetHitEntForScriptName( hitEntData, "prop_spider_egg" )
			if ( IsValid( eggs ) )
			{
				result.hitEnt   = processedHitEnt
				result.pingType = ePingType.PING_SPIDER_EGGS
				return result
			}
			entity hatchedEggs = GetHitEntForScriptName( hitEntData, "script_ai_spider_egg_hatched" )
			if ( IsValid( hatchedEggs ) )
			{
				result.hitEnt   = processedHitEnt
				result.pingType = ePingType.PING_SPIDER_EGGS_HATCHED
				return result
			}

	}



























	{ 
		entity drone = GetHitEntForModel( hitEntData, LOOT_DRONE_MODEL )
		if ( IsValid( drone ) )
		{
			printf( "LootDronePingDebug: Pinged a Loot Drone" )
			result.hitEnt = drone
			result.pingType = ePingType.LOOT_DRONE

			return result
		}
	}

	{ 
		entity roller = GetHitEntForModel( hitEntData, LOOT_ROLLER_MODEL )
		if ( IsValid( roller ) )
		{
			entity drone = roller.GetParent()

			if ( IsValid( drone ) )
			{
				printf( "LootDronePingDebug: Pinged a parented Loot Roller. Returning Loot Drone" )
				result.hitEnt = drone
				result.pingType = ePingType.LOOT_DRONE
			}
			else
			{
				printf( "LootDronePingDebug: Pinged an unparented Loot Roller." )
				result.hitEnt = roller
				result.pingType = ePingType.LOOT_ROLLER
			}
			return result
		}
	}


		{
			entity vaultPanel = GetVaultPanelEntityForHitEnt( processedHitEnt )
			if ( IsValid( vaultPanel ) )
			{
				UniqueVaultData vaultData = GetUniqueVaultData( vaultPanel )

				string playerWithKey = GetNameOfTeammateWithVaultKey( player.GetTeam() )
				if ( playerWithKey != "" )
				{
					if ( playerWithKey == player.GetPlayerName() )
						result.pingType = vaultData.pingVaultHasKeySelf
					else
						result.pingType = vaultData.pingVaultHasKeySquad
				}
				else
					result.pingType = vaultData.pingVault

				result.hitEnt = vaultPanel

				return result
			}
		}



		{
			entity vaultDoor = GetVaultDoorForHitEnt( processedHitEnt )
			if ( IsValid( vaultDoor ) )
			{
				entity panel = GetVaultPanelFromDoor( vaultDoor )
				if ( IsVaultPanel( panel) && IsVaultPanelLocked( panel ) )
				{
					string playerWithKey = GetNameOfTeammateWithVaultKey( player.GetTeam() )
					if ( playerWithKey != "" )
					{
						if ( playerWithKey == player.GetPlayerName() )
							result.pingType = ePingType.SHIP_VAULT_HAS_KEY_SELF
						else
							result.pingType = ePingType.SHIP_VAULT_HAS_KEY_SQUAD
					}
					else
						result.pingType = ePingType.SHIP_VAULT

					result.hitEnt = vaultDoor
				}
				else
				{
					result.pingType = ePingType.DOOR_OPEN
					result.hitEnt = vaultDoor
				}

				return result
			}
		}



		{
			entity train = GetTrainForHitEnt( processedHitEnt, TRAIN_BRUSH_SCRIPTNAME )
			if ( IsValid( train ) )
			{
				result.hitEnt = train
				result.pingType = ePingType.TRAIN

				return result
			}
		}


	{ 
		entity blackMarket = GetHitEntForScriptName( hitEntData, BLACK_MARKET_SCRIPTNAME )
		if ( IsValid( blackMarket ) )
		{
			result.hitEnt = blackMarket
			result.pingType = ePingType.ABILITY_BLACK_MARKET
			return result
		}
	}

	{ 
		entity echoLocator = GetHitEntForScriptName( hitEntData, ECHO_LOCATOR_SCRIPT_NAME )
		if ( IsValid( echoLocator ) )
		{
			result.hitEnt = echoLocator
			if ( IsFriendlyTeam( echoLocator.GetTeam(), player.GetTeam() ) || echoLocator.GetBossPlayer() == player )
			{
				result.pingType = ePingType.PING_ABILITY_ECHO_LOCATOR_FRIENDLY
			}
			else
			{
				result.pingType = ePingType.PING_ABILITY_ECHO_LOCATOR_ENEMY
			}
			return result
		}
	}


		{ 
			entity shieldMine = GetHitEntForScriptName( hitEntData, SHIELD_MINE_PROP_SCRIPTNAME )
			if ( IsValid( shieldMine ) )
			{
				result.hitEnt = shieldMine
				result.pingType = ePingType.ABILITY_SHIELD_MINE
				
				return result
			}
		}


	{ 
		entity chargePylon = GetHitEntForModel( hitEntData, CHARGE_PYLON_PING_MODEL )
		if ( IsValid( chargePylon ) )
		{
			result.hitEnt = chargePylon
			result.pingType = ePingType.CHARGE_PYLON
			return result
		}
	}

	{ 
		entity mobileShield = GetHitEntForScriptName( hitEntData, SHIELD_THROW_SCRIPTNAME )
		if ( IsValid( mobileShield ) )
		{
			int team = mobileShield.GetTeam()
			if ( team == TEAM_UNASSIGNED )
			{
				entity owner = mobileShield.GetOwner()
				if ( IsValid( owner ) )
					team = owner.GetTeam()
			}

			result.hitEnt = mobileShield
			result.pingType = IsEnemyTeam( playerTeam, team ) ? ePingType.ENEMY_MOBILE_SHIELD : ePingType.ABILITY_MOBILE_SHIELD
			return result
		}
	}

	{
		entity castleWall = GetHitEntForScriptName( hitEntData, ARMORED_LEAP_SHIELD_ANCHOR_SCRIPTNAME )
		if ( IsValid( castleWall ) )
		{
			int team = castleWall.GetTeam()
			if ( team == TEAM_UNASSIGNED )
			{
				entity owner = castleWall.GetOwner()
				if ( IsValid( owner ) )
					team = owner.GetTeam()
			}

			bool isEnergized = castleWall.e.castleWallIsEnergized

			result.hitEnt = castleWall
			if( isEnergized )
				result.pingType = IsEnemyTeam( playerTeam, team ) ? ePingType.ENEMY_CASTLE_WALL_ENERGIZED : ePingType.ABILITY_CASTLE_WALL_ENERGIZED
			else
				result.pingType = IsEnemyTeam( playerTeam, team ) ? ePingType.ENEMY_CASTLE_WALL : ePingType.ABILITY_CASTLE_WALL

			return result
		}
	}


	{
		entity whiteRaven = GetHitEntForScriptName( hitEntData, TRACKING_VISION_BIRD_PING_SCRIPTNAME )
		if ( IsValid( whiteRaven ) )
		{
			int team = whiteRaven.GetTeam()
			if ( team == TEAM_UNASSIGNED )
			{
				entity owner = whiteRaven.GetOwner()
				if ( IsValid( owner ) )
					team = owner.GetTeam()
			}

			result.hitEnt = whiteRaven
			result.pingType = ePingType.BLOODHOUND_WHITE_RAVEN
			return result
		}
	}



		{
			entity hoverVehicle = GetHoverVehicleForHitEnt( processedHitEnt )
			if ( IsValid( hoverVehicle ) )
			{
				result.hitEnt = hoverVehicle
				result.pingType = ePingType.HOVERVEHICLE

			if ( HoverVehicle_IsHostileToTeam( hoverVehicle, player.GetTeam() ) )
				result.pingType = ePingType.HOVERVEHICLE_ENEMY
			else
			{
				if ( !HoverVehicle_IsVehicleEmpty( hoverVehicle ) )
					result.pingType = ePingType.HOVERVEHICLE_ALLY
			}

				return result
			}
		}



		{
			entity pingVol = GetHitEntForScriptName( hitEntData, "pr_pingvol" )
			if ( IsValid( pingVol ) )
			{
				result.hitEnt = pingVol
				result.pingType = ePingType.PHASE_RUNNER
				return result
			}

		}



		{
			entity satelliteProp = GetCryptoSatelliteForHitEnt( processedHitEnt )
			if ( IsValid( satelliteProp ) )
			{
				result.hitEnt = satelliteProp
				result.pingType = ePingType.WE_GO
				return result
			}
		}



		{
			
			entity mural = GetHitEntForScriptName( hitEntData, "rampart_tt_lore_mural" )
			if ( IsValid( mural ) )
			{
				
				if( CheckRampartTTMuralLegends( player ) )
				{
					result.hitEnt   = mural
					result.pingType = ePingType.RAMPART_TT_MURAL
					return result
				}
			}

			
			if ( hitEntData.scriptName == "rampart_tt_vend" || hitEntData.scriptName == "rampart_tt_vend_panel" )
			{
				result.hitEnt = processedHitEnt
				result.pingType = ePingType.RAMPART_TT_VEND
				return result
			}
		}



		
		{
			entity medBayProp = GetHitEntForScriptName( hitEntData, MEDBAY_PING_SCRIPT_NAME )
			if ( IsValid( medBayProp ) )
			{
				
				if ( medBayProp.GetModelName() != "mdl/props/lifeline_drone/lifeline_drone.rmdl")
					medBayProp = medBayProp.GetOwner()
				result.hitEnt = medBayProp

				if ( MedBay_IsOnCooldown() )
					result.pingType = ePingType.MEDBAY_COOLDOWN
				else if ( MedBay_IsDisabled() )
					result.pingType = ePingType.MEDBAY_DISABLED
				else
					result.pingType = ePingType.MEDBAY

				return result
			}
		}


		{
			entity voidRing = GetHitEntForScriptName( hitEntData, VOID_RING_PROP_SCRIPTNAME )
			if ( IsValid( voidRing ) )
			{
				result.hitEnt = voidRing
				tr.endPos = <voidRing.GetOrigin().x, voidRing.GetOrigin().y,tr.endPos.z>
				result.pingType = ePingType.VOID_RING
				return result
			}
		}


		
		{
			entity balloonProp = GetRedeployBalloonForHitEnt( processedHitEnt )
			if ( IsValid( balloonProp ) )
			{
				result.hitEnt = balloonProp
				result.pingType = ePingType.REDEPLOY_BALLOON
				return result
			}
		}









































		{
			entity explosiveHoldEnt = GetExplosiveHoldForHitEnt( processedHitEnt )
			if ( IsValid( explosiveHoldEnt ) )
			{
				result.hitEnt = explosiveHoldEnt
				bool isOpen = ExplosiveHold_IsOpen( explosiveHoldEnt )
				if ( isOpen )
				{
					result.pingType = ePingType.EXPLOSIVEHOLD_OPEN
				}
				else
				{
					if ( ExplosiveHold_PlayerHasGrenadeInInventory( player ) )
					{
						result.pingType = ePingType.EXPLOSIVEHOLD
					}
					else
					{
						result.pingType = ePingType.EXPLOSIVEHOLD_REQUEST
					}
				}

				return result
			}
		}














		
		{
			
			if ( hitEntData.scriptName == CONTROL_OBJECTIVE_SCRIPTNAME && IsValid( processedHitEnt ) && IsValid( processedHitEnt.GetOwner() ) )
			{
				result.hitEnt = processedHitEnt

				entity objectiveStarterPing = Control_GetStarterPingFromTraceBlockerPing( processedHitEnt, player.GetTeam() )
				if ( objectiveStarterPing != null )
					result.hitEnt = objectiveStarterPing

				entity objectiveEnt = processedHitEnt.GetOwner()
				int objectiveOwner = objectiveEnt.GetWaypointInt( CONTROL_INT_OBJ_ALLIANCE_OWNER )

				if ( objectiveOwner != -1 && IsTeamInAlliance( player.GetTeam(), objectiveOwner ) )
				{
					result.pingType = ePingType.PING_CAPTURE_OBJECTIVE_DEFEND
				}
				else
				{
					result.pingType = ePingType.PING_CAPTURE_OBJECTIVE_ATTACK
				}
				return result
			}
		}


	{
		if ( hitEntData.scriptName == PHASE_BREACH_BLOCKER_SCRIPTNAME )
		{
			result.hitEnt = processedHitEnt
			result.pingType = ePingType.PING_PHASE_BREACH
			return result
		}
	}













	
	
	{
		entity targetEnt = GetHitEntForModel( hitEntData, "mdl/barriers/shooting_range_target_02.rmdl" )
		if ( IsValid( targetEnt ) )
		{
			result.hitEnt = targetEnt
			result.pingType = ePingType.ENEMY_GENERAL
			return result
		}
	}

	
	{
		entity targetEnt = GetHitEntForScriptName( hitEntData, VENDING_MACHINE_SCRIPTNAME )
		if ( IsValid( targetEnt ) )
		{
 			result.hitEnt = targetEnt
			result.pingType = ePingType.LOOT_BIN
			return result
		}
	}


	
	{
		if ( hitEntIsNPC && hitEntIsEnemy )
		{
			if ( processedHitEnt.ContextAction_IsReviving() || processedHitEnt.ContextAction_IsBeingRevived() )
			{
				result.pingType = ePingType.ENEMY_REVIVING
				return result
			}
			else
			{
				result.pingType = ePingType.ENEMY_SPECIFIC
				return result
			}
		}
	}


	{
		entity gravCannon = GetHitEntForScriptName( hitEntData, "GRAVITY_CANNON"  )
		if ( IsValid( gravCannon ) )
		{
			result.pingType = ePingType.PING_GRAVITYCANNON
			return result
		}
	}


	if ( processedHitEnt.GetScriptName() == GONDOLA_SCRIPTNAME )
	{
		result.pingType = ePingType.PING_GONDOLA
		return result
	}


	if ( player.HasZiplinePingInRange() )
	{
		result.hitEnt = player.GetZiplinePingEntity();

		result.pingType = ePingType.ZIPLINE;

			if ( IsZiprail( result.hitEnt ) )
			{
				result.pingType =  ePingType.ZIPRAIL;
			}

	}















	
	{
		
		if ( hitEntData.scriptName == TREASUREHUNT_OBJECTIVE_SCRIPTNAME && IsValid( processedHitEnt ) && IsValid( processedHitEnt.GetOwner() ) )
		{
			result.hitEnt = processedHitEnt

			entity objectiveStarterPing = TreasureHunt_GetStarterPingFromTraceBlockerPing( processedHitEnt, player.GetTeam() )
			if ( objectiveStarterPing != null )
				result.hitEnt = objectiveStarterPing

			result.pingType = ePingType.PING_CAPTURE_OBJECTIVE_ATTACK
			return result
		}
	}




















	if ( EntIsADynamicProp( processedHitEnt ) && processedHitEnt.GetTargetName() == "pathfinder_statue" )
	{
		result.pingType = ePingType.PATHFINDER_STATUE
		return result
	}

	
	if ( EntIsADynamicProp( processedHitEnt ) )
	{
		result.hitEnt = null
		result.pingType = defaultPingType
		return result
	}

	
	{
		result.hitEnt = processedHitEnt
		result.pingType = defaultPingType
		return result
	}
}




entity function GetProwlerDenForHitEnt( entity hitEnt )
{
	if ( hitEnt.GetScriptName().find( PROWLER_DEN_SCRIPT_NAME ) != -1 )
		return hitEnt

	entity parentEnt = hitEnt.GetParent()
	if ( IsValid( parentEnt ) && parentEnt.GetScriptName().find( PROWLER_DEN_SCRIPT_NAME ) != -1 )
		return parentEnt

	return null
}



int function GetEnemyPingCommsAction( int pingType, entity pingedEnt )
{
	if ( IsValid( pingedEnt ) && pingedEnt.IsNPC() )
	{
		string settingsName = pingedEnt.GetAISettingsName()
		switch( settingsName )
		{
			case "npc_soldier_spcore_rifleman":
			case "npc_soldier_spcore_shotgunner":
			case "npc_boss_guts":
			case "npc_training_dummy":
			case "npc_dummie_combat":
			case "npc_nessie":
				
				break;

				

			case "npc_soldier_spcore_sniper":
				return eCommsAction.PING_ENEMY_NPC_SNIPER

				

			case "npc_spectre_outlands":
				return eCommsAction.PING_ENEMY_NPC_SPECTRE

			case "npc_stalker_outlands":
				return eCommsAction.PING_ENEMY_NPC_STALKER

			case "npc_super_spectre_melee":
				return eCommsAction.PING_ENEMY_NPC_REAPER

			case "npc_drone_plasma":
				return eCommsAction.PING_ENEMY_NPC_DRONE

			case "npc_frag_drone_outlands":
				return eCommsAction.PING_ENEMY_NPC_TICK

			case "npc_titan_outlands":
				return eCommsAction.PING_ENEMY_NPC_TITAN

			case "npc_marvin":
				return eCommsAction.PING_NPC_MARVIN_LOOT

				

			case "npc_prowler":
				return eCommsAction.PING_ENEMY_NPC_PROWLER






			case "npc_spider_jungle":
				return eCommsAction.PING_ENEMY_NPC_SPIDER





			case "npc_soldier_infected":
				return eCommsAction.PING_ENEMY_NPC_INFECTED

			default:
				Warning( "%s() - Unhandled npc type '%s'.", FUNC_NAME(), settingsName )
		}
	}
	if ( pingType == ePingType.ENEMY_REVIVING )
		return eCommsAction.PING_ENEMY_SPOTTED_REVIVING

	else if ( pingType == ePingType.ENEMY_HEALING_HEALTH )
		return eCommsAction.PING_ENEMY_SPOTTED_HEALING_HEALTH
	else if ( pingType == ePingType.ENEMY_HEALING_SHIELD )
		return eCommsAction.PING_ENEMY_SPOTTED_HEALING_SHIELD

	else
		return eCommsAction.PING_ENEMY_SPOTTED_SPECIFIC

	unreachable
}




void function DoPlayerDefaultPingForLootEntity( entity player, entity lootEnt, entity deathBox )
{
	bool indirectMode = false
	if ( IsValid( deathBox ) && deathBox.GetNetworkedClassName() == "prop_loot_grabber" )
		indirectMode = true

	if ( !Waypoint_LootItemIsBeingPingedByAnyone( lootEnt, indirectMode ) )
	{
		Send_PingLoot( player, lootEnt, deathBox )
		return
	}

	array<entity> waypoints = Waypoint_GetWaypointsForLootItemPingedByTeam( lootEnt, player.GetTeam(), indirectMode )
	foreach ( entity wp in waypoints )
	{
		if ( wp.GetOwner() == player )
		{
			Send_PingReply( player, wp, ePingReply.OWNER_CANCEL )
		}
		else
		{
			entity dibsPlayer = Waypoint_GetLootPingDibsPlayer( wp )
			if ( IsValid( dibsPlayer ) )
			{
				if ( dibsPlayer == player )
					Send_PingReply( player, wp, ePingReply.LOOT_UNDIBS )
			}
			else
			{
				Send_PingReply( player, wp, ePingReply.LOOT_DIBS )
			}
		}
	}
}




float s_onDownLockoutTime = -100.0
void function Ping_Interrupt()
{
	if ( CommsMenu_HasValidSelection() )
	{
		entity player = GetLocalViewPlayer()
		if ( IsValid( player ) )
			player.SetLookStickDebounce()
	}

	CommsMenu_Shutdown( false )
	ClearPendingPing()
	s_onDownLockoutTime = (Time() + 0.1)
}




int function GetLootBinPingCommsAction( entity pingingPlayer, int pingType, entity pingedEnt )
{
	entity lootBin = IsValid( pingedEnt ) ? GetLootBinForHitEnt( pingedEnt ) : null
	if ( IsValid( lootBin ) )
	{
		if ( LootBin_IsOpenAtAll( lootBin ) )
		{
			return eCommsAction.PING_LOOTBIN_OPEN
		}


			if( SupportBin_EntityIsSupportBin( lootBin ) )
			{
				return eCommsAction.PING_SUPPORT_BOX
			}
			if( Perk_MunitionsBox_IsEntMunitionsBox( lootBin ) )
			{
				return eCommsAction.PING_MUNITIONS_BOX
			}



		if ( LootBin_HasSecretCompartment( lootBin ) )
			return eCommsAction.PING_LOOTBIN_EXTENDED

	}

	return eCommsAction.PING_LOOTBIN
}




int function GetCarePackageCommsAction( entity pingingPlayer, int pingType, entity pingedEnt )
{
	if ( IsValid( pingedEnt ) && pingedEnt.GetOwner() == pingingPlayer )
	{
		return eCommsAction.PING_MY_CAREPACKAGE
	}

	return eCommsAction.PING_CAREPACKAGE
}




Assert( ePingType._assertion_marker == 70, "Conditional Ping Type found above Assertion Marker in ePingType Enum. (assertion marker  = " + ePingType._assertion_marker )
int function GetCommsActionForPing( entity pingingPlayer, int pingType, entity pingedEnt )
{
	switch( pingType )
	{
		case ePingType.LOCATION:
		case ePingType.LOCATION_TRAINING:
#if DEV
		case ePingType.MULTILOCATION:
#endif
			return eCommsAction.PING_LOCATION

		case ePingType.WE_GO:




			if ( pingingPlayer.GetPlayerNetBool( "playerInPlane" ) )
				return eCommsAction.PING_DROP_SUGGESTION
			else
				return eCommsAction.PING_WE_GO

		case ePingType.RESPAWN_STATION:

				if ( GameModeVariant_IsActive( eGameModeVariants.SURVIVAL_SHADOW_ARMY ) && ShadowArmy_RespawnBeacon_CanBeaconBeUsedByPlayer( pingingPlayer, pingedEnt ) )
					return eCommsAction.SHADOWARMY_PING_RESPAWN_STATION

			return eCommsAction.PING_RESPAWN_STATION

		case ePingType.RESPAWN_MOBILE:
			return eCommsAction.PING_RESPAWN_MOBILE







		case ePingType.LOOT_CREEP_INFECTED:
			return eCommsAction.PING_LOOT_CREEP_INFECTED

		case ePingType.LOOT_CREEP_SPIDER:
			return eCommsAction.PING_LOOT_CREEP_SPIDER


		case ePingType.RESPAWN_DROPSHIP:
			return eCommsAction.PING_RESPAWN_DROPSHIP

		case ePingType.EVAC_DROPSHIP:
			return eCommsAction.PING_EVAC_DROPSHIP

		case ePingType.JUMP_PAD:
			return eCommsAction.PING_JUMP_PAD

		case ePingType.CRYPTO_DRONE:
			return eCommsAction.PING_CRYPTO_DRONE

		case ePingType.RAMPART_WALL:
			return eCommsAction.PING_RAMPART_WALL

		case ePingType.RAMPART_TURRET:
			return eCommsAction.PING_RAMPART_TURRET

		case ePingType.DEATH_TOTEM:
			return eCommsAction.PING_DEATH_TOTEM_NEUTRAL

		case ePingType.DEPLOYABLE_MEDIC:
			return eCommsAction.PING_DEPLOYABLE_MEDIC

		case ePingType.I_GO:
			return eCommsAction.PING_I_GO

		case ePingType.I_WATCHING:
			return eCommsAction.PING_I_WATCHING

		case ePingType.I_LOOTING:
			return eCommsAction.PING_I_LOOTING

		case ePingType.I_DEFENDING:
			return eCommsAction.PING_I_DEFENDING

		case ePingType.I_ATTACKING:
			return eCommsAction.PING_I_ATTACKING

		case ePingType.NEED_HEALTH:
			return eCommsAction.PING_NEED_HEALTH

		case ePingType.ABILITY_ME:
			return eCommsAction.PING_ABILITY_ME

		case ePingType.ABILITY_ALLY_0:
		case ePingType.ABILITY_ALLY_1:
		case ePingType.ABILITY_ALLY_2:
			return eCommsAction.PING_ABILITY_ALLY

		case ePingType.AREA_CLEAR:
			return eCommsAction.PING_AREA_CLEAR

		case ePingType.AREA_VISITED:
			return eCommsAction.PING_AREA_VISITED

		case ePingType.ENEMY_GENERAL:
			return eCommsAction.PING_ENEMY_SPOTTED_GENERAL

		case ePingType.WE_ATTACK:
			return eCommsAction.PING_WE_ATTACK
		case ePingType.I_ULTIMATE:
			return eCommsAction.PING_I_ULTIMATE
		case ePingType.WE_FALLBACK:
			return eCommsAction.PING_WE_FALLBACK
		case ePingType.ENEMY_AUDIO:
			return eCommsAction.PING_ENEMY_AUDIO
		case ePingType.ENEMY_FIGHTING:
			return eCommsAction.PING_ENEMY_FIGHTING
		case ePingType.DONT_REVIVE:
			return eCommsAction.PING_BLEEDOUT_DONT_REVIVE
		case ePingType.WE_AVOID:
			return eCommsAction.PING_WE_AVOID
		case ePingType.WE_DEFEND:
			return eCommsAction.PING_WE_DEFEND
		case ePingType.WE_ABILITY:
			return eCommsAction.PING_WE_ABILITY
		case ePingType.WE_REGROUP:
			return eCommsAction.PING_WE_REGROUP


		case ePingType.VANTAGE_SPOTS_ENEMY:
			int armorTier = EquipmentSlot_GetEquipmentTier( pingedEnt, "armor" )
			if ( armorTier <= 1 )
				return eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_1
			else if ( armorTier == 2 )
				return eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_2
			else if ( armorTier == 3 )
				return eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_3
			else if ( armorTier == 4 )
				return eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_4
			else if ( armorTier >= 5 )
				return eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_5
			break
		case ePingType.VANTAGE_COMPANION:
			return eCommsAction.PING_VANTAGE_COMPANION
		case ePingType.ENEMY_VANTAGE_COMPANION:
			return eCommsAction.PING_ENEMY_VANTAGE_COMPANION
		case ePingType.ENEMY_SPECIFIC:

		case ePingType.ENEMY_HEALING_HEALTH:
		case ePingType.ENEMY_HEALING_SHIELD:

		case ePingType.ENEMY_REVIVING:

				if ( IsValid( pingedEnt ) && IsPlayerShadowZombie( pingedEnt ) )
				{

						
						if ( !GameModeVariant_IsActive( eGameModeVariants.SURVIVAL_SHADOW_ARMY ) )

						{
							return eCommsAction.PING_ENEMY_SPOTTED_SHADOW
						}
				}


			return GetEnemyPingCommsAction( pingType, pingedEnt )

		case ePingType.ENEMY_LOOTSOURCE:
			return eCommsAction.PING_NPC_LOOT_TICK


		case ePingType.LOOT_TICK_GH:
			return eCommsAction.PING_NPC_LOOT_TICK_GH


		case ePingType.ASH_PASSIVE_ID_ATTACKER:
			return eCommsAction.PING_ENEMY_MARKED_BY_DATAKNIFE


		case ePingType.STORY_MARVIN:
			return eCommsAction.PING_NPC_MARVIN_STORY
		case ePingType.LOOT_MARVIN:
			return eCommsAction.PING_NPC_MARVIN_LOOT


		case ePingType.LOOT:
			if ( IsValid( pingedEnt ) && pingedEnt.GetNetworkedClassName() == "prop_survival" )
				return GetPingLootCommsAction( pingedEnt )
			else
				return eCommsAction.PING_WE_GO

		case ePingType.MAP_WAYPOINT:




			if ( pingingPlayer.GetPlayerNetBool( "playerInPlane" ) )
				return eCommsAction.PING_DROP_SUGGESTION
			else
				return eCommsAction.PING_WE_GO

		case ePingType.DOOR:
			return eCommsAction.PING_DOOR

		case ePingType.DOOR_OPEN:
			return eCommsAction.PING_DOOR_OPEN

		case ePingType.LOOT_BIN:
		case ePingType.LOOT_BIN_EXTENDED:
			return GetLootBinPingCommsAction( pingingPlayer, pingType, pingedEnt )

		case ePingType.CAREPACKAGE:
			return GetCarePackageCommsAction( pingingPlayer, pingType, pingedEnt )

		case ePingType.DEATH_BOX:
			return eCommsAction.PING_DEATHBOX

		case ePingType.ASH_PASSIVE_PING_DEATHBOX:
			return eCommsAction.PING_DEATHBOX_FROM_MAP_BY_DATAKNIFE

		case ePingType.ASH_PASSIVE_ID_DEATHBOX:
			return eCommsAction.PING_DEATHBOX_MARKED_BY_DATAKNIFE

		case ePingType.PING_PHASE_BREACH:
			return eCommsAction.PING_PHASE_BREACH

		case ePingType.OPENED_PHASE_BREACH:
			return eCommsAction.SPAWN_BREACH

		case ePingType.ENEMY_TETHERED:
			return eCommsAction.PING_ENEMY_TETHERED


		case ePingType.MAGGIE_WRECKING_BALL:
			return eCommsAction.PING_MAGGIE_WRECKING_BALL

		case ePingType.ABILITY_MOBILE_SHIELD:
			return eCommsAction.PING_MOBILE_SHIELD
		case ePingType.ENEMY_MOBILE_SHIELD:
			return eCommsAction.PING_ENEMY_MOBILE_SHIELD
		case ePingType.ABILITY_CASTLE_WALL:
			return eCommsAction.PING_CASTLE_WALL
		case ePingType.ENEMY_CASTLE_WALL:
			return eCommsAction.PING_ENEMY_CASTLE_WALL
		case ePingType.ABILITY_CASTLE_WALL_ENERGIZED:
			return eCommsAction.PING_CASTLE_WALL_ENERGIZED
		case ePingType.ENEMY_CASTLE_WALL_ENERGIZED:
			return eCommsAction.PING_ENEMY_CASTLE_WALL_ENERGIZED
		case ePingType.BLOODHOUND_WHITE_RAVEN:
			return eCommsAction.PING_BLOODHOUND_WHITE_RAVEN
		case ePingType.BLOODHOUND_WHITE_RAVEN_TARGET_LOC:
			return eCommsAction.PING_BLOODHOUND_WHITE_RAVEN_TARGET_LOC






		case ePingType.ABILITY_BARRICADE:
			return eCommsAction.PING_BARRICADED_DOOR
		case ePingType.ABILITY_BARRICADE_OPEN:
			return eCommsAction.PING_BARRICADED_DOOR_OPEN
		case ePingType.ABILITY_PIERCING_SPIKES:
			return ( IsValid( pingingPlayer ) && IsValid( pingedEnt ) && IsEnemyTeam( pingingPlayer.GetTeam(), pingedEnt.GetTeam() ) ) ? eCommsAction.PING_PIERCING_SPIKES_ENEMY : eCommsAction.PING_PIERCING_SPIKES
		case ePingType.ABILITY_DARK_VEIL:
			return ( IsValid( pingingPlayer ) && IsValid( pingedEnt ) && IsEnemyTeam( pingingPlayer.GetTeam(), pingedEnt.GetTeam() ) ) ? eCommsAction.PING_DARK_VEIL_ENEMY : eCommsAction.PING_DARK_VEIL


		case ePingType.PING_MY_LAST_DEATH_BOX:
			return eCommsAction.PING_MY_LAST_DEATHBOX

		case ePingType.MARK_MY_LAST_DEATH_BOX:
			return eCommsAction.MARK_MY_LAST_DEATHBOX



		case ePingType.MARK_MY_LAST_DEATH_LOCATION:
			return eCommsAction.MARK_MY_LAST_DEATH_LOCATION


		case ePingType.SURVEYBEACON:
			return eCommsAction.PING_SURVEYBEACON

		case ePingType.HOVERTANK:
			return eCommsAction.PING_HOVERTANK

		case ePingType.FLYER:
			return eCommsAction.PING_FLYER

		case ePingType.FLYER_CAGED:
			return eCommsAction.PING_FLYER_CAGED

		case ePingType.JUMPTOWER:
			return eCommsAction.PING_JUMPTOWER

		case ePingType.GEYSER:
			return eCommsAction.PING_GEYSER

		case ePingType.LAVA:
			return eCommsAction.PING_LAVA


		case ePingType.HOVERVEHICLE:
			return eCommsAction.PING_HOVERVEHICLE

		case ePingType.HOVERVEHICLE_ALLY:
			return eCommsAction.PING_HOVERVEHICLE_ALLY

		case ePingType.HOVERVEHICLE_ENEMY:
			return eCommsAction.PING_HOVERVEHICLE_ENEMY

		case ePingType.HOVERVEHICLE_NAG:
			return eCommsAction.PING_HOVERVEHICLE_NAG


		case ePingType.LOOT_DRONE:
			return eCommsAction.PING_LOOT_DRONE

		case ePingType.LOOT_ROLLER:
			return eCommsAction.PING_LOOT_ROLLER


		case ePingType.LOOT_VAULT:
			return eCommsAction.PING_LOOT_VAULT

		case ePingType.LOOT_VAULT_HAS_KEY_SQUAD:
			return eCommsAction.PING_LOOT_VAULT_HAS_KEY_SQUAD

		case ePingType.LOOT_VAULT_HAS_KEY_SELF:
			return eCommsAction.PING_LOOT_VAULT_HAS_KEY_SELF

		case ePingType.LOOT_VAULT_OPEN:
			return eCommsAction.PING_LOOT_VAULT_OPEN

		case ePingType.LOOT_VAULT_REVEAL:
			return eCommsAction.PING_LOOT_VAULT_REVEAL



		case ePingType.SHIP_VAULT:
			return eCommsAction.PING_SHIP_VAULT

		case ePingType.SHIP_VAULT_HAS_KEY_SQUAD:
			return eCommsAction.PING_SHIP_VAULT_HAS_KEY_SQUAD

		case ePingType.SHIP_VAULT_HAS_KEY_SELF:
			return eCommsAction.PING_SHIP_VAULT_HAS_KEY_SELF

		case ePingType.SHIP_VAULT_REVEAL:
			return eCommsAction.PING_SHIP_VAULT_REVEAL




		case ePingType.TRAIN:
			return eCommsAction.PING_TRAIN



		case ePingType.EVAC_SHIP:
			return eCommsAction.SPAWN_EVAC_SHIP

		case ePingType.EVAC_ZONE:
			return eCommsAction.SPAWN_EVAC_ZONE


















		case ePingType.CHARGE_PYLON:
			return eCommsAction.PING_CHARGE_PYLON


		case ePingType.PHASE_RUNNER:
		{
			return eCommsAction.PING_PHASE_RUNNER
		}


		case ePingType.QUEST_OBJECTIVE:
			return eCommsAction.QUEST_OBJECTIVE

		case ePingType.QUEST_DRILL:
			return eCommsAction.QUEST_DRILL

		case ePingType.ZIPLINE:
			return eCommsAction.PING_ZIPLINE

		case ePingType.ZIPRAIL:
			return eCommsAction.PING_ZIPRAIL

		case ePingType.NEUTRAL_FENCE:
			return eCommsAction.PING_NEUTRAL_FENCE

		case ePingType.FRIENDLY_TRAP:
			return eCommsAction.PING_FRIENDLY_TRAP

		case ePingType.ENEMY_TRAP:
			return eCommsAction.PING_ENEMY_TRAP

		case ePingType.ENEMY_SILENCE_BOMB:
			return eCommsAction.PING_ENEMY_SILENCE_BOMB

		case ePingType.ENEMY_TESLA_TRAP:
			return eCommsAction.PING_ENEMY_TESLA_TRAP

		case ePingType.NEUTRAL_TROPHY_SYSTEM:
			if ( !IsValid( pingedEnt ) )
				return eCommsAction.PING_WE_GO
			return eCommsAction.PING_TROPHY_SYSTEM_NEUTRAL
		case ePingType.ENEMY_TROPHY_SYSTEM:
			if ( !IsValid( pingedEnt ) )
				return eCommsAction.PING_WE_GO
			return eCommsAction.PING_TROPHY_SYSTEM

		case ePingType.ENEMY_SMOKE:
			return eCommsAction.PING_ENEMY_SMOKE

		case ePingType.TOXIC_GAS:
			return eCommsAction.PING_TOXIC_GAS

		case ePingType.ENEMY_SHIELD:
			return eCommsAction.PING_ENEMY_SHIELD

		case ePingType.ENEMY_TELEPORTER:
			return eCommsAction.PING_ENEMY_TELEPORTER

		case ePingType.ABILITY_WORMHOLE:
			return eCommsAction.SPAWN_WORMHOLE

		case ePingType.ABILITY_DRONEMEDIC:
			return eCommsAction.SPAWN_DRONEMEDIC

		case ePingType.SKYDIVE_LAUNCHER:
			return eCommsAction.PING_SKYDIVE_LAUNCHER


		case ePingType.TRAIN_OBJECTIVE:
			return eCommsAction.PING_TRAINOBJECTIVE

		case ePingType.STATION:
			return eCommsAction.PING_STATION



		case ePingType.SPAWN_REGION:
			return eCommsAction.PING_SPAWNREGION

		case ePingType.VALK_ULT_COME_HERE:
			return eCommsAction.PING_VALK_ULT_COME_HERE

		case ePingType.VALK_ULT_ENEMY_TAKING_OFF:
			return eCommsAction.PING_VALK_ULT_ENEMY_TAKING_OFF

		case ePingType.ABILITY_SPACE_ELEVATOR:
			return eCommsAction.PING_SPACE_ELEVATOR_HERE

		case ePingType.ABILITY_BLACK_HOLE:
			return eCommsAction.PING_BLACKHOLE_HERE

		case ePingType.ABILITY_SHIELD_MINE:
			return eCommsAction.PING_SHIELD_MINE


		case ePingType.OBJECTIVE:
			return eCommsAction.PING_OBJECTIVE


		case ePingType.CRAFTING_GENERIC:
			return eCommsAction.REPLY_CRAFTING_NEXT_HARVESTER_OR_WORKBENCH

		case ePingType.PING_REPLICATOR:
			return eCommsAction.PING_REPLICATOR

		case ePingType.PING_REPLICATOR_INCOMING:
			return eCommsAction.PING_REPLICATOR_INCOMING

		case ePingType.PING_MATERIALS:
			return eCommsAction.PING_MATERIALS


		case ePingType.PING_REPLICATOR_NOONE_USED:
			return eCommsAction.PING_REPLICATOR_NOONE_USED

		case ePingType.PING_REPLICATOR_ALL_USED:
			return eCommsAction.PING_REPLICATOR_ALL_USED

		case ePingType.PING_REPLICATOR_PLAYER_USED:
			return eCommsAction.PING_REPLICATOR_PLAYER_USED

		case ePingType.PING_REPLICATOR_TEAMMATE_USED:
			return eCommsAction.PING_REPLICATOR_TEAMMATE_USED

		case ePingType.PING_REPLICATOR_DISPENSER_INCOMING:
			return eCommsAction.PING_REPLICATOR_DISPENSER_INCOMING

		case ePingType.VOID_RING:
			return eCommsAction.PING_DEPLOYED_VOID_RING

		case ePingType.CAREPACKAGE_INSIGHT:
		case ePingType.CAREPACKAGE_INSIGHT_FUTURE:
			return eCommsAction.REPLY_CAREPACKAGE_INSIGHT
		case ePingType.CAREPACKAGE_INSIGHT_LOOTED:
			return eCommsAction.REPLY_CAREPACKAGE_INSIGHT_LOOTED
		case ePingType.MUNITIONS_BOX:
			return eCommsAction.PING_MUNITIONS_BOX
		case ePingType.MUNITIONS_BOX_LOOT:
			return eCommsAction.PING_OPENED_MUNITIONS_BOX
		case ePingType.SUPPORT_BOX_LOOT:
			return eCommsAction.PING_OPENED_SUPPORT_BOX
		case ePingType.SUPPORT_BOX:
			return eCommsAction.PING_SUPPORT_BOX
		case ePingType.ENCRYPTED_CONSOLE:
			return eCommsAction.PING_ENCRYPTED_CONSOLE


		case ePingType.ABILITY_DOMESHIELD:
		case ePingType.ABILITY_JUMPPAD:
		case ePingType.BLEEDOUT:
		case ePingType.SELF_REVIVE:
		case ePingType.RESPAWN_CARD:
		case ePingType.RESPAWN_BANNER:

		case ePingType.HOLOSPRAY_LIKE:



		case ePingType.ASH_PASSIVE_ID_ATTACKER:





			return eCommsAction.BLANK

		case ePingType.ABILITY_ECHO_LOCATOR:
			return eCommsAction.PING_ABILITY_ECHO_LOCATOR
		case ePingType.PING_ABILITY_ECHO_LOCATOR_ENEMY:
			return eCommsAction.PING_ABILITY_ECHO_LOCATOR_ENEMY
		case ePingType.PING_ABILITY_ECHO_LOCATOR_FRIENDLY:
			return eCommsAction.PING_ABILITY_ECHO_LOCATOR_FRIENDLY

		case ePingType.BLOODHOUND_POI_TRAVELER:
		case ePingType.BLOODHOUND_POI_TRAVELER_RECENT:
		case ePingType.BLOODHOUND_POI_BATTLE:
		case ePingType.BLOODHOUND_POI_BATTLE_RECENT:
		case ePingType.BLOODHOUND_POI_LOOTING:
		case ePingType.BLOODHOUND_POI_LOOTING_RECENT:
		case ePingType.BLOODHOUND_POI_WOUNDED:
		case ePingType.BLOODHOUND_POI_WOUNDED_RECENT:
			return GetBloodhoundPingCommsAction( pingingPlayer, pingType, pingedEnt )

		case ePingType.ABILITY_BLACK_MARKET:
			return eCommsAction.ABILITY_BLACK_MARKET_NEUTRAL

		case ePingType.DRONE_PING_BANNER_0:
		case ePingType.DRONE_PING_BANNER_1:
		case ePingType.DRONE_PING_BANNER_2:
		case ePingType.DRONE_PING_BANNER_3:
		case ePingType.DRONE_PING_BANNER_MANY:
			int diff = pingType - ePingType.DRONE_PING_BANNER_0
			return eCommsAction.PING_BANNER_ENEMYCOUNT_0 + diff







		case ePingType.EXPLOSIVEHOLD:
			return eCommsAction.PING_EXPLOSIVEHOLD

		case ePingType.EXPLOSIVEHOLD_OPEN:
			return eCommsAction.PING_EXPLOSIVEHOLD_OPEN

		case ePingType.EXPLOSIVEHOLD_REQUEST:
			return eCommsAction.PING_EXPLOSIVEHOLD_REQUEST


		case ePingType.PING_CAPTURE_OBJECTIVE_DEFEND:
		{

				if ( GameMode_IsActive( eGameModes.CONTROL ) )
					return eCommsAction.PING_CONTROL_OBJECTIVE_DEFEND

		}

		case ePingType.PING_CAPTURE_OBJECTIVE_ATTACK:
		{

				if ( GameMode_IsActive( eGameModes.CONTROL ) )
					return eCommsAction.PING_CONTROL_OBJECTIVE_ATTACK



				if ( GameModeVariant_IsActive( eGameModeVariants.FREEDM_LOCKDOWN ) )
					return eCommsAction.PING_TREASUREHUNT_OBJ_ATTACK






		}

		
		case ePingType.NON_PINGABLE_SPAWN_LOCATION:
			return eCommsAction.BLANK

		case ePingType.PATHFINDER_STATUE:
			return eCommsAction.PING_PATHFINDER_STATUE

		case ePingType.PING_PROWLER:
			return eCommsAction.PING_ENEMY_NPC_PROWLER

		case ePingType.PING_SPIDER:
			return eCommsAction.PING_ENEMY_NPC_SPIDER


		case ePingType.PING_PROWLER_DEN:
			return eCommsAction.PING_PROWLER_DEN
		case ePingType.PING_PROWLER_DEN_EMPTY:
			return eCommsAction.PING_PROWLER_DEN_EMPTY
		case ePingType.PING_SPIDER_EGGS:
			return eCommsAction.PING_SPIDER_EGGS
		case ePingType.PING_SPIDER_EGGS_HATCHED:
			return eCommsAction.PING_SPIDER_EGGS_HATCHED



		case ePingType.PING_GRAVITYCANNON:
			return eCommsAction.PING_GRAVITYCANNON


		case ePingType.PING_GONDOLA:
			return eCommsAction.PING_GONDOLA


		case ePingType.RAMPART_TT_MURAL:
			return eCommsAction.PING_RAMPART_TT_MURAL
		case ePingType.RAMPART_TT_VEND:
			return eCommsAction.PING_RAMPART_TT_VEND



		case ePingType.MEDBAY:
			return eCommsAction.PING_MEDBAY
		case ePingType.MEDBAY_COOLDOWN:
			return eCommsAction.PING_MEDBAY_COOLDOWN
		case ePingType.MEDBAY_DISABLED:
			return eCommsAction.PING_MEDBAY_DISABLED



		case ePingType.PING_IMC_ARMORY_EXT:
			return eCommsAction.PING_IMC_ARMORY_EXT
		case ePingType.PING_IMC_ARMORY_PANEL:
			return eCommsAction.PING_IMC_ARMORY_PANEL

		case ePingType.PING_PANEL:
			return eCommsAction.PING_PANEL
		case ePingType.PING_PANEL_COOLDOWN:
			return eCommsAction.PING_PANEL_COOLDOWN
		case ePingType.PING_PANEL_INACTIVE:
			return eCommsAction.PING_PANEL_INACTIVE
		case ePingType.CAREPACKAGE_INCOMING:
			return eCommsAction.PING_CAREPACKAGE_INCOMING


		case ePingType.REDEPLOY_BALLOON:
			return eCommsAction.PING_REDEPLOY_BALLOON
























		case ePingType.REV_SHELL:
			return eCommsAction.PING_ITEM_REV_SHELL_INAIR



		case ePingType.REDEYED_REV:
			return eCommsAction.PING_REDEYED_REV

		case ePingType.EVAC_AREA:
			return eCommsAction.PING_EVAC_AREA

		case ePingType.LEGEND_START_AREA:
			return eCommsAction.PING_LEGEND_START_AREA



		case ePingType.THE_HUNT_AREA_PREY:
			return eCommsAction.PING_AREA_THE_HUNT_PREY
		case ePingType.THE_HUNT_AREA_HUNTER:
			return eCommsAction.PING_AREA_THE_HUNT_HUNTER


		case ePingType.RAMPART_TT_VENDING:
			return eCommsAction.PING_RAMPART_TT_VENDING







		case ePingType.UPGRADE_STATION:
			return eCommsAction.PING_UPGRADE_STATION



		case ePingType.TRANSPORT_PORTAL_REMOTE:
		case ePingType.TRANSPORT_PORTAL_FRIENDLY:
			return eCommsAction.PING_TRANSPORT_PORTAL_FRIENDLY
		case ePingType.TRANSPORT_PORTAL_ENEMY:
			return eCommsAction.PING_TRANSPORT_PORTAL_ENEMY
		case ePingType.CHASE_PORTAL_FRIENDLY:
			return eCommsAction.PING_CHASE_PORTAL_FRIENDLY
		case ePingType.CHASE_PORTAL_ENEMY:
			return eCommsAction.PING_CHASE_PORTAL_ENEMY
		case ePingType.PHASE_DOOR:
			return eCommsAction.PING_PHASE_DOOR



		case ePingType.ENEMY_POI:
			return eCommsAction.PING_ENEMY_POI


		case ePingType.MULTI_ENEMY_POI:
			return eCommsAction.PING_MULTI_ENEMY_POI








	}

	string enumStr = IsValidEnumValue( "ePingType", pingType ) ? GetEnumString( "ePingType", pingType ) : "Unknown ePingType!"
	Assert( false, "Unhandled pingtype " + enumStr + " (" + pingType + ")" ) 

	return eCommsAction.PING_WE_GO
}




int function Ping_GetSortModifier( int pingType, bool isSameTeam )
{
	switch( pingType )
	{
		case ePingType.BLEEDOUT:
			return (isSameTeam ? 10 : 0)

		case ePingType.RESPAWN_BANNER:

		case ePingType.CAREPACKAGE_INSIGHT:
		case ePingType.CAREPACKAGE_INSIGHT_LOOTED:
		case ePingType.CAREPACKAGE_INSIGHT_FUTURE:

			return 10
	}

	return 0
}




string function Ping_GetShortTextForPing( int pingType )
{
	entity player = GetLocalViewPlayer()
	if ( !IsValid( player ) )
		return ""

	int commsAction = GetCommsActionForPing( player, pingType, null )
	string result   = GetShortTextForCommsAction( commsAction )
	return result
}




string function Ping_GetMenuOptionTextForPing( int pingType )
{
	entity player = GetLocalViewPlayer()
	if ( !IsValid( player ) )
		return ""

	int commsAction = GetCommsActionForPing( player, pingType, null )
	string result   = GetMenuOptionTextForCommsAction( commsAction )
	return result
}




entity function GetAllyByTeamMemberIndex( entity player, int teamNumIndex )
{
	array<entity> teamPlayers = GetPlayerArrayOfTeam( player.GetTeam() )
	foreach ( entity teamPlayer in teamPlayers )
	{
		if ( teamPlayer.GetTeamMemberIndex() == teamNumIndex )
			return teamPlayer
	}

	return null
}




Assert( ePingType._assertion_marker == 70, "Conditional Ping Type found above Assertion Marker in ePingType Enum. (assertion marker  = " + ePingType._assertion_marker )
asset function Ping_IconForPing_Hud( entity player, int pingType, entity pingedEnt, entity owner )
{
	switch( pingType )
	{
		case ePingType.ABILITY_ME:
			return IsValid( owner ) ? owner.GetPlayerSettingAsset( "unitframe_icon" ) : $""

		case ePingType.ABILITY_ALLY_0:
		case ePingType.ABILITY_ALLY_1:
		case ePingType.ABILITY_ALLY_2:
		{
			entity ally = GetAllyByTeamMemberIndex( player, (pingType - ePingType.ABILITY_ALLY_0) )
			return IsValid( ally ) ? ally.GetPlayerSettingAsset( "unitframe_icon" ) : $""
		}

		case ePingType.RESPAWN_MOBILE:



		case ePingType.RESPAWN_STATION:
			return RESPAWN_BEACON_ICON

		case ePingType.HOLOSPRAY_LIKE:
			return $"rui/menu/dpad_comms/emoji/thumbsup"

		case ePingType.RESPAWN_CARD: 
			return $"rui/hud/unitframes/frame_status_mask"


		case ePingType.MARK_MY_LAST_DEATH_BOX:


		case ePingType.MARK_MY_LAST_DEATH_LOCATION:

		case ePingType.BLEEDOUT:
		case ePingType.RESPAWN_BANNER:
			if ( LoadoutSlot_IsReady( ToEHI( owner ), Loadout_Character() ) )
			{
				ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( owner ), Loadout_Character() )
				return CharacterClass_GetGalleryPortrait( character )
			}
			return RESPAWN_BEACON_ICON

		case ePingType.ABILITY_DOMESHIELD:
			return $"rui/hud/tactical_icons/tactical_gibraltar"

		case ePingType.SELF_REVIVE:
			return $"rui/hud/gametype_icons/hunted/bleedout_selfrevive_icon"

		case ePingType.ABILITY_JUMPPAD:
			return $"rui/hud/ultimate_icons/ultimate_octane_in_world"

		case ePingType.ABILITY_SPACE_ELEVATOR:
			return $"rui/hud/tactical_icons/tactical_nova"






		case ePingType.ABILITY_BLACK_MARKET:
			return $"rui/hud/ultimate_icons/ultimate_loba"

		case ePingType.RAMPART_WALL:
			return $"rui/hud/tactical_icons/tactical_rampart"

		case ePingType.RAMPART_TURRET:
			return $"rui/hud/ultimate_icons/ultimate_rampart"

		case ePingType.VOID_RING:
			return $"rui/hud/gametype_icons/survival/void_ring_icon"

		case ePingType.ASH_PASSIVE_ID_ATTACKER:
			return $"rui/hud/ping/icon_ping_enemy"






		case ePingType.ABILITY_ECHO_LOCATOR:
			return $"rui/hud/ultimate_icons/ultimate_seer"












		case ePingType.PING_REPLICATOR:
		{
			if ( Crafting_IsDispenserCraftingEnabled() )
				return $"rui/hud/ping/icon_ping_crafting_2"

			return $"rui/hud/ping/icon_ping_crafting"
		}











	}

	int commsAction = GetCommsActionForPing( player, pingType, pingedEnt )
	asset result    = GetDefaultIconForCommsAction( commsAction )
	return result
}




asset function Ping_IconForPing_Minimap( entity player, int pingType, entity pingedEnt, entity owner )
{
	switch( pingType )
	{
		case ePingType.RESPAWN_CARD: 


		case ePingType.PING_MY_LAST_DEATH_BOX:
		case ePingType.MARK_MY_LAST_DEATH_BOX:


		case ePingType.MARK_MY_LAST_DEATH_LOCATION:

		case ePingType.BLEEDOUT:
		case ePingType.RESPAWN_BANNER:
			return $"rui/hud/unitframes/frame_status_mask"



		case ePingType.CRAFTING_GENERIC:
		case ePingType.PING_MATERIALS:
		case ePingType.PING_REPLICATOR_INCOMING:
		case ePingType.PING_REPLICATOR:
			return $""



		case ePingType.LOOT_TICK_GH:
			return $"rui/hud/common/objective_marker"

	}

	return Ping_IconForPing_Hud( player, pingType, pingedEnt, owner )
}




asset function Ping_IconForPing_Bigmap( entity player, int pingType, entity pingedEnt, entity owner )
{
	switch( pingType )
	{
		case ePingType.RESPAWN_CARD: 


		case ePingType.PING_MY_LAST_DEATH_BOX:
		case ePingType.MARK_MY_LAST_DEATH_BOX:


		case ePingType.MARK_MY_LAST_DEATH_LOCATION:

		case ePingType.BLEEDOUT:
		case ePingType.RESPAWN_BANNER:
			return $"rui/hud/unitframes/frame_status_mask"


		case ePingType.PING_REPLICATOR_NOONE_USED:
		case ePingType.PING_REPLICATOR_ALL_USED:
		case ePingType.PING_REPLICATOR_PLAYER_USED:
		case ePingType.PING_REPLICATOR_TEAMMATE_USED:
		case ePingType.PING_REPLICATOR_DISPENSER_INCOMING:
		case ePingType.CRAFTING_GENERIC:
		case ePingType.PING_MATERIALS:
		case ePingType.PING_REPLICATOR_INCOMING:
		case ePingType.PING_REPLICATOR:
			asset craftingPingAsset = $""
			if( Crafting_IsPingMapIconEnabled() )
				craftingPingAsset = $"rui/hud/common/objective_marker"
			return craftingPingAsset 


		case ePingType.RESPAWN_STATION:
			return $"rui/hud/common/objective_marker"


		case ePingType.LOOT_TICK_GH:
			return $"rui/hud/common/objective_marker"

	}

	return Ping_IconForPing_Hud( player, pingType, pingedEnt, owner )
}




vector function Ping_IconScaleForPing( entity player, int pingType, entity pingedEnt, entity owner )
{
	switch ( pingType )
	{






		default:
			return <1.0, 1.0, 0.0>
	}
	unreachable
}

bool function Ping_IconForPing_IsAdditive( entity player, int pingType, entity pingedEnt, entity owner )
{
	switch( pingType )
	{
		case ePingType.ABILITY_DOMESHIELD:
			return true

		case ePingType.ABILITY_JUMPPAD:
			return true

		case ePingType.ABILITY_SPACE_ELEVATOR:
			return true











	}

	return false
}




asset function Ping_RuiForPing_Hud( entity player, int pingType, entity pingedEnt, entity owner )
{
	int commsAction = GetCommsActionForPing( player, pingType, pingedEnt )
	asset pingAsset = GetPingAssetForCommsAction( commsAction )
	if ( pingAsset != $"" )
		return $"ui/waypoint_ping_entpos.rpak"

	switch ( pingType )
	{
		case ePingType.NON_PINGABLE_SPAWN_LOCATION:
		case ePingType.RESPAWN_CARD:
		case ePingType.PING_CAPTURE_OBJECTIVE_DEFEND:
		case ePingType.PING_CAPTURE_OBJECTIVE_ATTACK:
			return $"ui/waypoint_ping_entpos.rpak"


		case ePingType.MARK_MY_LAST_DEATH_BOX:


		case ePingType.MARK_MY_LAST_DEATH_LOCATION:

		case ePingType.BLEEDOUT:
		case ePingType.RESPAWN_BANNER:

		case ePingType.CAREPACKAGE_INSIGHT_FUTURE:

			return $"ui/waypoint_status_timer_entpos.rpak"
	}

	return $"ui/waypoint_basic_entpos.rpak"
}




ItemFlavor ornull function Ping_ItemFlavorForPing( entity player, int pingType, entity pingedEnt )
{
	int commsAction = GetCommsActionForPing( player, pingType, pingedEnt )
	asset pingAsset = GetPingAssetForCommsAction( commsAction )
	if ( pingAsset == $"" )
	{
		if ( pingType == ePingType.RESPAWN_CARD )
			return GetItemFlavorByAsset( $"settings/itemflav/ping/ping_my_banner.rpak" )

		return null
	}

	return GetItemFlavorByAsset( pingAsset )
}

vector function Ping_LineColorForPing_Hud( int pingType )
{
	vector color

	switch( pingType )
	{

		case ePingType.ENEMY_GENERAL:

		case ePingType.ENEMY_HEALING_HEALTH:
		case ePingType.ENEMY_HEALING_SHIELD:

		case ePingType.ENEMY_REVIVING:
		case ePingType.ENEMY_SHIELD:
		case ePingType.ENEMY_SMOKE:
		case ePingType.TOXIC_GAS:
		case ePingType.ENEMY_SPECIFIC:
		case ePingType.ENEMY_TELEPORTER:
		case ePingType.ENEMY_TRAP:
		case ePingType.ENEMY_TESLA_TRAP:
		case ePingType.ENEMY_TROPHY_SYSTEM:
		case ePingType.ASH_PASSIVE_ID_ATTACKER:




			color = <1.0, 0.0, 0.0>
			break








		case ePingType.MARK_MY_LAST_DEATH_BOX:


		case ePingType.MARK_MY_LAST_DEATH_LOCATION:

		case ePingType.I_GO:
		case ePingType.WE_GO:
		case ePingType.MAP_WAYPOINT:
			color = <1.0, 0.7, 0.2>
			break




		default:
			color = <1.0, 1.0, 1.0>
	}

	return color
}




vector function Ping_IconColorForPing_Hud( int pingType, bool isSameTeam )
{
	vector color
	switch( pingType )
	{

		case ePingType.ENEMY_GENERAL:
		case ePingType.ENEMY_SHIELD:
		case ePingType.ENEMY_SMOKE:
		case ePingType.TOXIC_GAS:
		case ePingType.ENEMY_SPECIFIC:

		case ePingType.ENEMY_HEALING_HEALTH:
		case ePingType.ENEMY_HEALING_SHIELD:

		case ePingType.ENEMY_REVIVING:
		case ePingType.ENEMY_TELEPORTER:
		case ePingType.ENEMY_TRAP:
		case ePingType.ENEMY_TESLA_TRAP:
		case ePingType.ENEMY_TROPHY_SYSTEM:
		case ePingType.ASH_PASSIVE_ID_ATTACKER:




			color = <1.0, 0.0, 0.0>
			break


		case ePingType.MARK_MY_LAST_DEATH_BOX:


		case ePingType.MARK_MY_LAST_DEATH_LOCATION:

		case ePingType.I_GO:
		case ePingType.WE_GO:
		case ePingType.MAP_WAYPOINT:
			color = <1.0, 0.7, 0.2>
			break

		case ePingType.BLEEDOUT:
			if ( isSameTeam )
				color = SrgbToLinear( GetKeyColor( COLORID_HUD_BLEEDOUT_COLOR ) / 255.0 )
			else
				color = 0.25 * (<1, 1, 1> + SrgbToLinear( GetKeyColor( COLORID_HUD_BLEEDOUT_COLOR ) / 255.0 ))
			break

		case ePingType.RESPAWN_BANNER:
			color = SrgbToLinear( GetKeyColor( COLORID_HUD_HEAL_COLOR ) / 255.0 )
			break







		default:
			color = <1.0, 1.0, 1.0>
	}

	return color
}







string function Ping_GetLabelForPingType( int pingType )
{
	return Ping_GetMenuOptionTextForPing( pingType )
}




string function Ping_GetPromptForPing( entity player, entity wp, int pingType )
{

	array<int> replies = GetReplyOptionsForWaypoint( player, wp )
	if ( (replies.len() == 0) || (replies[0] == ePingReply.BLANK) )
		return ""

	ReplyCommsActionInfo caInfo = Ping_GetCommsActionForWaypointReply( player, wp, replies[0] )
	string promptText           = GetMenuOptionTextForCommsAction( caInfo.commsAction )
	return (promptText + " `1%ping%`0")
}







void function OnPingCreatedByAnyPlayer_VocalizeNewPing( entity pingingPlayer, int pingType, entity pingedEnt, vector pingLoc, entity wayPoint )
{
	if ( !Waypoint_ShouldPlayCreationEffectWaypoint( wayPoint ) )
		return

	int commsAction = GetCommsActionForPing( pingingPlayer, pingType, pingedEnt )
	int secondaryCommsAction = 0
	int commsActionCount = Waypoint_GetQuantityForWaypoint( wayPoint )







		if(commsAction == eCommsAction.PING_I_ULTIMATE)
		{
			if ( IsLocalClientPlayer( pingingPlayer ) )
			{
				Quickchat( commsAction, null )
			}
			return
		}


	int itemIndex = -1

	if( commsAction == eCommsAction.REPLY_CAREPACKAGE_INSIGHT || commsAction == eCommsAction.REPLY_CAREPACKAGE_INSIGHT_LOOTED )
	{
		string lootRef = wayPoint.GetWaypointString( 0 )
		LootData data = SURVIVAL_Loot_GetLootDataByRef( lootRef )
		itemIndex = data.index
	}


	HandleBroadcastCommsAction( pingingPlayer, commsAction, pingedEnt, pingLoc, eCommsFlags.NONE, itemIndex, commsActionCount, secondaryCommsAction, wayPoint.GetWaypointGametime( 1 ) )
}




int function GetPingLootCommsAction( entity ent )
{
	LootData data = SURVIVAL_Loot_GetLootDataByIndex( ent.GetSurvivalInt() )
	return data.pingCommsAction
}




array< void functionref( entity, int, entity, vector, entity ) > s_onCreateClientPingCallbacks
void function AddCallback_OnPingCreatedByAnyPlayer( void functionref( entity, int, entity, vector, entity ) func )
{
	s_onCreateClientPingCallbacks.append( func )
}




void function ExecuteCallbacks_OnPingCreatedByAnyPlayer( entity pingingPlayer, int pingType, entity focusEnt, vector pingLoc, entity wp )
{
	if ( !IsValid( pingingPlayer ) )
		return

	foreach ( func in s_onCreateClientPingCallbacks )
		func( pingingPlayer, pingType, focusEnt, pingLoc, wp )
}




void function DoLocalPingConfirm( vector origin, int pingType, entity pingedEnt, bool doSound )
{
	if ( doSound )
		EmitSoundOnEntity( GetLocalViewPlayer(), PING_SOUND_LOCAL_CONFIRM )

	var rui = CreateTransientFullscreenRui( $"ui/waypoint_confirm_entpos.rpak", 200 )
	RuiSetString( rui, "promptText", "" )
	RuiSetImage( rui, "iconImage", $"rui/hud/gametype_icons/obj_foreground_diamond" )    
	RuiSetFloat3( rui, "targetPos", origin )
	RuiSetFloat3( rui, "iconColor", SrgbToLinear( Ping_IconColorForPing_Hud( pingType, true ) ) )
	RuiSetFloat( rui, "iconSize", 32.0 )
	RuiSetFloat( rui, "iconSizePinned", 32.0 )
	RuiSetBool( rui, "isFinished", true )
}




var s_pendingPingRui = null
void function PendingPingMarkerStart( vector origin, int pingType )
{
	PendingPingMarkerStop()

	var rui = CreateTransientFullscreenRui( $"ui/ping_pending_marker.rpak", 210 )
	RuiSetImage( rui, "iconImage", $"rui/hud/gametype_icons/obj_foreground_diamond" )    
	RuiSetFloat3( rui, "targetPos", origin )

	s_pendingPingRui = rui
}




void function PendingPingMarkerStop()
{
	if ( s_pendingPingRui == null )
		return

	RuiDestroyIfAlive( s_pendingPingRui )
	s_pendingPingRui = null
}




int s_latestTicketID = -1
int function GetNewTicketID()
{
	++s_latestTicketID
	return s_latestTicketID
}




int function GetLatestTicketID()
{
	return s_latestTicketID
}




void function Send_PingLoot( entity player, entity lootEnt, entity deathBox )
{
	if ( !IsValid( lootEnt ) )
		return

	if ( IsValid( player ) && !player.DoesShareRealms( lootEnt ) )
		return

	int ticketID  = GetNewTicketID()
	vector origin = lootEnt.GetOrigin()

	if ( IsValid( deathBox ) )
	{
		switch ( deathBox.GetNetworkedClassName() )
		{
			case "prop_death_box":
			{
				Remote_ServerCallFunction( CMDNAME_PING_NEW_LOOT_DEATHBOX, lootEnt, deathBox, ticketID, origin )
				break
			}
			case "prop_loot_grabber":
			{
				origin = deathBox.GetOrigin()
				Remote_ServerCallFunction( CMDNAME_PING_NEW_LOOT_GRABBER, lootEnt, deathBox, ticketID, origin )
				break
			}
			default:
			{
				Assert( false, "Attempted to pick up from non known box entity of type: " + string( deathBox.GetNetworkedClassName() ) )
				break
			}
		}
	}
	else
	{
		Remote_ServerCallFunction( CMDNAME_PING_NEW_LOOT_OUTSIDE_DEATHBOX, lootEnt, ticketID, origin )
	}

	lootEnt.e.localPingBeginTime = Time()
	DoLocalPingConfirm( origin, ePingType.LOOT, lootEnt, true )
}




void function PingGroundLoot( entity lootEnt, entity deathBox )
{
	if ( !IsValid( lootEnt ) )
		return

	entity player = GetLocalViewPlayer()
	DoPlayerDefaultPingForLootEntity( player, lootEnt, deathBox )
}




struct
{
	int[5] ticketIDs = [-1, -1, -1, -1, -1]
	int    latestIndex = -1
} s_cancelRecord




void function RecordCanceledPing( int ticketID )
{
	s_cancelRecord.latestIndex = ((s_cancelRecord.latestIndex + 1) % s_cancelRecord.ticketIDs.len())
	s_cancelRecord.ticketIDs[s_cancelRecord.latestIndex] = ticketID
}




bool function Ping_TicketIDIsLocallyCanceled( int ticketID )
{
	if ( ticketID < 0 )
		return false

	foreach ( int id in s_cancelRecord.ticketIDs )
	{
		if ( id == ticketID )
			return true
	}

	return false
}




void function CancelLatestWaypoint( entity player )
{
	CancelWaypointByTicketID( player, GetLatestTicketID() )
}




void function CancelWaypointByTicketID( entity player, int ticketID )
{
	if ( ticketID < 0 )
		return

	Remote_ServerCallFunction( CMDNAME_CANCEL_PING_BY_TICKETID, ticketID )

	RecordCanceledPing( ticketID )

	entity wp = Waypoint_FindPingByTicketID( player, ticketID )
	if ( IsValid( wp ) )
		Waypoint_HideOnLocalHud( wp )
}




void function Send_PingReply( entity player, entity wp, int pingReply )
{
	switch( pingReply )
	{
		case ePingReply.OWNER_CANCEL:
			EmitSoundOnEntity( player, PING_SOUND_UNDO )
			Waypoint_HideOnLocalHud( wp )
			
			break

		case ePingReply.JOIN:
		case ePingReply.OK:
		case ePingReply.NEGATIVE:
		case ePingReply.I_CANNOT:
		case ePingReply.THANKS:
		case ePingReply.COMING_TO_HELP:
		case ePingReply.HOLD_ON:
			Waypoint_MarkAsAcknowledgedLocally( wp )
			EmitSoundOnEntity( GetLocalViewPlayer(), PING_SOUND_ACKNOWLEDGE )
			break
		case ePingReply.SPAWN_HERE:
			EmitSoundOnEntity( GetLocalViewPlayer(), PING_SOUND_ACKNOWLEDGE )
			foreach( func in file.spawnWPFunctionCallbacks)
				func ( player, wp )
			return
			break

		default:
			EmitSoundOnEntity( GetLocalViewPlayer(), PING_SOUND_ACKNOWLEDGE )
	}

	Remote_ServerCallFunction( CMDNAME_PING_REPLY, wp, pingReply )
}




void function Ping_ClearMapWaypoint( entity player )
{
	CancelWaypointByTicketID( player, player.p.mapPingTicketID )
}




void function Ping_SetMapWaypoint( entity player, vector origin, bool pingEnemy = false )
{
	if ( !IsAlive( player ) )
		return

	if ( !IsPingEnabledForPlayer( player ) )
		return

	int ticketID = GetNewTicketID()

	if( !pingEnemy )
		Remote_ServerCallFunction( CMDNAME_PING_MAP_WAYPOINT, int( origin.x ), int( origin.y ), ticketID, false )
	else
		Remote_ServerCallFunction( CMDNAME_PING_MAP_WAYPOINT, int( origin.x ), int( origin.y ), ticketID, true )








	EmitSoundOnEntity( GetLocalViewPlayer(), PING_SOUND_LOCAL_CONFIRM )
}









































































































































































































































































































































































































































































bool function TryOnscreenPromptFunction( entity player, string commandRef )
{
	if ( commandRef in file.lastOnscreenPromptFunctionTriggerTime )
	{
		if ( file.lastOnscreenPromptFunctionTriggerTime[ commandRef ] == Time() )
			return true
	}

	
	

	if ( !(commandRef in file.onscreenPromptFunctions) )
		return false

	UpdateOnscreenPromptFunctions( commandRef )

	if ( file.onscreenPromptFunctions[ commandRef ].len() > 0 )
	{
		OnscreenPromptData data = file.onscreenPromptFunctions[commandRef][0]
		data.onscreenPromptFunction( player )

		{
			HidePlayerHint( data.hint )
			file.onscreenPromptFunctions[commandRef].remove( 0 )
			ShowNextOnscreenPromptFunctionHint( commandRef )

			if ( file.warnRui != null )
				RuiSetGameTime( file.warnRui, "activateTime", Time() )

			file.lastOnscreenPromptFunctionTriggerTime[ commandRef ] = Time()
			return true
		}
	}

	return false
}




int function SortByTimeout( OnscreenPromptData a, OnscreenPromptData b )
{
	if ( a.timeout < b.timeout )
		return -1

	if ( a.timeout > b.timeout )
		return 1

	return 0
}




int function SortByPriority( OnscreenPromptData a, OnscreenPromptData b )
{
	if ( a.priority < b.priority )
		return 1

	if ( a.priority > b.priority )
		return -1

	return 0
}







void function AddOnscreenPromptFunction( string commandRef, void functionref(entity) onscreenPromptFunction, float duration, string hint, int priority = 1 )

{
	if ( !(commandRef in file.onscreenPromptFunctions) )
		file.onscreenPromptFunctions[ commandRef ] <- []

	if ( !(commandRef in file.lastOnscreenPromptFunctionTriggerTime) )
		file.lastOnscreenPromptFunctionTriggerTime[ commandRef ] <- 0.0

	OnscreenPromptData data
	data.onscreenPromptFunction = onscreenPromptFunction
	data.timeout = Time() + duration
	data.hint = hint
	data.priority = priority



	bool updatedExisting = false
	foreach ( d in file.onscreenPromptFunctions[ commandRef ] )
	{
		if ( d.onscreenPromptFunction == onscreenPromptFunction )
		{
			d.hint = hint
			d.timeout = Time() + duration
		}
	}

	if ( !updatedExisting )
		file.onscreenPromptFunctions[ commandRef ].append( data )

	UpdateOnscreenPromptFunctions( commandRef )
	ShowNextOnscreenPromptFunctionHint( commandRef )
}




void function ShowNextOnscreenPromptFunctionHint( string commandRef )
{
	if ( file.onscreenPromptFunctions[ commandRef ].len() > 0 )
	{
		OnscreenPromptData firstData = file.onscreenPromptFunctions[ commandRef ][0]



		CreateOnscreenPromptHint( firstData.hint, firstData.timeout )

		thread UpdateOnscreenPromptHintAfterDelay( firstData.timeout - Time(), commandRef )
	}
}




void function UpdateOnscreenPromptFunctions( string commandRef )
{
	for ( int i = file.onscreenPromptFunctions[ commandRef ].len() - 1; i >= 0; i-- )
	{
		if ( Time() > file.onscreenPromptFunctions[ commandRef ][i].timeout )
		{
			file.onscreenPromptFunctions[ commandRef ].remove( i )
		}
	}

	file.onscreenPromptFunctions[ commandRef ].sort( SortByPriority )
}







void function CreateOnscreenPromptHint( string msg, float endTime )

{
	if ( file.warnRui != null )
	{
		RuiDestroy( file.warnRui )
	}

	file.warnRui = CreateFullscreenRui( $"ui/wraith_comms_hint.rpak" )
	RuiSetGameTime( file.warnRui, "startTime", Time() )
	RuiSetGameTime( file.warnRui, "endTime", endTime )
	RuiSetBool( file.warnRui, "commsMenuOpen", IsCommsMenuActive() )
	RuiSetString( file.warnRui, "msg", msg )














}




void function OnCommsMenuChanged( bool menuOpened )
{
	if ( file.warnRui != null )
	{
		RuiSetBool( file.warnRui, "commsMenuOpen", menuOpened )
	}
}




void function OnLifeStateChanged( entity player, int oldState, int newState )
{
	if ( player == GetLocalClientPlayer() )
	{
		if ( newState == LIFE_DYING || newState == LIFE_DEAD )
		{
			if ( file.warnRui != null )
			{
				RuiDestroy( file.warnRui )
				file.warnRui = null
			}
		}
	}
}




void function UpdateOnscreenPromptHintAfterDelay( float delay, string commandRef )
{
	clGlobal.levelEnt.Signal( "UpdateOnscreenPromptHintAfterDelay" )
	clGlobal.levelEnt.EndSignal( "UpdateOnscreenPromptHintAfterDelay" )

	wait delay

	WaitEndFrame()

	UpdateOnscreenPromptFunctions( commandRef )
	ShowNextOnscreenPromptFunctionHint( commandRef )
}























































































































#if DEV
void function DEV_Ping_devPrintsOn( bool isOn = true )
{
	printt( "***** sh_ping: DEV Printing Set To " + isOn )
	file.devPrintsOn = isOn
}
#endif


void function AddCallback_OnPingSpawnRequest( void functionref( entity, entity ) func )
{
	file.spawnWPFunctionCallbacks.append( func )
}










bool function CaptureObjectivePing_IsUsingCaptureObjectivePings()
{
	return GetCurrentPlaylistVarBool( "is_using_capture_objective_pings", false )
}














































































void function CaptureObjectivePing_OnPlayerWaypointCreated( entity wp )
{
	if ( IsValid( wp ) && wp.GetWaypointType() == eWaypoint.PING_LOCATION && IsValid( wp.GetOwner() ) )
	{
		entity objectiveWaypoint = wp.GetOwner()

		if ( objectiveWaypoint.GetNetworkedClassName() != PLAYER_WAYPOINT_CLASSNAME )
			return

		if ( CaptureObjectivePing_GetIsCaptureObjectivePingObjectiveWaypoint( objectiveWaypoint ) && !file.captureObjectivePingStarterPings.contains( wp ) )
			file.captureObjectivePingStarterPings.append( wp )
	}
}




void function CaptureObjectivePing_OnPlayerWaypointDestroyed( entity wp )
{
	if ( IsValid( wp ) && wp.GetWaypointType() == eWaypoint.PING_LOCATION && IsValid( wp.GetOwner() ) && file.captureObjectivePingStarterPings.contains( wp ) )
		file.captureObjectivePingStarterPings.fastremovebyvalue( wp )
}




array < entity > function CaptureObjectivePing_GetStarterPingsArray()
{
	return file.captureObjectivePingStarterPings
}




void function CaptureObjectivePing_AddCallback_SetIsCaptureObjectivePingObjectiveWaypoint( bool functionref( entity ) func )
{
	file.getIsCaptureObjectivePingObjectiveWPFunction = func
}




bool function CaptureObjectivePing_GetIsCaptureObjectivePingObjectiveWaypoint( entity waypoint )
{
	if ( file.getIsCaptureObjectivePingObjectiveWPFunction == null )
	{
		Assert( false, "CAPTURE OBJECTIVE PING: Running " + FUNC_NAME() + " with no function defined to check if a waypoint is an objective waypoint, make sure a function is set using CaptureObjectivePing_AddCallback_SetIsCaptureObjectivePingObjectiveWaypoint" )
		return false
	}

	return file.getIsCaptureObjectivePingObjectiveWPFunction( waypoint )
}








































































































































































void function CaptureObjectivePing_AddCallback_OnObjectivePingCoundChanged( void functionref( entity, int, int ) callBackFunc )
{
	Assert( !file.onObjectivePingCountChangedCallbackFunctions.contains( callBackFunc ), "Already added " + string( callBackFunc ) + " with " + FUNC_NAME() )
	file.onObjectivePingCountChangedCallbackFunctions.append( callBackFunc )
}




bool function CaptureObjectivePing_DidPlayerPingSameObjective( entity player, entity wp, entity pingEnt )
{
	if ( !IsValid( pingEnt ) || !IsValid( player ) || !IsValid( wp ) )
		return false

	entity objectiveWaypoint = pingEnt.GetOwner()
	if ( CaptureObjectivePing_GetIsCaptureObjectivePingObjectiveWaypoint( objectiveWaypoint ) )
	{

			entity oldPing = file.lastLocalCaptureObjectivePing
			if ( IsValid( oldPing ) && oldPing == wp )
				return true










	}
	return false
}




void function ServerCallback_CaptureObjectivePing_UpdateLastPingedObjective( entity pingingPlayer, entity wp, entity pingedEnt, bool isDestroying )
{
	entity localPlayer = GetLocalViewPlayer()

	if ( !IsValid( wp ) || !IsValid( pingedEnt ) ||!IsValid( pingingPlayer ) || !IsValid( localPlayer ) )
		return

	if ( pingingPlayer != localPlayer )
		return

	entity objectiveWaypoint = pingedEnt.GetOwner()
	if ( CaptureObjectivePing_GetIsCaptureObjectivePingObjectiveWaypoint( objectiveWaypoint ) )
	{
		if ( isDestroying )
			file.lastLocalCaptureObjectivePing = null
		else
			file.lastLocalCaptureObjectivePing = wp
	}
}




entity function CaptureObjectivePing_GetLastPingedObjective()
{
	return file.lastLocalCaptureObjectivePing
}





void function ServerCallback_CaptureObjectivePing_UpdateObjectivePingText( entity wp, int pingType, int pingCount, bool doesPlayerHavePingOnObjective )
{
	if ( IsValid( wp ) && IsValid( wp.wp.ruiHud ) && pingCount >= 0 )
	{
		if ( pingType == ePingType.PING_CAPTURE_OBJECTIVE_DEFEND || pingType == ePingType.PING_CAPTURE_OBJECTIVE_ATTACK )
		{
			
			string promptText = ""

			if ( pingCount <= 0 ) 
			{
				promptText = Localize( "#PROMPT_PING_CONTROL_OBJECTIVE" )
			}
			else 
			{
				if ( doesPlayerHavePingOnObjective )
				{
					if ( pingCount == 1 ) 
					{
						promptText = Localize( "#PROMPT_CANCELED_PING" )
					}
					else 
					{
						promptText = Localize( "#PROMPT_PING_CONTROL_OBJECTIVE_CANCEL", pingCount )
					}
				}
				else 
				{
					promptText = Localize( "#PROMPT_PING_CONTROL_OBJECTIVE_JOIN", pingCount )
				}
			}

			promptText = promptText + " `1%ping%`0"
			RuiSetString( wp.wp.ruiHud, "pingPrompt", promptText )
		}
	}
}




void function ServerCallback_CaptureObjectivePing_UpdateObjectivePingCounts( entity objectiveWaypoint, int teamOrAlliance, int count )
{
	
	Assert( file.objectiveToCaptureObjectivePingCountTableArray.len() > teamOrAlliance, "CAPTURE OBJECTIVE PING: " + FUNC_NAME() + " Tried to grab a table of objective pings to ping count for teamOrAlliance: " + teamOrAlliance + " but the array didn't contain the teamOrAlliance index" )
	if ( file.objectiveToCaptureObjectivePingCountTableArray.len() <= teamOrAlliance )
		return

	
	int pingCountMax = AllianceProximity_IsUsingAlliances() ? AllianceProximity_GetMaxNumPlayersPerAlliance() + 1 : GetExpectedSquadSize() + 1
	if ( count < 0 || count > pingCountMax )
		return

	if ( CaptureObjectivePing_GetIsCaptureObjectivePingObjectiveWaypoint( objectiveWaypoint ) )
	{
		file.objectiveToCaptureObjectivePingCountTableArray[ teamOrAlliance ][ objectiveWaypoint ] <- count

		foreach ( callbackFunc in file.onObjectivePingCountChangedCallbackFunctions )
		{
			callbackFunc( objectiveWaypoint, teamOrAlliance, count )
		}
	}
}











































































int function CaptureObjectivePing_GetPingCountForObjectiveForTeamOrAlliance( entity wp, int teamOrAlliance )
{
	int pingCount = 0

	
	Assert( file.objectiveToCaptureObjectivePingCountTableArray.len() > teamOrAlliance, "CAPTURE OBJECTIVE PING: " + FUNC_NAME() + " Tried to grab a table of objective pings to ping count for teamOrAlliance: " + teamOrAlliance + " but the array didn't contain the teamOrAlliance index" )
	if ( file.objectiveToCaptureObjectivePingCountTableArray.len() <= teamOrAlliance )
		return pingCount

	if ( CaptureObjectivePing_GetIsCaptureObjectivePingObjectiveWaypoint( wp ) && wp in file.objectiveToCaptureObjectivePingCountTableArray[ teamOrAlliance ] )
		pingCount = file.objectiveToCaptureObjectivePingCountTableArray[ teamOrAlliance ][ wp ]

	return pingCount
}













































































































void function CaptureObjectivePing_AddCallback_SetIsCaptureObjectivePingCommsActionFunction( bool functionref( int, entity ) func )
{
	file.getIsCommsActionForCaptureObjectivePingFunction = func
}




bool function CaptureObjectivePing_GetIsCaptureObjectivePingCommsAction( int commsAction, entity subjectEnt )
{
	if ( file.getIsCommsActionForCaptureObjectivePingFunction == null )
		return false

	return file.getIsCommsActionForCaptureObjectivePingFunction( commsAction, subjectEnt )
}




void function CaptureObjectivePing_AddCallback_SetGetCaptureObjectiveIDFromWaypointFunction( int functionref( entity ) func )
{
	file.getCaptureObjectiveIDFromWaypointFunction = func
}




const int INVALD_WAYPOINT_INDEX = -1
int function CaptureObjectivePing_GetObjectiveIndexFromWaypoint( entity waypoint )
{
	if ( file.getCaptureObjectiveIDFromWaypointFunction == null )
	{
		Assert( false, "CAPTURE OBJECTIVE PING: Running " + FUNC_NAME() + " with no function defined to grab the objective ID, make sure a function is set using CaptureObjectivePing_AddCallback_SetGetCaptureObjectiveIDFromWaypointFunction" )
		return INVALD_WAYPOINT_INDEX
	}

	return file.getCaptureObjectiveIDFromWaypointFunction( waypoint )
}



const array<string> CAPTUREOBJECTIVE_OBJECTIVE_NAME_STRINGS = ["#CONTROL_OBJECTIVE_A", "#CONTROL_OBJECTIVE_B", "#CONTROL_OBJECTIVE_C", "#CONTROL_OBJECTIVE_D", "#CONTROL_OBJECTIVE_E", "#CONTROL_OBJECTIVE_F", "#CONTROL_OBJECTIVE_G", "#CONTROL_OBJECTIVE_H", "#CONTROL_OBJECTIVE_I", "#CONTROL_OBJECTIVE_J" ]


array<string> function CaptureObjectivePing_GetObjectiveNameStringsArray()
{
	return CAPTUREOBJECTIVE_OBJECTIVE_NAME_STRINGS
}




string function CaptureObjectivePing_GetObjectiveNameFromObjectiveID_Localized( int objectiveID )
{
	return Localize( CaptureObjectivePing_GetObjectiveNameStringsArray()[objectiveID] )
}
























void function CaptureObjectivePing_AddCallback_SetGetObjectivesArrayFunction( array < entity > functionref() func )
{
	file.getCaptureObjectivesArrayFunction = func
}




array < entity > function CaptureObjectivePing_GetGetObjectivesCloneArray()
{
	if ( file.getCaptureObjectivesArrayFunction == null )
	{
		Assert( false, "CAPTURE OBJECTIVE PING: Running " + FUNC_NAME() + " with no function defined to grab an array of objectives, make sure a function is set using CaptureObjectivePing_AddCallback_SetGetObjectivesArrayFunction" )
		return []
	}

	return clone file.getCaptureObjectivesArrayFunction() 
}




entity function CaptureObjectivePing_GetObjectiveUnderAim( vector worldPos, float adjustedRange )
{
	float closestDistSqr = FLT_MAX
	entity closestEnt
	array<entity> objectiveArray = CaptureObjectivePing_GetGetObjectivesCloneArray()
	foreach ( objective in objectiveArray )
	{
		if ( !IsValid( objective ) )
			continue

		vector objectiveOrigin = objective.GetOrigin()
		if ( fabs( objectiveOrigin.x - worldPos.x ) > adjustedRange || fabs( objectiveOrigin.y - worldPos.y ) > adjustedRange )
			continue

		float distSqr = Distance2DSqr( objectiveOrigin, worldPos )
		if ( distSqr < closestDistSqr )
		{
			closestDistSqr = distSqr
			closestEnt     = objective
		}
	}

	return closestEnt
}




bool function CaptureObjectivePing_PingObjectiveUnderAim( entity objective )
{
	entity player = GetLocalClientPlayer()

	if ( !IsValid( player ) )
		return false

	CaptureObjectivePing_SetObjectivePing( player, objective )
	return true
}




void function CaptureObjectivePing_SetObjectivePing( entity player, entity objective )
{
	if ( !IsPingEnabledForPlayer( player ) )
		return

	Remote_ServerCallFunction( "ClientCallback_CaptureObjectivePing_PingObjective", objective )

	EmitSoundOnEntity( GetLocalViewPlayer(), PING_SOUND_LOCAL_CONFIRM )
}




















































#if DEV
void function DEV_PingAllLoot_Client( entity player )
{
	thread DEV_PingAllLoot_Thread( player )
}
void function DEV_PingAllLoot_Thread( entity player )
{
	int s_latestTicketID = -1
	foreach (entity lootEnt in GetClientEntArrayBySignifier("prop_survival"))
	{
		int ticketID  = ++s_latestTicketID
		vector origin = lootEnt.GetOrigin()

		Remote_ServerCallFunction( "ClientCallback_PingNewLootOutsideDeathbox", lootEnt, ticketID, origin )
		wait 0.00001
	}
}
#endif

