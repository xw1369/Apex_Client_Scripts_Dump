


global function ShLootBin_Init



global function CanAccessSecretCompartments
global function LootBin_IsOpenAtAll
global function LootBin_IsFullyOpenedForPlayer
global function LootBin_IsBusy
global function LootBin_HasSecretCompartment
global function LootBin_HasUnopenedSecretCompartment
global function LootBin_GetSpawnedLoot
global function GetLootBinForHitEnt
global function GetAllLootBins
global function AddCallback_OnLootBinOpening
global function AddCallback_CanOpenLootBin




















































global function CL_LootBinOpening








global const string SUPPORT_LOOT_BIN_SKIN_NAME = "Blue_Turbo"





global const string LOOT_BIN_DELAY_LOOT_SPAWNING_PLAYLIST_VAR = "survival_lootbin_delay_loot_spawning"


global const string LOOT_BIN_MARKER_SCRIPTNAME = "survival_lootbin"
global const string LOOT_BIN_SCRIPTNAME = "survival_lootbin_spawned"

global const asset LOOT_BIN_MODEL = $"mdl/props/loot_bin/loot_bin_01_loba.rmdl"

global const asset LOOT_BIN_OPEN_REGULAR_FX = $"P_LootBin_open"
global const asset LOOT_BIN_OPEN_SECRET_FX = $"P_LootBin_open_lower"


const bool SURVIVAL_DEBUG_LOOT_BINS = false




global enum eLootBinCompartment
{
	REGULAR,
	SECRET,
	BOTH,
	_COUNT
}
global enum lootBinType
{
	REGULAR,

	MUNITIONS,
	SUPPORT

}

global enum eLootBinSequenceKind
{
	OPEN_REGULAR,
	OPEN_SECRET,
	OPEN_BOTH,
	CLOSE_REGULAR,
	
	CLOSE_BOTH,
}






global typedef OnLootBinOpeningCallbackType void functionref( entity )








































































































struct
{

		array<OnLootBinOpeningCallbackType> onLootBinOpeningCallbacks
		table<entity, bool functionref(entity,entity)> canOpenLootBinCallback









} file




void function ShLootBin_Init()
{
	PrecacheModel( LOOT_BIN_MODEL )
	PrecacheScriptString( LOOT_BIN_SCRIPTNAME )
	PrecacheParticleSystem( LOOT_BIN_OPEN_REGULAR_FX )
	PrecacheParticleSystem( LOOT_BIN_OPEN_SECRET_FX )













		AddCreateCallback( "prop_dynamic", OnPropCreated )
		AddDestroyCallback( "prop_dynamic", OnPropDestroyed )
		AddCreateCallback( "prop_script", OnPropCreated )
		AddDestroyCallback( "prop_script", OnPropDestroyed )

}




array<entity> function GetAllLootBins()
{



		return GetEntArrayByScriptName( LOOT_BIN_SCRIPTNAME )

}












void function AddCallback_OnLootBinOpening( OnLootBinOpeningCallbackType callbackFunc )
{
	Assert( !file.onLootBinOpeningCallbacks.contains( callbackFunc ), "Already added " + string( callbackFunc ) + " with Survival_AddCallback_OnLootbinOpened" )
	file.onLootBinOpeningCallbacks.append( callbackFunc )
}





































































































































































































































































































































































































































































































































































































bool function LootBin_HasSecretCompartment( entity lootBin )
{



		Assert( lootBin.GetScriptName() == LOOT_BIN_SCRIPTNAME || lootBin.GetScriptName() == LOOT_BIN_MARKER_SCRIPTNAME )






	if( lootBin.GetSkin() == lootBin.GetSkinIndexByName( SUPPORT_LOOT_BIN_SKIN_NAME ) )
		return true


	if( lootBin.GetSkin() == lootBin.GetSkinIndexByName( MUNITIONS_BOX_LOOT_BIN_SKIN_NAME ) )
		return true







	return false
}



bool function LootBin_HasUnopenedSecretCompartment( entity lootBin )
{
	Assert( lootBin.GetScriptName() == LOOT_BIN_SCRIPTNAME || lootBin.GetScriptName() == LOOT_BIN_MARKER_SCRIPTNAME )

	if ( lootBin.GetNetworkedClassName() != "prop_dynamic" )
		return false

	if (LootBin_HasSecretCompartment( lootBin ) == false)
		return false

	if (GradeFlagsHas( lootBin, eGradeFlags.IS_OPEN_SECRET ) == true)
		return false

	return true
}



array<entity> function LootBin_GetSpawnedLoot( entity lootBin, bool includeRegular, bool includeSecret )
{

		Assert( includeRegular && includeSecret, "Cannot distinguish between regular and secret compartments on CLIENT -- must include both" )


	array<entity> out = []
	foreach ( entity child in lootBin.GetChildren() )
	{
		if ( child.GetNetworkedClassName() != "prop_survival" )
			continue









		out.append( child )
	}
	return out
}



































































































































































































































































































































































































































































































































































































































void function CL_LootBinOpening( entity lootBin, int sequenceType )
{
	foreach ( OnLootBinOpeningCallbackType cb in file.onLootBinOpeningCallbacks )
		cb( lootBin )
}




bool function CanAccessSecretCompartments( entity lootBin, entity player )
{
	
	if ( !LootBin_HasSecretCompartment( lootBin ) )
		return false

	if ( !IsValid( player ) )
		return false




		
		bool canOpenCompartment

		if(lootBin.GetSkin() == lootBin.GetSkinIndexByName( MUNITIONS_BOX_LOOT_BIN_SKIN_NAME ) && Perks_DoesPlayerHavePerk( player, ePerkIndex.MUNITIONS_BOX ))
			canOpenCompartment = true
		else if(lootBin.GetSkin() == lootBin.GetSkinIndexByName( LOOT_BIN_SUPPORT_SKIN ) && Perks_DoesPlayerHavePerk( player, ePerkIndex.EXTRA_BIN_LOOT ))
			canOpenCompartment = true




		else
			canOpenCompartment = false



	return canOpenCompartment
}




bool function LootBin_IsOpenAtAll( entity lootBin )
{
	return GradeFlagsHas( lootBin, eGradeFlags.IS_OPEN ) || GradeFlagsHas( lootBin, eGradeFlags.IS_OPEN_SECRET )
}




bool function LootBin_IsFullyOpenedForPlayer( entity lootBin, entity player )
{
	if ( !GradeFlagsHas( lootBin, eGradeFlags.IS_OPEN ) )
		return false

	if ( CanAccessSecretCompartments( lootBin, player ) && !GradeFlagsHas( lootBin, eGradeFlags.IS_OPEN_SECRET ) )
		return false

	return true
}




bool function LootBin_CanBeClosed( entity lootBin )
{
	if ( IsInfiniteLootBinsEnabled() )
		return true

	return false
}




bool function IsInfiniteLootBinsEnabled()
{
#if DEV
		if ( GetBugReproNum() == 50 )
			return true
#endif

	return GetCurrentPlaylistVarBool( "lootbins_infinite", false )
}




bool function LootBin_IsBusy( entity lootBin )
{
	return GradeFlagsHas( lootBin, eGradeFlags.IS_BUSY )
}




void function OnPropCreated( entity lootBin )
{
	if ( lootBin.GetScriptName() != LOOT_BIN_SCRIPTNAME )
		return

	AddEntityCallback_GetUseEntOverrideText( lootBin, GetLootBinUseTextOverride )
	SetCallback_CanUseEntityCallback( lootBin, CanUseLootBin )
}




void function OnPropDestroyed( entity lootBin )
{
	
}




entity function GetLootBinForHitEnt( entity hitEnt )
{
	if ( hitEnt.GetScriptName() == LOOT_BIN_SCRIPTNAME )
		return hitEnt

	entity parentEnt = hitEnt.GetParent()
	if ( IsValid( parentEnt ) && parentEnt.GetScriptName() == LOOT_BIN_SCRIPTNAME )
		return parentEnt

	return null
}




void function AddCallback_CanOpenLootBin( entity lootBin, bool functionref( entity,entity ) callback )
{
	file.canOpenLootBinCallback[lootBin] <- callback
}

bool function CanUseLootBin( entity player, entity lootBin, int useFlags )
{

	if( lootBin in file.canOpenLootBinCallback )
	{
		if( !file.canOpenLootBinCallback[lootBin]( player, lootBin ) )
			return false
	}


	if ( player.GetWeaponDisableFlags() == WEAPON_DISABLE_FLAGS_ALL )
		return false

	if ( Bleedout_IsBleedingOut( player ) )
		return false

	if ( LootBin_IsBusy( lootBin ) )
		return false


	if ( LootBin_IsFullyOpenedForPlayer( lootBin, player ) )
		return false


	return true
}




string function GetLootBinUseTextOverride( entity lootBin )
{
	entity player = GetLocalViewPlayer()








	if ( !LootBin_IsFullyOpenedForPlayer( lootBin, player ) )
	{
		if ( GradeFlagsHas( lootBin, eGradeFlags.IS_LOCKED ) )
		{
			if ( IsValid( lootBin.GetOwner() ) )
			{
				entity lootBinOwner = lootBin.GetOwner()

				EHI ornull ehi = ToEHI( lootBinOwner )
				if ( ehi == null )
					return ""
				expect EHI( ehi )
				if ( !EHIHasValidScriptStruct( ehi ) )
					return ""

				int team          = EHI_GetTeam( ehi )
				string playerName = GetDisplayablePlayerNameFromEHI( ehi )

				string hint = "#SURVIVAL_LOOTBIN_LOCKED_FRIENDLY"

				if ( lootBinOwner == player || GetCurrentPlaylistVarBool( "lootbin_locking_disabled", false ) )
					hint = "#SURVIVAL_LOOTBIN_LOCKED_SELF"
				else if ( IsEnemyTeam( team, player.GetTeam() ) )
					hint = "#SURVIVAL_LOOTBIN_LOCKED_ENEMY"

				return Localize( hint, playerName )
			}
			return "#SURVIVAL_LOOTBIN_LOCKED"
		}
		else if ( !GradeFlagsHas( lootBin, eGradeFlags.IS_OPEN ) )
			return "#SURVIVAL_LOOTBIN_OPEN"

		else if ( !GradeFlagsHas( lootBin, eGradeFlags.IS_OPEN_SECRET ) )
			return "#SURVIVAL_LOOTBIN_OPEN_SECRET"

	}
	else if ( LootBin_CanBeClosed( lootBin ) )
	{
		return "#SURVIVAL_LOOTBIN_CLOSE"
	}
	return ""
}






























































































































































































































































































































































































































