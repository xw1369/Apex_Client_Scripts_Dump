


global function ShQuickchat_Init




global function AddCallback_OnQuickchatEvent
global function PlayerDeliveryShouldBeUrgent
global function PlayerIsInCombat




global function Quickchat
global function HandleBroadcastCommsAction
global function ServerToClient_BroadcastCommsActionToTeam
global function ServerToClient_BroadcastSubjectlessCommsActionToTeam
global function ServerCallback_BroadcastPlayerKicked
global function GetChatTitleColorForPlayer
global function GetMenuOptionTextForCommsAction
global function GetShortTextForCommsAction
global function GetDefaultIconForCommsAction
global function GetPingAssetForCommsAction
global function ShouldMuteCommsActionForCooldown
global function SetCommsDialogueEnabled
global function PlaySoundForCommsAction

global function ClientCodeCallback_GetPlayerThreatLevel












#if DEV
global function DEV_ReloadCommsTable
const bool DEBUG_PLAYER_IS_IN_COMBAT = false
#endif



global enum eCommsFlags
{
	NONE = 0,

	FORCE_URGENT = (1 << 0),
	FORCE_FAR = (1 << 1),
	SILENCE = (1 << 2),
	INCLUDE_DEAD = (1 << 3),
	BROADCAST_TO_WAYPOINT_OWNER = (1 << 4),
	NO_TEXT = (1 << 5),

	_flagCount = 6
}




global struct CommsAction
{
	int index

	string menuText
	string shortText
	string chatText

	array<string> attachmentPoints

	string aliasSubname
	bool   hasCalm
	bool   hasCalmFar
	bool   hasUrgent
	bool   hasUrgentFar
	string subEvent
	string flavorEvent

	asset defaultIcon
	asset pingAsset

	bool hasForcedTempVoice
}




global struct CommsOptions
{
	bool isFirstPerson
	bool isFar
	bool isUrgent
	bool pauseQueue
}




struct
{
	bool                    quickchatInitialized = false
	table<int, CommsAction> actions

		bool  commsDialogueEnabled = true
		float flavorDebounceTime = 120.0 
		float flavorGlobalDebounceTime = 30.0 
		array<int> alwaysPlayFlavorActions = [ eCommsAction.FLAVOR_LOOT_DIBS ]
		table< int, int > replyMap
		table< int, int > altMap

	table< int, array<void functionref( entity player, int eventId, entity subjectEnt )> >    onQuickchatCallbacks




} file




void function LoadCommsActionsFromDatatable()
{
	var dt = GetDataTable( $"datatable/comms_actions.rpak" )

	int col_event            = GetDataTableColumnByName( dt, "event" )
	int col_menuText         = GetDataTableColumnByName( dt, "menuText" )
	int col_shortText        = GetDataTableColumnByName( dt, "shortText" )
	int col_chatText         = GetDataTableColumnByName( dt, "chatText" )
	int col_attachmentPoints = GetDataTableColumnByName( dt, "attachmentPoints" )
	int col_aliasSubname     = GetDataTableColumnByName( dt, "aliasSubname" )
	int col_hasCalm          = GetDataTableColumnByName( dt, "hasCalm" )
	int col_hasCalmFar       = GetDataTableColumnByName( dt, "hasCalmFar" )
	int col_hasUrgent        = GetDataTableColumnByName( dt, "hasUrgent" )
	int col_hasUrgentFar     = GetDataTableColumnByName( dt, "hasUrgentFar" )
	int col_subEvent         = GetDataTableColumnByName( dt, "subEvent" )
	int col_flavorEvent      = GetDataTableColumnByName( dt, "flavorEvent" )
	int col_defaultIcon  		= GetDataTableColumnByName( dt, "defaultIcon" )
	int col_pingAsset    		= GetDataTableColumnByName( dt, "pingAsset" )
	int col_hasForcedTempVoice 	= GetDataTableColumnByName( dt, "hasForcedTempVoice" )

	for ( int row = 0; row < GetDataTableRowCount( dt ); row++ )
	{
		string commsActionName = GetDataTableString( dt, row, col_event )

		asset pingAsset = GetDataTableAsset( dt, row, col_pingAsset )
		if ( pingAsset != $"" )
			RegisterItemFlavorFromSettingsAsset( pingAsset )


			int commsAction = eCommsAction[commsActionName]

			CommsAction action
			action.menuText = GetDataTableString( dt, row, col_menuText )
			action.shortText = GetDataTableString( dt, row, col_shortText )
			action.chatText = GetDataTableString( dt, row, col_chatText )
			action.attachmentPoints = split( GetDataTableString( dt, row, col_attachmentPoints ), WHITESPACE_CHARACTERS )
			action.aliasSubname = GetDataTableString( dt, row, col_aliasSubname )
			action.hasCalm = GetDataTableBool( dt, row, col_hasCalm )
			action.hasCalmFar = GetDataTableBool( dt, row, col_hasCalmFar )
			action.hasUrgent = GetDataTableBool( dt, row, col_hasUrgent )
			action.hasUrgentFar = GetDataTableBool( dt, row, col_hasUrgentFar )
			action.subEvent = GetDataTableString( dt, row, col_subEvent )
			action.flavorEvent = GetDataTableString( dt, row, col_flavorEvent )
			action.defaultIcon = GetDataTableAsset( dt, row, col_defaultIcon )
			action.hasForcedTempVoice = GetDataTableBool( dt, row, col_hasForcedTempVoice )
			action.pingAsset = pingAsset
			action.index = commsAction

			file.actions[commsAction] <- action


	}
}




void function ShQuickchat_Init()
{
	AddCallback_RegisterRootItemFlavors( LoadCommsActionsFromDatatable )






		Remote_RegisterServerFunction( "ClientCallback_Quickchat_UI", "int", 0, eCommsAction._count, "int", 0, 1 << eCommsFlags._flagCount, "int", 0, eEquipmentSlotType.COUNT  )
		Remote_RegisterServerFunction( "ClientCallback_Quickchat", "int", 0, eCommsAction._count, "int", 0, 1 << eCommsFlags._flagCount )
		Remote_RegisterServerFunction( "ClientCallback_QuickchatSubject_Player", "int", 0, eCommsAction._count, "int", 0, 1 << eCommsFlags._flagCount, "typed_entity", "player" )

		
		var dt = GetDataTable( LOOT_DATATABLE )
		int numRows = GetDataTableRowCount( dt )

		Remote_RegisterClientFunction( "ServerToClient_BroadcastCommsActionToTeam", "entity", "int", 0, eCommsAction._count, "int", 0, (1 << eCommsFlags._flagCount), "int", -1, INT_MAX,"int", 0, eCommsAction._count, "entity", "vector", -32000.0, 32000.0, 32, "int", -1, numRows, "int", 0, INVALID_SOUND_SELECTOR )
		Remote_RegisterClientFunction( "ServerToClient_BroadcastSubjectlessCommsActionToTeam", "entity", "int", 0, eCommsAction._count, "int", 0, (1 << eCommsFlags._flagCount), "int", -1, INT_MAX,"int", 0, eCommsAction._count, "vector", -32000.0, 32000.0, 32, "int", -1, numRows, "int", 0, INVALID_SOUND_SELECTOR )
		Remote_RegisterClientFunction( "ServerCallback_BroadcastPlayerKicked", "int", 1, 129,  "bool" )



		file.flavorDebounceTime = GetCurrentPlaylistVarFloat( "comms_actions_flavor_debounce_time", 150.0 )
		file.flavorGlobalDebounceTime = GetCurrentPlaylistVarFloat( "comms_actions_flavor_global_debounce_time", 90.0 )

		file.replyMap[ eCommsAction.REPLY_THANKS ] <- eCommsAction.REPLY_WELCOME
		file.replyMap[ eCommsAction.REPLY_REVIVE_THANKS ] <- eCommsAction.REPLY_REVIVE_WELCOME


			file.replyMap[eCommsAction.REPLY_LOVE_YOU] <- eCommsAction.REPLY_LOVE_YOU_MORE
			file.replyMap[eCommsAction.REPLY_LOVE_YOU_MORE] <- eCommsAction.REPLY_NO_I_LOVE_YOU_MORE
			file.replyMap[eCommsAction.REPLY_NO_I_LOVE_YOU_MORE] <- eCommsAction.REPLY_NO_I_LOVE_YOU_MORE

			
			file.altMap[eCommsAction.REPLY_LOVE_YOU] <- eCommsAction.REPLY_LOVE_YOU
			file.altMap[eCommsAction.REPLY_LOVE_YOU_MORE] <- eCommsAction.REPLY_LOVE_YOU_MORE
			file.altMap[eCommsAction.REPLY_NO_I_LOVE_YOU_MORE] <- eCommsAction.REPLY_NO_I_LOVE_YOU_MORE


		file.altMap[ eCommsAction.REPLY_WELCOME ] <- eCommsAction.REPLY_WELCOME_ALT
		file.altMap[ eCommsAction.REPLY_REVIVE_WELCOME ] <- eCommsAction.REPLY_REVIVE_WELCOME_ALT

















		file.quickchatInitialized = true

}


















#if DEV
void function DEV_ReloadCommsTable()
{

		file.actions.clear()

	LoadCommsActionsFromDatatable()
}
#endif



void function Quickchat( int index, entity subject )
{
	if ( !file.quickchatInitialized )
		return

	QuickchatInternal( index, eCommsFlags.NONE, subject )
}

void function QuickchatInternal( int index, int commsFlags, entity subject )
{
	if ( !file.quickchatInitialized )
		return

	
	if ( IsValid( subject ) && subject.IsPlayer() )
		Remote_ServerCallFunction( "ClientCallback_QuickchatSubject_Player", index, commsFlags, subject )
	else
		Remote_ServerCallFunction( "ClientCallback_Quickchat", index, commsFlags )
}




vector function GetChatTitleColorForPlayer( entity player )
{
	entity localPlayer = GetLocalClientPlayer()
	if ( player == localPlayer )
		return OBITUARY_COLOR_LOCALPLAYER

	if ( localPlayer.GetTeam() == player.GetTeam() )
	{
		if ( GetCurrentPlaylistVarBool( "show_team_color_obituary", false ) )
		{
			return GetPlayerInfoColor( player )
		}
		else
		{
			return OBITUARY_COLOR_FRIENDLY
		}
	}

	if ( AllianceProximity_IsUsingAllianceProximity() && IsValid( localPlayer ) && IsValid( player ) && IsFriendlyTeam( localPlayer.GetTeam(), player.GetTeam() ) )
		return TEAM_COLOR_FRIENDLY

	return OBITUARY_COLOR_ENEMY
}




table< entity, table<int, float> > s_playerToActionTimesMap
void function SetPlayerLastSaid( entity player, int actionIndex )
{
	if ( !(player in s_playerToActionTimesMap) )
		s_playerToActionTimesMap[player] <- {}
	if ( !(actionIndex in s_playerToActionTimesMap[player]) )
		s_playerToActionTimesMap[player][actionIndex] <- 0.0

	s_playerToActionTimesMap[player][actionIndex] = Time()
	SetTeamLastSaid( player.GetTeam(), actionIndex )
}




float function GetPlayerLastSaid( entity player, int actionIndex )
{
	float baseline = 0.0
	if ( player in s_playerToActionTimesMap )
	{
		if ( actionIndex in s_playerToActionTimesMap[player] )
			baseline = s_playerToActionTimesMap[player][actionIndex]
	}

	float result = (Time() - baseline)
	return result
}



table< int, table<int, float> > s_teamToActionTimesMap
void function SetTeamLastSaid( int team, int actionIndex )
{
	if ( !(team in s_teamToActionTimesMap) )
		s_teamToActionTimesMap[team] <- {}
	if ( !(actionIndex in s_teamToActionTimesMap[team]) )
		s_teamToActionTimesMap[team][actionIndex] <- 0.0

	s_teamToActionTimesMap[team][actionIndex] = Time()
}




float function GetTeamLastSaid( int team, int actionIndex )
{
	float baseline = 0.0
	if ( team in s_teamToActionTimesMap )
	{
		if ( actionIndex in s_teamToActionTimesMap[team] )
			baseline = s_teamToActionTimesMap[team][actionIndex]
	}

	float result = (Time() - baseline)
	return result
}



array<string> function GetSubjectNamesForCommsAction( int commsAction, entity subjectEnt, string itemRef )
{
	if ( !IsValid( subjectEnt ) )
	{
		if ( itemRef != "" )
			return [SURVIVAL_Loot_GetLootDataByRef( itemRef ).pickupString]
		else
			return [""]
	}


	if( ( commsAction == eCommsAction.REPLY_CAREPACKAGE_INSIGHT || commsAction == eCommsAction.REPLY_CAREPACKAGE_INSIGHT_LOOTED ) && itemRef != "" )
	{
		return [SURVIVAL_Loot_GetLootDataByRef( itemRef ).pickupString]
	}


	if ( subjectEnt.IsPlayer() )
		return [subjectEnt.GetPlayerName()]

	switch ( subjectEnt.GetNetworkedClassName() )
	{
		case "prop_survival":
		{
			LootData ld = SURVIVAL_Loot_GetLootDataByIndex( subjectEnt.GetSurvivalInt() )
			return [ld.pickupString]
		}

		case "weaponx":
			string weaponClassName = subjectEnt.GetWeaponClassName()
			array<string> commsActionAttachmentPoints = file.actions[commsAction].attachmentPoints
			if ( commsActionAttachmentPoints.contains( "hopup") || commsActionAttachmentPoints.contains( "hopupMulti_a" ) || commsActionAttachmentPoints.contains( "hopupMulti_b" ) )
			{
				array<string> possibleHopups = []
				array<string> supportedAttachments = SURVIVAL_GetLootDataFromWeapon( subjectEnt ).supportedAttachments
				array<string> attachmentRefs = []
				foreach ( string attachmentPoint in commsActionAttachmentPoints )
				{
					if ( !supportedAttachments.contains( attachmentPoint ) )
						continue

					attachmentRefs = GetAttachmentsForPoint( attachmentPoint, weaponClassName )
					foreach ( string ref in attachmentRefs )
					{
						LootData lootData = SURVIVAL_Loot_GetLootDataByRef( ref )

						if ( !lootData.lootTags.contains ( "FakeHopup" ) )
							possibleHopups.append( SURVIVAL_Loot_GetLootDataByRef( ref ).pickupString )
					}
				}

				return possibleHopups
			}

			return [string( subjectEnt.GetWeaponPrintName() )]

	}

	if ( subjectEnt.IsPlayerDecoy() )
	{
		entity bossPlayer = subjectEnt.GetBossPlayer()
		if ( IsValid( bossPlayer ) )
			return [bossPlayer.GetPlayerName()]
		return ["<decoyUnk:[" + subjectEnt + "]>"]
	}

	if ( subjectEnt.IsNPC() )
	{
		if ( commsAction == eCommsAction.PING_NPC_LOOT_TICK )
		{
			return [Localize( "#NPC_LOOT_TICK_UI_TITLE" )]
		}

		else if ( commsAction == eCommsAction.PING_NPC_LOOT_TICK_GH )
		{
			return [Localize( "#NPC_LOOT_TICK_UI_TITLE_GH" )]
		}

		else if ( commsAction == eCommsAction.PING_ENEMY_NPC_PROWLER )
		{
			return [Localize( "#NPC_PROWLER_UI_TITLE" )]
		}
		else if ( commsAction == eCommsAction.PING_ENEMY_NPC_SPIDER )
		{
			return [Localize( "#NPC_SPIDER_UI_TITLE" )]
		}
		else if ( commsAction == eCommsAction.PING_ENEMY_NPC_SPECTRE )
		{
			return [Localize( "#NPC_SPECTRE" )]
		}
		else if ( commsAction == eCommsAction.PING_NPC_MARVIN_LOOT  || commsAction == eCommsAction.PING_NPC_MARVIN_STORY )
		{
			return [Localize( "#NPC_MARVIN_UI_TITLE" )]
		}
		return [Localize( "#PING_ENEMY_GENERIC", subjectEnt.GetTitleForUI() )]
	}

	if ( commsAction == eCommsAction.PING_LOOT_DRONE )
	{
		return [Localize( "#LOOT_DRONE_UI_TITLE" )]
	}

	if ( commsAction == eCommsAction.PING_LOOT_ROLLER )
	{
		return [Localize( "#LOOT_ROLLER_UI_TITLE" )]
	}








		if ( IsVaultPanel( subjectEnt ) )
		{
			UniqueVaultData vaultData = GetUniqueVaultData( subjectEnt )

			if ( commsAction == vaultData.commsPingVault || commsAction == vaultData.commsPingVaultOpen || commsAction == vaultData.commsPingVaultHasKeySquad || commsAction == vaultData.commsPingVaultHasKeySelf )
			{
				return [Localize( vaultData.vaultUITitleString )]
			}
		}

		else if ( IsVaultDoor( subjectEnt ) )
		{
			if ( commsAction == eCommsAction.PING_SHIP_VAULT || commsAction == eCommsAction.PING_SHIP_VAULT_HAS_KEY_SQUAD || commsAction == eCommsAction.PING_SHIP_VAULT_HAS_KEY_SELF )
				return [Localize( "#SHIP_VAULT_UI_TITLE" )]
		}
























	if ( CaptureObjectivePing_GetIsCaptureObjectivePingCommsAction( commsAction, subjectEnt ) )
	{
		int objectiveID = CaptureObjectivePing_GetObjectiveIndexFromWaypoint( subjectEnt.GetOwner() )
		return [ CaptureObjectivePing_GetObjectiveNameFromObjectiveID_Localized( objectiveID ) ]
	}

	return ["<subjectUnk:[" + subjectEnt + "]>"]
}




vector function GetSubjectColorForCommsAction( entity subjectEnt, string itemRef, entity player )
{
	const vector DEFAULT_RESULT = <255, 255, 255>

	if ( itemRef != "" )
		return GetKeyColor( COLORID_TEXT_LOOT_TIER0, SURVIVAL_Loot_GetLootDataByRef( itemRef ).tier )

	if ( !IsValid( subjectEnt ))
		return BURN_COLOR

	if ( subjectEnt.IsPlayer() )
		return GetChatTitleColorForPlayer( subjectEnt )


	if( LootBinReset_IsLootBinSpecial( subjectEnt ) )
	{
		if( LootBinReset_IsLootBin_GoldBin( subjectEnt ) )
		{
			return GetKeyColor( COLORID_HUD_LOOT_TIER4 )
		}

		if( LootBinReset_IsLootBin_Mythic( subjectEnt ) )
		{
			return GetKeyColor( COLORID_MYTHIC_BIN_ICON )
		}
	}


	switch ( subjectEnt.GetNetworkedClassName() )
	{
		case "prop_survival":
			return GetRarityColor( subjectEnt )

		case "weaponx":
			return BURN_COLOR


		case PLAYER_WAYPOINT_CLASSNAME:
			if ( GameMode_IsActive( eGameModes.CONTROL ) && subjectEnt.GetWaypointType() == eWaypoint.CONTROL_OBJECTIVE )
			{
				if ( subjectEnt.GetWaypointInt( CONTROL_INT_OBJ_ALLIANCE_OWNER ) == ALLIANCE_NONE )
				{
					return GamemodeUtility_GetColorVectorForCaptureObjectiveState( eGamemodeUtilityCaptureObjectiveColorState.ENEMY_OWNED )
				}
				else if ( IsTeamInAlliance( player.GetTeam(), subjectEnt.GetWaypointInt( CONTROL_INT_OBJ_ALLIANCE_OWNER ) ) )
				{
					return GamemodeUtility_GetColorVectorForCaptureObjectiveState( eGamemodeUtilityCaptureObjectiveColorState.FRIENDLY_OWNED )
				}
				else if ( !IsTeamInAlliance( player.GetTeam(), subjectEnt.GetWaypointInt( CONTROL_INT_OBJ_ALLIANCE_OWNER ) ) )
				{
					return GamemodeUtility_GetColorVectorForCaptureObjectiveState( eGamemodeUtilityCaptureObjectiveColorState.ENEMY_OWNED )
				}
			}
			break


		case "prop_script":
			if ( IsEnemyTeam( player.GetTeam(), subjectEnt.GetTeam() ) )
			{
				return OBITUARY_COLOR_ENEMY
			}
			else if ( IsFriendlyTeam( player.GetTeam(), subjectEnt.GetTeam() ) )
			{
				return OBITUARY_COLOR_FRIENDLY
			}

	}

	if ( subjectEnt.IsPlayerDecoy() )
	{
		entity bossPlayer = subjectEnt.GetBossPlayer()
		if ( IsValid( bossPlayer ) )
			return GetChatTitleColorForPlayer( bossPlayer )
	}

	if( IsValid( GetHealDroneForHitEnt( subjectEnt ) ) )
	{
		return GetChatTitleColorForPlayer( player )
	}

	return DEFAULT_RESULT
}


vector function GetSecondarySubjectColorForCommsAction( entity subjectEnt, entity player )
{
	const vector DEFAULT_RESULT = <255, 255, 255>

	if ( !IsValid( subjectEnt ))
		return DEFAULT_RESULT

	if ( subjectEnt.IsPlayer() )
		return DEFAULT_RESULT

	switch ( subjectEnt.GetNetworkedClassName() )
	{

		case PLAYER_WAYPOINT_CLASSNAME:
			if ( GameMode_IsActive( eGameModes.CONTROL ) && subjectEnt.GetWaypointType() == eWaypoint.CONTROL_OBJECTIVE )
			{
				if ( subjectEnt.GetWaypointInt( CONTROL_INT_OBJ_ALLIANCE_OWNER ) == ALLIANCE_NONE )
				{
					return GetKeyColor( COLORID_TEXT_LOOT_TIER0 )
				}
				else if ( IsTeamInAlliance( player.GetTeam(), subjectEnt.GetWaypointInt( CONTROL_INT_OBJ_ALLIANCE_OWNER ) ) )
				{
					return GamemodeUtility_GetColorVectorForCaptureObjectiveState( eGamemodeUtilityCaptureObjectiveColorState.FRIENDLY_OWNED )
				}
				else if ( !IsTeamInAlliance( player.GetTeam(), subjectEnt.GetWaypointInt( CONTROL_INT_OBJ_ALLIANCE_OWNER ) ) )
				{
					return GamemodeUtility_GetColorVectorForCaptureObjectiveState( eGamemodeUtilityCaptureObjectiveColorState.ENEMY_OWNED )
				}
			}
			break

	}

	return DEFAULT_RESULT
}




string function GetSubjectLootTierForCommsAction( entity subjectEnt, string itemRef )
{
	int tier = 0

	if ( itemRef != "" )
		return string( SURVIVAL_Loot_GetLootDataByRef( itemRef ).tier )

	if ( !IsValid( subjectEnt ) || subjectEnt.GetNetworkedClassName() != "prop_survival" )
	{
		

			if ( IsVaultDoor( subjectEnt ) || IsVaultPanel( subjectEnt ) )
			{
				entity playerWithKey = VaultPanel_GetTeammateWithKey( GetLocalClientPlayer().GetTeam() )
				string playerWithKeyName
				if ( IsValid( playerWithKey ) )
					playerWithKeyName = VaultPanel_GetTeammateWithKey( GetLocalClientPlayer().GetTeam() ).GetPlayerName()
				if ( playerWithKeyName != "" )
					return playerWithKeyName
			}


		return string( tier )
	}

	LootData data = SURVIVAL_Loot_GetLootDataByIndex( subjectEnt.GetSurvivalInt() )
	tier = data.tier


	
	
	
	if( UpgradeCore_IsEquipmentArmorCore( data.ref ) && tier == 5 )
	{
		tier = 4
	}


	return string( tier )
}



bool function GetCommsActionIsFar( entity player, entity subjectEnt, vector subjectPos, int commsFlags )
{
	const float FAR_DIST_THRESHOLD = 2048.0

	if ( IsBitFlagSet( commsFlags, eCommsFlags.FORCE_FAR ) )
	{
		printt( "Far [YES] <- eCommsFlags.FORCE_FAR" )
		return true
	}

	vector actionPos = subjectPos    
	float dist       = Distance( actionPos, player.GetOrigin() )
	bool result      = (dist > FAR_DIST_THRESHOLD)
	return result
}



bool function PlayerIsInCombat( entity player )
{
	const float TEAMMATE_NEAR_SPOTTED_ENEMY = 2048.0
	const float LAST_DAMAGED_BY_PLAYER_OR_NPC = 30.0
	const float LAST_DID_DAMAGE_TO_PLAYER_OR_NPC = 30.0

	if ( Bleedout_IsBleedingOut( player ) )
		return true

	if ( GetEffectiveDeltaSince( player.GetLastTimeDamagedByOtherPlayer() ) < LAST_DAMAGED_BY_PLAYER_OR_NPC )
	{
#if DEV
		if ( DEBUG_PLAYER_IS_IN_COMBAT )
			printt( "PlayerIsInCombat: [YES] <- Player was damaged by other player within " + LAST_DAMAGED_BY_PLAYER_OR_NPC + "s" )
#endif
		return true
	}

	if ( GetEffectiveDeltaSince( player.GetLastTimeDamagedByNPC() ) < LAST_DAMAGED_BY_PLAYER_OR_NPC )
	{
#if DEV
		if ( DEBUG_PLAYER_IS_IN_COMBAT )
			printt( "PlayerIsInCombat: [YES] <- Player was last damaged by NPC within " + LAST_DAMAGED_BY_PLAYER_OR_NPC + "s" )
#endif
		return true
	}

	
	if ( GetEffectiveDeltaSince( player.GetLastTimeDidDamageToOtherPlayer() ) < LAST_DID_DAMAGE_TO_PLAYER_OR_NPC )
	{
#if DEV
		if ( DEBUG_PLAYER_IS_IN_COMBAT )
			printt( "PlayerIsInCombat: [YES] <- This player did damage to another player within " + LAST_DID_DAMAGE_TO_PLAYER_OR_NPC + "s" )
#endif
		return true
	}

	if ( GetEffectiveDeltaSince( player.GetLastTimeDidDamageToNPC() ) < LAST_DID_DAMAGE_TO_PLAYER_OR_NPC )
	{
#if DEV
		if ( DEBUG_PLAYER_IS_IN_COMBAT )
			printt( "PlayerIsInCombat: [YES] <- This player did damage to NPC within " + LAST_DID_DAMAGE_TO_PLAYER_OR_NPC + "s" )
#endif
		return true
	}

	



	if ( Waypoint_AnyEnemySpottedNearPoint( player.EyePosition(), TEAMMATE_NEAR_SPOTTED_ENEMY ) )

	{
#if DEV
		if ( DEBUG_PLAYER_IS_IN_COMBAT )
			printt( "PlayerIsInCombat [YES] <- A teammate is near spotted enemy" )
#endif
		return true
	}

	return false
}



const bool DEBUG_PLAYER_DELIVERY = false
const float SUBJECT_NEAR_SPOTTED_ENEMY = 1024.0

bool function PlayerDeliveryShouldBeUrgent( entity player, vector subjectPos, int commsFlags = eCommsFlags.NONE )
{
	const float TEAMMATE_NEAR_PLAYER = 2048.0
	const float TEAMMATE_NEAR_SUBJECT_POS = 1024.0

	if ( IsBitFlagSet( commsFlags, eCommsFlags.FORCE_URGENT ) )
	{
#if DEV
			if ( DEBUG_PLAYER_DELIVERY )
				printt( "PlayerDeliveryShouldBeUrgent: [YES] <- eCommsFlags.FORCE_URGENT" )
#endif
		return true
	}

	vector eyePos             = player.EyePosition()
	int team                  = player.GetTeam()
	array<entity> teamPlayers = GetPlayerArrayOfTeam_Alive( team )
	foreach ( entity teamPlayer in teamPlayers )
	{
		if ( teamPlayer != player )
		{
			float distToPlayer     = Distance( eyePos, teamPlayer.EyePosition() )
			float distToSubjectPos = Distance( subjectPos, teamPlayer.EyePosition() )
			if ( (distToPlayer > TEAMMATE_NEAR_PLAYER) && (distToSubjectPos > TEAMMATE_NEAR_SUBJECT_POS) )
				continue
		}

		if ( PlayerIsInCombat( teamPlayer ) )
			return true
	}

	



	if ( Waypoint_AnyEnemySpottedNearPoint( subjectPos, SUBJECT_NEAR_SPOTTED_ENEMY ) )

	{
#if DEV
			if ( DEBUG_PLAYER_DELIVERY )
				printt( "PlayerDeliveryShouldBeUrgent: [YES] <- Waypoint near spotted enemy" )
#endif
		return true
	}

	if ( DeathField_IsActive( player.DeathFieldIndex() ) )
	{
		const float START_PLAYING_DIST = -30.0        
		float stormDist = DeathField_PointDistanceFromFrontier( eyePos, player.DeathFieldIndex() )
		if ( stormDist < START_PLAYING_DIST )
		{
#if DEV
				if ( DEBUG_PLAYER_DELIVERY )
					printt( "PlayerDeliveryShouldBeUrgent: [YES] <- Inside deathfield" )
#endif
			return true
		}
	}

	
	float stim = StatusEffect_GetSeverity( player, eStatusEffect.stim_visual_effect )
	if ( stim > 0.001 )
	{
#if DEV
			if ( DEBUG_PLAYER_DELIVERY )
				printf( "PlayerDeliveryShouldBeUrgent: [YES] <- Stim (%0.2f)", stim )
#endif
		return true
	}

	return false
}



float function ClientCodeCallback_GetPlayerThreatLevel( entity player )
{
	if ( DeathField_IsActive( player.DeathFieldIndex() ) )
	{
		const float START_PLAYING_DIST = -30.0        
		float stormDist = DeathField_PointDistanceFromFrontier( player.EyePosition(), player.DeathFieldIndex() )
		if ( stormDist < START_PLAYING_DIST )
		{
			return 80
		}
	}

	if ( Waypoint_AnyEnemySpottedNearPoint( player.GetOrigin(), SUBJECT_NEAR_SPOTTED_ENEMY ) )
	{
		return 50
	}

	return 0
}



float function GetCooldownTimeForCommsAction( int commsAction )
{
	switch( commsAction )
	{
		case eCommsAction.PING_ENEMY_SPOTTED_SPECIFIC:
		case eCommsAction.PING_ENEMY_TRAP:
		case eCommsAction.PING_ENEMY_SMOKE:
		case eCommsAction.PING_TOXIC_GAS:
		case eCommsAction.PING_ENEMY_SHIELD:
		case eCommsAction.PING_ENEMY_TELEPORTER:
		case eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_1:
		case eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_2:
		case eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_3:
		case eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_4:
		case eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_5:
			return 1.5

		case eCommsAction.FIRING_RANGE_TARGET_SPEED_CHANGE:
			return 0.9


		case eCommsAction.REPLY_CAREPACKAGE_INSIGHT:
		case eCommsAction.REPLY_CAREPACKAGE_INSIGHT_FUTURE:
			return 0.5






	}

	return 4.0
}




bool function ShouldMuteCommsActionForCooldown( entity player, int commsAction, entity subjectEnt )
{

		if ( commsAction == eCommsAction.REPLY_NO_I_LOVE_YOU_MORE )
			return false


	if ( IsValid( subjectEnt ) && (subjectEnt.GetNetworkedClassName() == "prop_survival") && commsAction != eCommsAction.REPLY_LOOT_DIBS )
	{
		float delta = (Time() - subjectEnt.e.lastVocalizedCommsTime)
		if ( delta < 3.0 )
			return true
		return false
	}

	float cooldownTime = GetCooldownTimeForCommsAction( commsAction )
	float delta        = GetPlayerLastSaid( player, commsAction )
	if ( delta < cooldownTime )
		return true

	bool isEnemyNearbyComm = commsAction == eCommsAction.QUICKCHAT_SKYDIVE_ENEMIES_NEARBY






	if ( isEnemyNearbyComm )
	{
		float teamDelta = GetTeamLastSaid( player.GetTeam(), commsAction )
		if ( teamDelta < cooldownTime )
			return true
	}


	return false
}




string function GetNameForCommsAction( int commsAction )
{
	foreach ( string key, int val in eCommsAction )
	{
		if ( val == commsAction )
			return key
	}
	return ""
}




void function ServerToClient_BroadcastSubjectlessCommsActionToTeam( entity player, int commsAction, int commsFlags, int subjectCount, int secondaryCommsAction, vector subjectPos, int itemIndex, int selector )
{
	ServerToClient_BroadcastCommsActionToTeam( player, commsAction, commsFlags, subjectCount, secondaryCommsAction, null, subjectPos, itemIndex, selector )
}

void function ServerToClient_BroadcastCommsActionToTeam( entity player, int commsAction, int commsFlags, int subjectCount, int secondaryCommsAction, entity subjectEnt, vector subjectPos, int itemIndex, int selector )
{
	HandleBroadcastCommsAction( player, commsAction, subjectEnt, subjectPos, commsFlags, itemIndex, subjectCount, secondaryCommsAction, 0.0, selector )
}




void function HandleBroadcastCommsAction( entity player, int commsAction, entity subjectEnt, vector subjectPos, int commsFlags, int itemIndex, int subjectCount, int secondaryCommsAction, float creationTime = 0.0, int selector = INVALID_SOUND_SELECTOR  )
{
	if ( !file.quickchatInitialized )
		return

	if ( !IsAlive( player ) && (commsFlags & eCommsFlags.INCLUDE_DEAD) == 0 )
		return

	if ( !player.IsPlayer() )
		return

	if ( ShouldMuteCommsActionForCooldown( player, commsAction, subjectEnt ) )
		return

	bool shouldUseAllianceCommsBehaviour = false
	bool shouldUseTeamCommsBehaviour = true

	string itemRef = ""
	if( SURVIVAL_Loot_IsLootIndexValid( itemIndex ) )
	{
		LootData data = SURVIVAL_Loot_GetLootDataByIndex( itemIndex )
		itemRef = data.ref
	}


		
		bool isControlObjectivePing = false
		if ( GameMode_IsActive( eGameModes.CONTROL ) )
		{
			if ( !IsValid( player ) || !IsValid( GetLocalViewPlayer() ) )
				return

			
			if ( player.GetTeam() != GetLocalViewPlayer().GetTeam() )
			{
				shouldUseTeamCommsBehaviour = false
			}

			
			if ( commsAction == eCommsAction.PING_CONTROL_OBJECTIVE_ATTACK || commsAction == eCommsAction.PING_CONTROL_OBJECTIVE_DEFEND )
			{
				if ( IsValid( subjectEnt ) && IsValid( subjectEnt.GetOwner() ) && IsPlayerWaypoint( subjectEnt.GetOwner() ) && subjectEnt.GetOwner().GetWaypointType() == eWaypoint.CONTROL_OBJECTIVE )
				{
					if ( AllianceProximity_GetAllianceFromTeam( player.GetTeam() ) == AllianceProximity_GetAllianceFromTeam( GetLocalViewPlayer().GetTeam() ) )
					{
						shouldUseAllianceCommsBehaviour = true
						isControlObjectivePing = true
					}

					
					if ( GetCommsWaypointSoundsEnabled() && shouldUseTeamCommsBehaviour || shouldUseAllianceCommsBehaviour )
					{
						int pingType = commsAction == eCommsAction.PING_CONTROL_OBJECTIVE_ATTACK ? ePingType.PING_CAPTURE_OBJECTIVE_ATTACK : ePingType.PING_CAPTURE_OBJECTIVE_DEFEND
						string pingSound = Ping_GetSoundForLocationPing( subjectEnt.GetOwner(), pingType, ( player == GetLocalViewPlayer() ), true )
						if ( pingSound != "" )
							EmitSoundOnEntity( subjectEnt.GetOwner(), pingSound )
					}
				}
			}
		}


	
	if ( AllianceProximity_IsUsingAllianceProximity() )
	{
		if ( !IsValid( player ) || !IsValid( GetLocalViewPlayer() ) )
			return

		if ( player.GetTeam() != GetLocalViewPlayer().GetTeam() )
		{
			
			shouldUseTeamCommsBehaviour = false

			
			if ( !shouldUseAllianceCommsBehaviour )
			{
				if ( AllianceProximity_GetLivingAllianceMembersInProximity( player.GetTeam(), player.GetOrigin() ).contains( GetLocalViewPlayer() ) )
					shouldUseAllianceCommsBehaviour = true
			}
		}
	}

	if ( !shouldUseTeamCommsBehaviour && !shouldUseAllianceCommsBehaviour )
		return

	if ( IsValid( subjectEnt ) )
		subjectEnt.e.lastVocalizedCommsTime = Time()


	CommsAction act = GetCommsAction( commsAction )

	CommsOptions opt
	opt.isFirstPerson = (player == GetLocalViewPlayer())
	opt.isFar = GetCommsActionIsFar( player, subjectEnt, subjectPos, commsFlags )
	opt.isUrgent = PlayerDeliveryShouldBeUrgent( player, subjectPos, commsFlags )
	opt.pauseQueue = true

	
	if ( shouldUseTeamCommsBehaviour )
	{
		if ( (GetPlayerVoice( player ) == SILENT_PLAYER_VOICE) )
		{
			if ( act.menuText != "" )
			{
				PrintDummieTeamChat( player, Localize( act.menuText ) )
			}
			else
			{
				array<string> subjectNames = GetSubjectNamesForCommsAction( commsAction, subjectEnt, itemRef )
				foreach ( subjectName in subjectNames )
					PrintDummieTeamChat( player, Localize( subjectName ) )
			}
		}
		else
		{
			
			if ( !IsValid( subjectEnt ) || subjectEnt.GetModelName() != CRAFTED_BANNER_MODEL_NAME ||
					( IsValid( GetEntityFromEncodedEHandle( subjectEnt.GetSurvivalProperty() ) ) && GetEntityFromEncodedEHandle( subjectEnt.GetSurvivalProperty() ).GetTeam() == player.GetTeam() ) )
			{
				PlaySoundForCommsAction( player, subjectEnt, act, opt,  secondaryCommsAction > 0 ? GetNameForCommsAction( secondaryCommsAction ) : "", selector)
			}
		}
	}

	RunQuickChatCallbacks( player, commsAction, subjectEnt )

	string chatText = act.chatText
	if ( chatText != "" && !IsBitFlagSet( commsFlags, eCommsFlags.NO_TEXT ) )
	{

			switch( commsAction )
			{
				case eCommsAction.REPLY_LOVE_YOU:
				case eCommsAction.REPLY_LOVE_YOU_MORE:
				case eCommsAction.REPLY_NO_I_LOVE_YOU_MORE:
					if ( opt.isFirstPerson )
						chatText += "_1P"
					break

				default:
					break
			}


		string playerName          = opt.isFirstPerson ? Localize( "#OBITUARY_YOU" ) : player.GetPlayerName()
		vector playerColor         = GetChatTitleColorForPlayer( player )

		array<string> subjectNames = GetSubjectNamesForCommsAction( commsAction, subjectEnt, itemRef )
		vector subjectColor        = GetSubjectColorForCommsAction( subjectEnt, itemRef, player )
		vector secondarySubjectColor = GetSecondarySubjectColorForCommsAction( subjectEnt, player )
		string subjectTier         = GetSubjectLootTierForCommsAction( subjectEnt, itemRef )


			
			if ( GameMode_IsActive( eGameModes.CONTROL ) )
			{
				
				if ( isControlObjectivePing )
				{
					subjectColor = GetSubjectColorForCommsAction( subjectEnt.GetOwner(), itemRef, player )
					secondarySubjectColor = GetSecondarySubjectColorForCommsAction( subjectEnt.GetOwner(), player )

					int pingCount = CaptureObjectivePing_GetPingCountForObjectiveForTeamOrAlliance( subjectEnt.GetOwner(), AllianceProximity_GetAllianceFromTeam( subjectEnt.GetTeam() ) )
					pingCount-- 
					if ( pingCount > 0 )
					{
						subjectTier = "+" + pingCount
					}
					else
					{
						subjectTier = ""
					}
				}
			}



			
			if ( GameModeVariant_IsActive( eGameModeVariants.FREEDM_LOCKDOWN ) )
			{
				
				if ( commsAction == eCommsAction.PING_TREASUREHUNT_OBJ_ATTACK && IsValid( subjectEnt ) && IsValid( subjectEnt.GetOwner() ) )
				{
					subjectColor = GetSubjectColorForCommsAction( subjectEnt.GetOwner(), itemRef, player )
					secondarySubjectColor = GetSecondarySubjectColorForCommsAction( subjectEnt.GetOwner(), player )

					int pingCount = CaptureObjectivePing_GetPingCountForObjectiveForTeamOrAlliance( subjectEnt.GetOwner(), subjectEnt.GetTeam() )
					pingCount-- 
					if ( pingCount > 0 )
						subjectTier = "+" + pingCount
					else
						subjectTier = ""
				}
			}






















		if ( commsAction == eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_1 ||
				commsAction == eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_2 ||
				commsAction == eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_3 ||
				commsAction == eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_4 ||
				commsAction == eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_5

				|| commsAction == eCommsAction.PING_XP_LEVEL_UP_ABILITY

			)
		{
			if ( IsValid( subjectEnt ) )
			{
				ItemFlavor character = LoadoutSlot_GetItemFlavor( ToEHI( subjectEnt ), Loadout_Character() )
				string name = ItemFlavor_GetShortName( character )
				subjectNames = [  name ]

				
				int armorTier = EquipmentSlot_GetEquipmentTier( subjectEnt, "armor" )
				subjectTier  = string ( armorTier )
				secondarySubjectColor = GetKeyColor( COLORID_TEXT_LOOT_TIER0, armorTier )

				
				array<entity> teamPlayers = GetPlayerArrayOfTeam_Alive( subjectEnt.GetTeam() )
				int teamCount = teamPlayers.len()
				subjectCount = teamCount
			}
		}

		string countText		   = ( subjectCount >= 0 ) ? string ( subjectCount ) : ""

		if ( !PlayerIsPingMuted( player ) )
		{
			int elapseTime = int( Time() - creationTime )
			foreach ( string subjectName in subjectNames )
			{
				string locText

				if(commsAction == eCommsAction.PING_I_ULTIMATE) 
				{
					entity weapon = player.GetOffhandWeapon( OFFHAND_ULTIMATE )

					if(IsValid(weapon))
					{
						string weaponName = string ( weapon.GetWeaponPrintName() )

						locText = Localize( chatText, playerName, Localize( weaponName ), subjectTier, countText, elapseTime)
					}
					else
						locText = Localize( chatText, playerName, Localize( subjectName ), subjectTier, countText, elapseTime)
				}
				else


			if( commsAction == eCommsAction.PING_XP_LEVEL_UP_ARMOR )
			{
				array< int > currentAndTargetEvo = UpgradeCore_GetXpRequiredForNextLevel( player )
				int curXp = player.GetPlayerNetInt( UPGRADE_CORE_XP_NETINT )
				int evoRequired = 0
				if( currentAndTargetEvo.len() >= 2 )
				{
					evoRequired = currentAndTargetEvo[1] - curXp
				}


				locText = Localize( chatText, playerName, evoRequired, subjectTier, countText, elapseTime)
			}
			else

					locText = Localize( chatText, playerName, Localize( subjectName ), subjectTier, countText, elapseTime)


				
				if ( GameMode_IsActive( eGameModes.CONTROL ) )
				{
					if ( isControlObjectivePing )
					{
						Obituary_Print_Control_ObjectivePing( subjectEnt, locText, playerColor, subjectColor, secondarySubjectColor, <0, 0, 0>, 0.5 )
					}
					else
					{
						Obituary_Print_Control_Ping( locText, shouldUseAllianceCommsBehaviour, playerColor, subjectColor, secondarySubjectColor, <0, 0, 0>, 0.5 )
					}
				}
				else

				{
					Obituary_Print_Localized( locText, playerColor, subjectColor, secondarySubjectColor, <0, 0, 0>, 0.5 )
				}
			}
		}
	}

	SetPlayerLastSaid( player, commsAction )
}




void function PlaySoundForCommsAction( entity player, entity subjectEnt, CommsAction act, CommsOptions opt, string flavorEventOverride = "", int selector = INVALID_SOUND_SELECTOR )
{
	if ( PlayerIsPingMuted( player ) )
		return

	if ( !file.commsDialogueEnabled )
		return

	if ( ShouldCommsActionDialogBeMuted( subjectEnt, act ) )
		return

	




	string sound = GetPlayerDialogSound( player, subjectEnt, act, opt )
	if ( sound != "" )
	{
		printt( format( "Comms: '%s' #%d    base:'%s'   (%s) far:%d urgent:%d    :  '%s'", GetNameForCommsAction( act.index ), act.index, act.aliasSubname, (opt.isFirstPerson ? "1p" : "3p"), (opt.isFar ? 1 : 0), (opt.isUrgent ? 1 : 0), sound ) )

		float sincePlastPlayed = (Time() - player.p.sayLineLatestTime)
		if ( (sincePlastPlayed < 30.0) && (player.p.sayLineLatestSound != "") )
		{
			player.p.lastCanceledCommsAction = player.p.lastSaidCommsAction
			StopSoundOnEntity( player, player.p.sayLineLatestSound )
		}
		else
			player.p.lastCanceledCommsAction = eCommsAction.BLANK

		
		
		var soundHandle = EmitSoundOnEntityWithSelector( player, sound, selector )
		SetPlayThroughPOVTransitions( soundHandle )

		if ( opt.pauseQueue )
			thread SuspendMainDialogueQueueForDurationOfSound( player, soundHandle )

		
		RemovePlayerDialogueEventsFromMainDialogueQueue( player )

		if ( act.index in file.replyMap && IsValid( subjectEnt ) && subjectEnt.IsPlayer() && subjectEnt == GetLocalViewPlayer() )
		{
			bool subjectIsConAltTarget = sound.find( "_cond" + GetPlayerVoice( subjectEnt ) ) >= 0
			thread PromptReplyWhenPrimaryFinishes( player, act.index, subjectEnt, soundHandle, subjectIsConAltTarget )
		}

		if ( sound.find( "_cond" ) >= 0 || sound.find( "_flavor" ) >= 0 )  {
			PIN_DynamicDialogue( sound )
		}

		player.p.sayLineLatestSound = sound
		player.p.sayLineLatestTime = Time()
		player.p.lastSaidCommsAction = act.index

		string subEventString    = act.subEvent
		int subEvent = GetCommsActionEnumForName( subEventString )
		if ( act.index == eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_1 ||
				act.index == eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_2 ||
				act.index == eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_3 ||
				act.index == eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_4 ||
				act.index == eCommsAction.PING_VANTAGE_ENEMY_SPOTTED_5 )
		{
			subEvent = eCommsAction.SUB_TYPE_VANTAGE_TEAM_1
			if ( IsValid( subjectEnt ) )
			{
				array<entity> teamPlayers = GetPlayerArrayOfTeam_Alive( subjectEnt.GetTeam() )
				int teamCount = teamPlayers.len()
				if ( teamCount == 2 )
					subEvent = eCommsAction.SUB_TYPE_VANTAGE_TEAM_2
				else if ( teamCount > 2 )
					subEvent = eCommsAction.SUB_TYPE_VANTAGE_TEAM_3
			}
		}
		string flavorEvent = flavorEventOverride == "" ? act.flavorEvent : flavorEventOverride

		if ( subEvent != eCommsAction.BLANK )
		{
			thread PlaySoundForSubActionWhenPrimaryFinishes( soundHandle, act, file.actions[ subEvent ], player, subjectEnt, opt, flavorEvent )
		}
		else if ( flavorEvent != "" )
		{
			int flavorAction   = GetCommsActionEnumForName( flavorEvent )
			CommsAction fAct   = GetCommsAction( flavorAction )
			string flavorSound = GetPlayerDialogSound( player, subjectEnt, fAct, opt )
			if ( DoesAliasExist( flavorSound ) && ShouldPlayFlavorAction( player, flavorAction ) )
			{
				thread PlaySoundForSubActionWhenPrimaryFinishes( soundHandle, act, fAct, player, subjectEnt, opt )
			}
		}
	}
}




bool function ShouldCommsActionDialogBeMuted( entity subjectEnt, CommsAction act )
{
	if ( IsValid( subjectEnt ) )
	{
		if ( subjectEnt.GetScriptName() == BLACK_MARKET_SCRIPTNAME )
		{
			if ( act.index == eCommsAction.ABILITY_BLACK_MARKET_NEUTRAL && GradeFlagsHas( subjectEnt, eGradeFlags.IS_BUSY ) )
				return true
		}
	}

	return false
}




CommsAction function GetCommsAction( int index )
{




	CommsAction blankAction
	if ( (index < 0) || (index >= eCommsAction._count) )
		return blankAction

	return file.actions[ index ]
}




bool function ShouldPlayFlavorAction( entity player, int flavorAction )
{
	if ( GetCurrentPlaylistVarInt( "disable_flavor_lines", 0 ) > 0 )
		return false

	if ( file.alwaysPlayFlavorActions.contains( flavorAction ) )
		return true

	if ( Time() - player.p.commActionFlavorGlobalDebounceTime < file.flavorGlobalDebounceTime )
		return false

	if ( flavorAction in player.p.commActionFlavorDebounceTimes )
	{
		if ( Time() - player.p.commActionFlavorDebounceTimes[flavorAction] > file.flavorDebounceTime )
		{
			player.p.commActionFlavorDebounceTimes[flavorAction] = Time() + RandomFloatRange( 10.0, 30.0 )
			player.p.commActionFlavorGlobalDebounceTime = Time() + RandomFloatRange( 10.0, 30.0 )
			return true
		}
		else
		{
			return false
		}
	}
	else
	{
		player.p.commActionFlavorDebounceTimes[flavorAction] <- Time() + RandomFloatRange( 10.0, 30.0 )
		player.p.commActionFlavorGlobalDebounceTime = Time() + RandomFloatRange( 10.0, 30.0 )
		return true
	}

	unreachable
}




void function PlaySoundForSubActionWhenPrimaryFinishes( var primarySoundHandle, CommsAction primaryAct, CommsAction subCommsAction, entity player, entity subjectEnt, CommsOptions opt, string flavorEvent = "" )
{
	EndSignal( player, "OnDestroy" )
	EndSignal( player, "OnDeath" )

	PauseMainDialogueQueue()

	OnThreadEnd(
		function()
		{
			ResumeMainDialogueQueue()
		}
	)

	WaitSignal( primarySoundHandle, "OnSoundFinished" )

	if ( player.p.lastCanceledCommsAction != primaryAct.index )
		PlaySoundForCommsAction( player, subjectEnt, subCommsAction, opt, flavorEvent )
}



void function PromptReplyWhenPrimaryFinishes( entity playerSpeakingPrimary, int primaryCommsAction, entity playerToReply, var soundHandle, bool wasConAlt )
{
	EndSignal( playerSpeakingPrimary, "OnDestroy" )
	EndSignal( playerSpeakingPrimary, "OnDeath" )
	EndSignal( playerToReply, "OnDestroy" )
	EndSignal( playerToReply, "OnDeath" )

	WaitSignal( soundHandle, "OnSoundFinished" )

	int replyCommsAction = file.replyMap[ primaryCommsAction ]

	bool isReplyForcePlay = ShouldForcePlayConditionalAlt( GetConditionalAltDialogue( file.actions[ replyCommsAction ].aliasSubname, playerToReply, playerSpeakingPrimary, true ) )

	if ( wasConAlt || isReplyForcePlay )
		replyCommsAction = file.altMap[ replyCommsAction ]

	string locString = ""
	switch ( replyCommsAction )
	{
		case eCommsAction.REPLY_WELCOME:
		case eCommsAction.REPLY_WELCOME_ALT:
		case eCommsAction.REPLY_REVIVE_WELCOME:
		case eCommsAction.REPLY_REVIVE_WELCOME_ALT:
			locString = Localize( "#PING_SAY_WELCOME" )
			break


		case eCommsAction.REPLY_LOVE_YOU_MORE:
			locString = Localize( "#PING_SAY_LOVE_YOU_MORE" )
			break

		case eCommsAction.REPLY_NO_I_LOVE_YOU_MORE:
			locString = Localize( "#PING_SAY_NO_I_LOVE_YOU_MORE" )
			break


		default:
			locString = ""
	}

	if ( ShouldMuteCommsActionForCooldown( GetLocalViewPlayer(), replyCommsAction, null ) )
		return

	AddOnscreenPromptFunction( "quickchat", CreateQuickchatFunction( replyCommsAction, playerSpeakingPrimary ), 6.0, Localize( locString ) )
}



string function GetMenuOptionTextForCommsAction( int commsAction )
{




	CommsAction data = file.actions[commsAction]
	return Localize( data.menuText )
}




string function GetShortTextForCommsAction( int commsAction )
{




	CommsAction data = file.actions[commsAction]
	return Localize( data.shortText )
}




asset function GetDefaultIconForCommsAction( int commsAction )
{




	CommsAction data = file.actions[commsAction]
	return data.defaultIcon
}




asset function GetPingAssetForCommsAction( int commsAction )
{




	CommsAction data = file.actions[commsAction]
	return data.pingAsset
}



string function GetShadowDialogSoundForAction( CommsAction act, CommsOptions options )
{
	
	string perspective = options.isFirstPerson ? "_1p" : "_3p"
	string prefix = "diag_mp_shadowsquad_ping_spotDefault_"

	string suffix
	string aliasSubname = act.aliasSubname
	switch( aliasSubname )
	{
		case "ping_spotEnemy":
		case "ping_cluePresence":
			suffix = "enemy"
			break
		case "ping_spotDefault":
		case "ping_exploreGoPlayer":
		case "ping_attackingHere":
		case "ping_defendingHere":
		case "ping_watchingHere":
		case "ping_lootingHere":
			suffix = "location"
			break
		case "ping_carePackage":
			suffix = "item"
			break
		default:
			if ( aliasSubname.find( "ping_found" ) >= 0 )
				suffix = "item"
			else
				suffix = "item" 
			break
	}

	string result = prefix + suffix + perspective

	return result

}



string function GetPlayerDialogSound( entity player, entity subjectEnt, CommsAction act, CommsOptions options )
{
	if ( !file.quickchatInitialized )
		return ""






	string subAlias = act.aliasSubname
	if ( subAlias == "" )
		return ""

	string ext
	if ( options.isFar && options.isUrgent && act.hasUrgentFar )
		ext = "_urgentFar"
	else if ( options.isUrgent && act.hasUrgent )
		ext = "_urgent"
	else if ( options.isFar && act.hasCalmFar )
		ext = "_calmFar"
	else if ( act.hasCalm )
		ext = "_calm"
	else
		ext = ""

	if ( act.index == eCommsAction.FLAVOR_LOOT_DIBS )
		ext = TryPrependDibsExtension( player, subjectEnt, act, options, ext )



		bool stompConAlt = ( act.index == eCommsAction.REPLY_WELCOME ) || ( act.index == eCommsAction.REPLY_REVIVE_WELCOME )
		bool forceConAlt = ( act.index == eCommsAction.REPLY_WELCOME_ALT ) || ( act.index == eCommsAction.REPLY_REVIVE_WELCOME_ALT )

		ext = GetConditionalAltPingExtension( player, subjectEnt, act.aliasSubname, ext, forceConAlt, stompConAlt )



	string result
	{
		if ( act.hasForcedTempVoice )
			result = GetBattleChatterAlias1P3PWithTempVoice( (subAlias + ext), options.isFirstPerson )
		else
			result = GetBattleChatterAlias1P3P( player, (subAlias + ext), options.isFirstPerson )
	}

#if DEV
		if ( ShouldTryToReplaceMissingVoiceWithTempVoice() )
		{
			if ( !DoesAliasExist( result ) )
			{
				result = GetBattleChatterAlias1P3PWithTempVoice( (subAlias + ext), options.isFirstPerson )

				if ( !DoesAliasExist( result ) )
					Warning( "Attempted to fall back to temp voice \"" + TEMP_VOICE + "\", but resulting alias \"" + result + "\" does not exist in miles." )
			}
		}
#endif

	return result
}



const string WEAPON_HEADER = "mp_weapon_"
const string ABILITY_HEADER = "mp_ability_"
const string CLASS_SUFFIX = "Class"

string function TryPrependDibsExtension( entity player, entity subjectEnt, CommsAction act, CommsOptions options, string currExt )
{
	if ( !IsValid( player ) )
		return currExt

	if ( !IsValidAndStandardGrabbableLootEnt( subjectEnt ) )
		return currExt

	LootData data = SURVIVAL_Loot_GetLootDataByIndex( subjectEnt.GetSurvivalInt() )

	
	if ( !( data.lootType == eLootType.MAINWEAPON || data.lootType == eLootType.ORDNANCE ) )
		return currExt

	string itemName = data.ref
	string itemClassName = ""

	if ( data.lootType == eLootType.MAINWEAPON )
	{
		if ( data.baseWeapon != "" )
			itemName = data.baseWeapon

		itemClassName = data.lootTags[0] + CLASS_SUFFIX
	}

	if ( itemName.find( WEAPON_HEADER ) == 0 )
	{
		itemName = itemName.slice( WEAPON_HEADER.len() )
	}

	if ( itemName.find( ABILITY_HEADER ) == 0 )
	{
		itemName = itemName.slice( ABILITY_HEADER.len() )
	}

	string ext = currExt

	if ( PlayerHasFlavorDibsLineForItem( player, itemName ) )
	{
		ext = "_" + itemName + currExt
	}

	else if ( itemClassName != "" && PlayerHasFlavorDibsLineForItem( player, itemClassName ) )
	{
		ext = "_" + itemClassName + currExt
	}

	return ext
}



void function SetCommsDialogueEnabled( bool value )
{
	file.commsDialogueEnabled = value
}







void function AddCallback_OnQuickchatEvent( int index, void functionref(entity, int, entity) func )
{
	if ( !(index in file.onQuickchatCallbacks) )
		file.onQuickchatCallbacks[ index ] <- []

	Assert( !file.onQuickchatCallbacks[ index ].contains( func ) )
	file.onQuickchatCallbacks[ index ].append( func )
}











































































































































































































































































































































void function RunQuickChatCallbacks( entity player, int commsAction, entity subjectEnt )
{
	if ( commsAction in file.onQuickchatCallbacks )
	{
		foreach ( func in file.onQuickchatCallbacks[ commsAction ] )
		{
			func( player, commsAction, subjectEnt )
		}
	}
}











void function ServerCallback_BroadcastPlayerKicked( int entIdx, bool isAnonymous )
{
	string name = GetPlayerNameByEntIndex( entIdx )
	if ( isAnonymous )
		name = GetCachedObsfuscatedNameByName( name )

	Obituary_Print_Localized( Localize( "#ANTICHEAT_REMOVED_FROM_MATCH", name ), <255, 255, 255> )
}












