global function Sh_RespawnBeacon_Init

global function RespawnBeacons_RegisterNetworking

global function GetRespawnStyle
global function GetRemainingRespawnsForPlayer
global function IsRespawnBeacon
global function RespawnChamberOnUse
global function GetStartingRespawnCount
global function ShouldRestoreKittedWeapons

global function RespawnEquipped_DontResetInventory

global function Get_RespawnStatus_String_ForPlayer

global function RespawnBeacon_PLV_NoBanners
global function Player_Banners_Enabled








































































global function ServerCallback_RespawnPodStarted
global function ServerCallback_DisplayWaitingForRespawn
global function ServerCallback_RespawnDNAHint

global function ServerCallback_RespawnBeaconStart
global function ServerCallback_RespawnBeaconStop

global function TryPingRespawnItem



global function ServerToClient_RespawnChamberOnUse


global function AddBeaconEntToRespawnBeaconsArray
global function GetRespawnStatus

global function CountTeammatesWaitingToBeRespawned
global function HasTeammatesToRespawn
global function ShouldFastBannerPickup
global function HasInterruptableBannerPickup







global function UpdateRespawnChamberRuis









global const string RESPAWN_CHAMBER_TARGETNAME = "respawn_chamber"

global const string RESPAWN_CHAMBER_SCRIPTNAME = "respawn_chamber"


global const string RESPAWN_DNA_TARGETNAME = "respawn_dna"
global const string RESPAWN_DROPSHIP_TARGETNAME = "respawn_dropship"
global const string PICKING_UP_RESPAWN_BANNER_ANIM = "ptpov_burn_card_activate_seq_gladcard"

const string RESPAWN_BEACON_ALTMOVENODE_MOVER_SCRIPTNAME = "respawn_beacon_altmovenode_mover"

const float RESPAWN_BEACON_HOLO_EFFECT_HEIGHT = 75.0

global const float RESPAWN_DNA_LIFETIME = 90.0
const float RESPAWN_DROP_TIME = 10.0
global const float RESPAWN_BEACON_RESPAWN_TIME = 5.0
global const int RESPAWN_BEACON_MAX_NUM_POSITIONS_ON_DROPSHIP = 4

global const int DROPSHIP_ANIM_HEIGHT_OFFSET = 2897

global const string RESPAWN_BEACON_SUCCESS_SOUND = "Survival_RespawnChamber_Activate"
global const string RESPAWN_BEACON_LOOP_SOUND = "Survival_RespawnBeacon_Linking_loop"

global const asset RESPAWN_DROPSHIP_MODEL = $"mdl/vehicle/goblin_dropship/goblin_dropship.rmdl"
global const asset RESPAWN_BEACON_EMITTER_FX = $"P_chamber_proj_holo"
global const asset RESPAWN_BEACON_BEAM_FX = $"P_chamber_beam"
global const asset RESPAWN_BEACON_SCAN_FX = $"P_chamber_celebration_s19"


const asset RESPAWN_BEACON_PULSATE_FX = $"P_chamber_pulse_s19"	
const string RESPAWN_INTERACT_PULSATE_SOUND = "Survival_RespawnEquippedBeacon_Full" 

global const asset RESPAWN_BEACON_ICON = $"rui/hud/gametype_icons/survival/dna_station"
global const asset RESPAWN_BEACON_ICON_SMALL = $"rui/hud/gametype_icons/survival/dna_station_small"
global const asset RESPAWN_BEACON_INUSE_ICON = $"rui/hud/gametype_icons/survival/dna_station_inuse"
global const asset RESPAWN_BEACON_DISABLED_ICON = $"rui/hud/gametype_icons/survival/dna_station_disabled"
const string SOUND_HOLOGRAM_LOOP = "Survival_Emit_RespawnChamber"

const float RESPAWN_CHAMBER_ICON_FADE_DIST_NEAR = 300.0
const float RESPAWN_CHAMBER_ICON_FADE_DIST_FAR = 1000.0

const int RESPAWN_THANKS_DELAY = 4

const string ANIM_FLYIN_IDLE = "dropship_classic_mp_flyin_idle"
const string ANIM_FLYIN_MOVE = "dropship_classic_mp_flyin"

const float MOBILE_RESPAWN_BEACON_ICON_FADE_DIST_ZERO = 0.0
global const string MOBILE_RESPAWN_BEACON_TARGETNAME = "respawn_chamber_mobile"

global const string MOBILE_RESPAWN_BEACON_SCRIPTNAME = "respawn_chamber_mobile"






const string FUNCNAME_PingBeaconFromMap = "RespawnBeacon_ClientToServer_PingBeaconFromMap"

global struct dropshipAnimData
{
	string                     idleAnim
	string                     idlePOVAnim
	string                     jumpAnim
	string                     jumpPOVAnim
	string                     attachment = "origin"
	bool                       hideProxy = true
	void functionref( entity ) viewConeFunc
	float                      yawAngle
	string                     firstPersonJumpOutSound 
}

global struct DropshipAltFlyinData
{
	vector startPos
	vector endPos
	float  timeToTake
	entity dropship
	string dropshipAISettings
}


struct sRestoreWeaponInfo
{
	entity ent
	string weaponRef = ""
	array< string > modRefs = []
}

struct respawnLoadout
{
	array< sRestoreWeaponInfo > restoreWeaponInfos





	ArmorData armorData
	string helmetRef

	bool wasDeath_Suicide
}


struct
{
	array<dropshipAnimData>      dropshipAnimDataList
	array<entity>                allStations


		array<var>         respawnChamberRuis
		array<var>		   respawnChamberFullmapRuis
		table<entity, int> chamberToBeamFX

		bool mobileRespawnSpawnInProgress



































}
file

void function Sh_RespawnBeacon_Init()
{








	PrecacheScriptString( RESPAWN_CHAMBER_SCRIPTNAME )

	PrecacheModel( RESPAWN_DROPSHIP_MODEL )

	if ( GetRespawnStyle() == eRespawnStyle.NONE )
		return

	PrecacheParticleSystem( RESPAWN_BEACON_EMITTER_FX )
	PrecacheParticleSystem( RESPAWN_BEACON_BEAM_FX )
	PrecacheParticleSystem( RESPAWN_BEACON_SCAN_FX )
	PrecacheParticleSystem( RESPAWN_BEACON_PULSATE_FX )


		Remote_RegisterServerFunction( "ClientCallback_PingNearestRespawn", "vector", -FLT_MAX, FLT_MAX, 32 )
		Remote_RegisterServerFunction( FUNCNAME_PingBeaconFromMap, "typed_entity", "prop_script" )

		if ( HasInterruptableBannerPickup() )
		{
			Remote_RegisterServerFunction( "ClientToServer_CancelBannerPickupAnim" )
		}



		RegisterSignal( "ReviveRuiThread" )
		RegisterSignal( "SpectatorShowRespawnRui" )


			if ( !GameModeVariant_IsActive( eGameModeVariants.SURVIVAL_SHADOW_ARMY ) )

			{
				AddCreateCallback( "prop_dynamic", RespawnEntitySpawned )
				AddCreateCallback( "prop_script", RespawnEntitySpawned )
			}

		AddCreateCallback( PLAYER_WAYPOINT_CLASSNAME, PlayerWaypoint_CreateCallback )
		AddDestroyCallback( PLAYER_WAYPOINT_CLASSNAME, PlayerWaypoint_DestroyCallback )

		if ( HasInterruptableBannerPickup() )
		{
			RegisterConCommandTriggeredCallback( "+attack", AttemptCancelBannerPickup )
			RegisterConCommandTriggeredCallback( "+melee", AttemptCancelBannerPickup )

			RegisterConCommandTriggeredCallback( "+speed", AttemptCancelBannerPickup )
		}


			if ( !GameModeVariant_IsActive( eGameModeVariants.SURVIVAL_SHADOW_ARMY ) )

			{
				RegisterMinimapPackages()
			}

		RegisterButtonPressedCallback( KEY_SPACE, TryPingRespawnItem )
		RegisterButtonPressedCallback( BUTTON_A, TryPingRespawnItem )

		if( RespawnBeacons_PingFromMap_Enabled() )
			AddCallback_OnFindFullMapAimEntity( GetRespawnBeaconUnderAim, PingRespawnBeaconUnderAim )

		if ( (GetRespawnStyle() == eRespawnStyle.RESPAWN_CHAMBERS) && RespawnBeaconsAreEnabled() && !RespawnBeacons_ShouldEnableBeaconsInNonBeaconRespawnMode() )
			SetMapFeatureItem( 1100, "#RESPAWN_BEACON", "#RESPAWN_BEACON_DESC", RESPAWN_BEACON_ICON )



















































































}

void function RespawnBeacons_RegisterNetworking()
{
	RegisterNetworkedVariable( "respawnsRemaining", SNDC_PLAYER_GLOBAL, SNVT_INT, GetStartingRespawnCount() )
	RegisterNetworkedVariable( "respawnStatus", SNDC_PLAYER_GLOBAL, SNVT_INT, eRespawnStatus.NONE )
	RegisterNetworkedVariable( "respawnStatusEndTime", SNDC_PLAYER_GLOBAL, SNVT_TIME, -1 )
	RegisterNetworkedVariable( "respawnBannerPickedUpTime", SNDC_PLAYER_GLOBAL, SNVT_TIME, -1 )


		RegisterNetVarIntChangeCallback( "respawnStatus", RespawnStatusChanged )

}

void function ShRespawnBeacon_RegisterAinAnalysisFuncs()
{
	AddDropshipFlightAnalysis( eFlightPathAnalysisIndex.RESPAWN_DROPSHIP_FLYIN_MOVE, RESPAWN_DROPSHIP_MODEL, ANIM_FLYIN_MOVE, AnaylsisFuncDropshipTestJumpout, "dropship_deploy" )
}


void function RegisterMinimapPackages()
{
	if ( GetRespawnStyle() == eRespawnStyle.RESPAWN_CHAMBERS || RespawnBeacons_ShouldEnableBeaconsInNonBeaconRespawnMode() )
	{
		RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.RESPAWN_CHAMBER, MINIMAP_OBJECT_RUI, MinimapPackage_RespawnChamber, FULLMAP_OBJECT_RUI, MinimapPackage_RespawnChamber )
		RegisterMinimapPackage( "prop_script", eMinimapObject_prop_script.RESPAWN_DNA, $"ui/minimap_square_respawn_dna_pickup.rpak", MinimapPackage_RespawnDNA, $"ui/in_world_minimap_respawn_dna.rpak", MinimapPackage_RespawnDNA )
	}
}

void function RespawnStatusChanged( entity player, int new )
{
	if ( !GetCurrentPlaylistVarBool( "mrb_show_ingame_ui", true ) )
		return

	if ( player == GetLocalClientPlayer() )
		UpdateRespawnStatus( new )

	if ( new == eRespawnStatus.WAITING_FOR_DROPPOD )
		FlashGameWindow()

	entity viewPlayer = GetLocalViewPlayer()

	if ( !IsValid( viewPlayer ) )
		viewPlayer = GetLocalClientPlayer()

	if ( !IsValid( viewPlayer ) )
		return

	bool waitingToBeRespawned = HasTeammatesToRespawn( viewPlayer.GetTeam() )

	foreach ( rui in file.respawnChamberRuis )
	{
		UpdateRespawnChamberRuis( rui, waitingToBeRespawned )
	}

	foreach( rui in file.respawnChamberFullmapRuis )
	{
		RuiSetBool( rui, "hasSmallIcon", !waitingToBeRespawned )
	}

	ArrayRemoveInvalid( file.allStations )

	if ( GetRespawnStyle() != eRespawnStyle.NONE && !RespawnBeacons_ShouldEnableBeaconsInNonBeaconRespawnMode() )
	{
		int fxId = GetParticleSystemIndex( RESPAWN_BEACON_BEAM_FX )

		foreach ( ent in file.allStations )
		{
			if ( waitingToBeRespawned )
			{
				if ( !EffectDoesExist( file.chamberToBeamFX[ ent ] ) )
				{
					file.chamberToBeamFX[ ent ] = StartParticleEffectOnEntity( ent, fxId, FX_PATTACH_POINT_FOLLOW_NOROTATE, ent.LookupAttachment( "FX_EMITTER" ) )
				}
			}
			else
			{
				if ( EffectDoesExist( file.chamberToBeamFX[ ent ] ) )
				{
					EffectStop( file.chamberToBeamFX[ ent ], true, true )
				}

				file.chamberToBeamFX[ ent ] = -1
			}
		}
	}

	
	DeathScreen_RespawnStatusChanged( player, new )
}

void function UpdateRespawnChamberRuis( var rui, bool waitingToBeRespawned )
{
	if ( waitingToBeRespawned )
	{
		RuiSetFloat( rui, "distanceFade", RESPAWN_CHAMBER_ICON_FADE_DIST_FAR )
		RuiSetBool( rui, "pinToEdge", true )
		RuiSetBool( rui, "showClampArrow", true )
	}
	else if ( file.mobileRespawnSpawnInProgress )
	{
		RuiSetFloat( rui, "distanceFade", MOBILE_RESPAWN_BEACON_ICON_FADE_DIST_ZERO )
		RuiSetBool( rui, "pinToEdge", false )
		RuiSetBool( rui, "showClampArrow", false )
	}
	else
	{
		RuiSetFloat( rui, "distanceFade", RESPAWN_CHAMBER_ICON_FADE_DIST_NEAR )
		RuiSetBool( rui, "pinToEdge", false )
		RuiSetBool( rui, "showClampArrow", false )
	}
}


bool function RespawnBeaconsAreEnabled()
{
	return GetCurrentPlaylistVarBool( "respawn_beacons_enabled", true )
}

int function GetStartingRespawnCount()
{
	return GetCurrentPlaylistVarInt( "respawns", 0 )
}


bool function RespawnBeacons_PingFromMap_Enabled()
{
	return GetCurrentPlaylistVarBool( "respawnbeacons_pingfrommap_enabled", true )
}




bool function RespawnBeacons_ShouldEnableBeaconsInNonBeaconRespawnMode()
{






		if ( GameModeVariant_IsActive( eGameModeVariants.SURVIVAL_SHADOW_ARMY ) )
			return true


	return false
}


bool function IsRespawnBeacon( entity ent )
{
	switch ( ent.GetTargetName() )
	{
		case RESPAWN_CHAMBER_TARGETNAME:



		case MOBILE_RESPAWN_BEACON_TARGETNAME:
			return true
	}
	return false
}

bool function ShouldFastBannerPickup()
{
	return GetCurrentPlaylistVarBool( "fast_banner_pickup", true )
}

bool function HasInterruptableBannerPickup()
{
	return GetCurrentPlaylistVarBool( "cancelable_banner_pickup_enabled", true )
}

bool function ShouldRestoreKittedWeapons()
{
	bool isKittedWeaponsGameMode = false


		isKittedWeaponsGameMode = GetCurrentPlaylistVarBool( "is_gamemode_battle_rush", false )



		isKittedWeaponsGameMode = isKittedWeaponsGameMode || GameModeVariant_IsActive( eGameModeVariants.SURVIVAL_SHADOW_ARMY )






	return isKittedWeaponsGameMode
}

void function RespawnEntitySpawned( entity ent )
{
	if ( !IsRespawnStationEnt( ent ) )
		return

	if ( !RespawnBeaconsAreEnabled() && ent.GetTargetName() != MOBILE_RESPAWN_BEACON_TARGETNAME )
	{
		
		
		
		

		if ( IsValid( ent ) )
			ent.Destroy()
		return
	}


		if ( GetCurrentPlaylistVarBool( "mrb_show_ingame_ui", true ) )
		{
			AddEntityCallback_GetUseEntOverrideText( ent, RespawnChamber_TextOverride )
			var rui
			if ( ent.GetTargetName() == MOBILE_RESPAWN_BEACON_TARGETNAME )
				rui = AddOverheadIcon( ent, RESPAWN_BEACON_ICON, false, $"ui/overhead_icon_mobile_respawn_beacon.rpak" )
			else
				rui = AddOverheadIcon( ent, RESPAWN_BEACON_ICON, false, $"ui/overhead_icon_respawn_beacon.rpak" )
			RuiSetFloat2( rui, "iconSize", <80, 80, 0> )
			RuiSetFloat( rui, "distanceFade", RESPAWN_CHAMBER_ICON_FADE_DIST_NEAR )
			RuiSetBool( rui, "adsFade", true )
			RuiSetString( rui, "hint", "#RESPAWN_ALLCAPS" )

			thread ManageRespawnChamberData( ent, rui )

			if ( ent.GetTargetName() == RESPAWN_CHAMBER_TARGETNAME ) 
				thread RespawnBeacon_PlayHologramVFX( ent )
		}
		else if ( IsValid( ent ) && ent in file.chamberToBeamFX )
		{
			if ( EffectDoesExist( file.chamberToBeamFX[ ent ] ) )
				EffectStop( file.chamberToBeamFX[ ent ], true, true )
		}














	AddBeaconEntToRespawnBeaconsArray( ent )

	SetCallback_CanUseEntityCallback( ent, IsNotBusy )
	SetCallback_ShouldUseBlockReloadCallback( ent, SimpleShouldNotBlockReloadCallback )

	AddCallback_OnUseEntity_ClientServer( ent, RespawnChamberOnUse )

	
	
	
	
	
	
	
}



void function AddBeaconEntToRespawnBeaconsArray( entity beacon )
{
	if ( IsValid( beacon ) )
		file.allStations.append( beacon )
}










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































bool function IsNotBusy( entity player, entity ent, int useFlags )
{
	if ( Bleedout_IsBleedingOut( player ) )
		return false

	if ( player.ContextAction_IsActive() )
		return false

	if ( !SURVIVAL_PlayerAllowedToPickup( player ) )
		return false

	if ( ent.e.isBusy )
		return false

	if ( GetCurrentPlaylistVarBool( "interrupted_stops_revive", false ) )
	{
		if ( StatusEffect_HasSeverity( player, eStatusEffect.interrupted ) )
			return false
	}

	return true
}


bool function Has_BR_Respawn_WithArmor()
{
	bool hasRespawnWithArmor = GameMode_IsActive( eGameModes.SURVIVAL ) && GetCurrentPlaylistVarBool( "has_br_respawn_witharmor", true )


	if ( GameModeVariant_IsActive( eGameModeVariants.SURVIVAL_STRIKEOUT ) )
		hasRespawnWithArmor = true


	return( hasRespawnWithArmor )
}

bool function RespawnEquipped_PLV_DontResetInventory()
{
	return( GetCurrentPlaylistVarBool( "respawnequipped_dontresetinventory", false ) )
}

bool function RespawnEquipped_DontResetInventory()
{
	bool result = RespawnEquipped_PLV_DontResetInventory()





	return result
}

bool function RespawnEquipped_PLV_EnsureMin_Weapon()
{
	
	return( GetCurrentPlaylistVarBool( "respawnequipped_ensuremin_weapon", true ) )
}

bool function RespawnEquipped_PLV_EnsureMin_Consumables()
{
	
	return( GetCurrentPlaylistVarBool( "respawnEquipped_ensuremin_consumables", true ) )
}

bool function Has_BR_Respawn_Restore_NoSuicide()
{
	bool hasPreventSuicideExploit = GameMode_IsActive( eGameModes.SURVIVAL ) && GetCurrentPlaylistVarBool( "has_br_respawn_restore_nosuicide", false )
	return( hasPreventSuicideExploit )
}


bool function RespawnBeacon_PLV_NoBanners()
{
	return( GetCurrentPlaylistVarBool( "RespawnBeacon_NoBanners", false ) )
}








bool function Player_Banners_Enabled()
{
	bool has_banners 	 = !RespawnBeacon_PLV_NoBanners()
	bool no_auto_banners = !GetCurrentPlaylistVarBool( "has_auto_banners", false )
	return( has_banners && no_auto_banners )
}




















































bool function Has_BR_Respawn_WithWeapons()
{
	bool hasRespawnWithWeapons = GameMode_IsActive( eGameModes.SURVIVAL ) && GetCurrentPlaylistVarBool( "has_br_respawn_withweapons", true )
	return( hasRespawnWithWeapons )
}

bool function Has_Restore_Attachments()
{
	
	return( GetCurrentPlaylistVarBool( "has_br_respawn_withattachments", true ))
}

















const string DEFAULT_CONSUMABLES = "health_pickup_health_small:2 health_pickup_combo_small:2"
string function GetBRConsumableLoadoutString()
{
	return GetCurrentPlaylistVarString( "br_respawn_consumables", DEFAULT_CONSUMABLES )
}

const string DEFAULT_EQUIPMENT = "incapshield_pickup_lv1"
string function GetBREquipmentLoadoutString()
{
	return GetCurrentPlaylistVarString( "br_respawn_equipment", DEFAULT_EQUIPMENT )
}


bool function Has_Respawn_ChargeTac()
{
	bool hasRespawnChargeTac = GetCurrentPlaylistVarBool( "has_respawn_chargetac", false  )
	return hasRespawnChargeTac
}



void function ManageRespawnChamberData( entity ent, var rui )
{
	file.chamberToBeamFX[ ent ] <- -1
	file.respawnChamberRuis.append( rui )
	ent.EndSignal( "OnDestroy" )

	UpdateRespawnChamberRuis( rui, HasTeammatesToRespawn( GetLocalViewPlayer().GetTeam() ) )

	OnThreadEnd(
		function() : ( ent, rui )
		{
			if ( EffectDoesExist( file.chamberToBeamFX[ ent ] ) )
				EffectStop( file.chamberToBeamFX[ ent ], true, true )

			delete file.chamberToBeamFX[ ent ]

			file.respawnChamberRuis.fastremovebyvalue( rui )

			file.mobileRespawnSpawnInProgress = false
		}
	)

	WaitForever()
}

void function RespawnBeacon_PlayHologramVFX( entity ent )
{
	bool isMobile = ent.GetTargetName() == MOBILE_RESPAWN_BEACON_TARGETNAME

	vector fwd    = AnglesToForward( ent.GetAngles() )
	vector up     = AnglesToUp( ent.GetAngles() )
	vector rgt    = AnglesToRight( ent.GetAngles() )
	vector offset = up * 100
	vector angles = AnglesCompose( ent.GetAngles(), <0, 0, -10> )

	ent.EndSignal( "OnDestroy" )

	float height = isMobile ? 32.0 : RESPAWN_BEACON_HOLO_EFFECT_HEIGHT

	entity fxHolder = CreateClientsideScriptMover( $"mdl/dev/empty_model.rmdl", ent.GetOrigin() + up * height, <-90, 0, 0> )

	array<int> fx
	fx.append( StartParticleEffectOnEntity( fxHolder, GetParticleSystemIndex( RESPAWN_BEACON_EMITTER_FX ), FX_PATTACH_ABSORIGIN_FOLLOW, ATTACHMENTID_INVALID ) )
	EmitSoundOnEntity( fxHolder, SOUND_HOLOGRAM_LOOP )

	OnThreadEnd(
		function() : ( fx, fxHolder )
		{
			
			foreach ( effect in fx )
			{
				EffectStop( effect, false, true )
			}
			fxHolder.Destroy()
		}
	)

	WaitForever()
}

void function MinimapPackage_RespawnDNA( entity ent, var rui )
{
	RuiSetImage( rui, "defaultIcon", $"" )
	RuiSetImage( rui, "clampedDefaultIcon", $"" )
	RuiSetBool( rui, "useTeamColor", false )
	RuiSetFloat2( rui, "iconScale", <1.0, 60.0 / 120.0, 0.0> * 2.0 )

	thread RespawnDNA_SetCharacterIcon( ent, rui, "defaultIcon" )
}

void function RespawnDNA_SetCharacterIcon( entity ent, var rui, string argName )
{
	ent.EndSignal( "OnDestroy" )

	entity owner = ent.GetOwner()
	if ( !IsValid( owner ) )
		return

	owner.EndSignal( "OnDestroy" )

	ItemFlavor character = LoadoutSlot_WaitForItemFlavor( ToEHI( owner ), Loadout_Character() )

	asset setFile = CharacterClass_GetSetFile( character )
	asset icon    = GetGlobalSettingsAsset( setFile, "unitframe_icon" )

	RuiSetImage( rui, argName, icon )
}

void function MinimapPackage_RespawnChamber( entity ent, var rui )
{
#if MINIMAP_DEBUG
		printt( "Adding " + RESPAWN_BEACON_ICON + " (RespawnChamber) icon to minimap" )
#endif

	RuiSetImage( rui, "defaultIcon", RESPAWN_BEACON_ICON )
	RuiSetImage( rui, "smallIcon", RESPAWN_BEACON_ICON_SMALL )
	RuiSetBool( rui, "hasSmallIcon", true )
	RuiSetImage( rui, "clampedDefaultIcon", $"" )
	RuiSetBool( rui, "useTeamColor", false )

	file.respawnChamberFullmapRuis.append( rui )

	AddEntityDestroyedCallback( ent,
		void function( entity ent ) : ( rui )
		{
			file.respawnChamberFullmapRuis.fastremovebyvalue( rui )
		}
	)

	entity viewPlayer = GetLocalViewPlayer()
	if ( !IsValid( viewPlayer ) )
		viewPlayer = GetLocalClientPlayer()
	if ( !IsValid( viewPlayer ) )
		return
	bool waitingToBeRespawned = HasTeammatesToRespawn( viewPlayer.GetTeam() )
	RuiSetBool( rui, "hasSmallIcon", !waitingToBeRespawned )
}

void function MinimapPackage_RespawnChamber_ListenForBannerPossession( entity ent, var rui )
{
}

string function RespawnChamber_TextOverride( entity ent )
{
	string baseString = Localize( RespawnChamber_TextOverride_BaseString( ent ) )


	entity player = GetLocalViewPlayer()
	if( Perk_CanBuyBanners( player ) )
	{
		baseString += "\n" + Localize( "#PERK_BANNER_CRAFTING_RESPAWN_BEACON_HINT" )
	}


	return baseString
}

string function RespawnChamber_TextOverride_BaseString( entity ent )
{

	if ( ent.GetScriptPropFlags() == 1 )
		ent.e.munitionsDropSpawned = true


	if ( file.mobileRespawnSpawnInProgress )
	{
		return ""
	}

	entity player = GetLocalViewPlayer()
	int team      = player.GetTeam()
	if ( GetPlayerArrayOfTeam( team ).len() == GetPlayerArrayOfTeam_Alive( team ).len() ||
			!HasTeammatesToRespawn( team ) )
	{











			return "#HINT_RESPAWN_NEED"
	}

		return "#HINT_RESPAWN_USE"
}

string function RespawnDNA_TextOverride( entity ent )
{
	if ( GetLocalViewPlayer().GetTeam() == ent.GetTeam() )
		return Localize( "#HINT_PICKUP_DNA_USE", ent.GetOwner().GetPlayerName() )

	return "#HINT_DESTROY_DNA_USE"
}



float function GetRespawnStationUseTime( entity ent )
{
	return RESPAWN_BEACON_RESPAWN_TIME
}

void function RespawnChamberOnUse( entity pickup, entity player, int pickupFlags )
{
	if ( !IsBitFlagSet( pickupFlags, USE_INPUT_LONG ) )
		return






	if ( !HasTeammatesToRespawn( player.GetTeam() ) )
		return


	float time = Time()
	RespawnChamberOnUse_Common( pickup, player, time )









}


void function ServerToClient_RespawnChamberOnUse( entity pickup, entity player )
{
	if ( !IsValid( pickup ) || !IsValid( player ) ) 
		return

	
	
	
	if ( player.p.isInExtendedUse )
	{
		
		return
	}
	else
	{
		RespawnChamberOnUse_Common( pickup, player, Time() )
	}
}


void function RespawnChamberOnUse_Common( entity pickup, entity player, float startTime )
{

		HidePlayerHint( "#RESPAWN_AT_BEACONS_HINT" )


	ExtendedUseSettings settings
	settings.successSound = RESPAWN_BEACON_SUCCESS_SOUND

	
	settings.serverStartTime = startTime


		settings.loopSound = RESPAWN_BEACON_LOOP_SOUND
		settings.displayRui = $"ui/health_use_progress.rpak"
		settings.displayRuiFunc = DisplayRuiForRespawnChamber
		settings.icon = $""















		settings.hint = "#HINT_RESPAWNING"
		settings.icon = RESPAWN_BEACON_ICON

		if ( pickup.GetTargetName() == MOBILE_RESPAWN_BEACON_TARGETNAME )
		{
			settings.successFunc = RespawnSuccessClient_Mobile
		}

































	if ( pickup.GetTargetName() == MOBILE_RESPAWN_BEACON_TARGETNAME )
	{
		settings.duration = GetRespawnStationUseTime_Mobile( pickup )
	}






	else
		settings.duration = GetRespawnStationUseTime( pickup )

	settings.useInputFlag = IN_USE_LONG

	thread ExtendedUse( pickup, player, settings )
}

















void function DisplayRuiForRespawnChamber( entity ent, entity player, var rui, ExtendedUseSettings settings )
{
	float startTime = settings.serverStartTime > 0.0 ? settings.serverStartTime : Time()
	float endTime = startTime + settings.duration
	DisplayRuiForRespawnChamber_Internal( rui, settings.icon, startTime, endTime, settings.hint )
}

void function DisplayRuiForRespawnChamber_Internal( var rui, asset icon, float startTime, float endTime, string hint )
{
	RuiSetBool( rui, "isVisible", true )
	RuiSetImage( rui, "icon", icon )
	RuiSetGameTime( rui, "startTime", startTime )
	RuiSetGameTime( rui, "endTime", endTime )
	RuiSetString( rui, "hintKeyboardMouse", hint )
	RuiSetString( rui, "hintController", hint )
}
































































































































































array< entity > function GetPlayersToRespawn( int team )
{
	array<entity> playersToSpawn
	foreach ( p in GetPlayerArrayOfTeam( team ) )
	{
		if ( !IsAlive( p ) && p.GetPlayerNetInt( "respawnStatus" ) == eRespawnStatus.WAITING_FOR_DELIVERY )
		{
			playersToSpawn.append( p )
		}
	}

	return playersToSpawn
}

int function CountTeammatesWaitingToBeRespawned( int team )
{
	array< entity > playersToRespawn = GetPlayersToRespawn( team )
	return playersToRespawn.len()
}

bool function HasTeammatesToRespawn( int team )
{
	return CountTeammatesWaitingToBeRespawned( team ) > 0
}



string function RespawnBeacon_TextOverride( entity ent )
{
	entity player = GetLocalViewPlayer()
	entity owner  = ent.GetOwner()

	if ( !IsValid( owner ) )
		return ""

	if ( !owner.IsPlayer() )
		return ""

	if ( ent.GetTeam() == player.GetTeam() )
		return Localize( "%use% Respawn " + owner.GetPlayerName() )

	return Localize( "%use% Destroy Respawn Beacon" )
}


int function GetRespawnStatus( entity player )
{
	if ( !IsValid( player ) || !player.IsPlayer() )
		return eRespawnStatus.NONE

	return player.GetPlayerNetInt( "respawnStatus" )
}

int function GetRespawnStyle()
{
	int respawnStyle
	string playlistRespawnStyle = GetCurrentPlaylistVarString( "survival_respawn_style", "respawn_chambers" ).tolower()
	bool respawnStyleFound = false

	for( int i = 0; i < eRespawnStyle._COUNT; i++ )
	{
		string enumStyle = GetEnumString( "eRespawnStyle", i )
		if (enumStyle.tolower() == playlistRespawnStyle)
		{
			respawnStyle = i
			respawnStyleFound = true
			break
		}
	}

	Assert( respawnStyleFound, "Playlist Respawn Style '" + playlistRespawnStyle + "' is not a specified enumerator." )

	return respawnStyle
}

string function Get_RespawnStatus_String_ForPlayer( entity player )
{
	Assert( IsValid( player ) && player.IsPlayer(), FUNC_NAME() + "(): Given Player Arg is invalid." )

	int respawnStatus = player.GetPlayerNetInt( "respawnStatus" )
	string respawnStatusString = respawnStatus_EnumToStringMap[ respawnStatus ]
	return( respawnStatusString )
}

const int INFINITE_RESPAWNS = -1
int function GetRemainingRespawnsForPlayer( entity player )
{
	int numRespawnsForMode = GetStartingRespawnCount() 
	if ( numRespawnsForMode == INFINITE_RESPAWNS )
		return INFINITE_RESPAWNS

	if ( !IsValid( player ) )
		return 0

	return player.GetPlayerNetInt( "respawnsRemaining" )

}


























void function ServerCallback_DisplayWaitingForRespawn( entity ent, float startTime, float endTime )
{
	thread DisplayWaitingForRespawnThread( ent, startTime, endTime )
}

void function DisplayWaitingForRespawnThread( entity ent, float startTime, float endTime )
{
	clGlobal.levelEnt.Signal( "ReviveRuiThread" )
	clGlobal.levelEnt.EndSignal( "SquadEliminated" )
	clGlobal.levelEnt.EndSignal( "ReviveRuiThread" )

	if ( !IsValid( ent ) )
		return

	ent.SetDoDestroyCallback( true )
	ent.EndSignal( "OnDestroy" )

	if ( Time() > endTime )
		return

	DeathScreen_UpdateRespawnTime( startTime, endTime )

	OnThreadEnd(
		function() : ()
		{
		}
	)

	wait endTime - Time()
}

void function ServerCallback_RespawnPodStarted( float endTime )
{
	thread ReviveRuiThread( endTime )
}

void function ReviveRuiThread( float endTime )
{
	clGlobal.levelEnt.Signal( "ReviveRuiThread" )
	clGlobal.levelEnt.EndSignal( "SquadEliminated" )

	DeathScreen_UpdateRespawnTime( Time(), endTime )

	Chroma_RespawningInDropship()

	OnThreadEnd(
		function() : ()
		{
			Chroma_RespawnComplete()
		}
	)

	wait (endTime - Time())
}

void function ServerCallback_RespawnDNAHint()
{
	AddPlayerHint( 10.0, 1.0, $"", "#RESPAWN_AT_BEACONS_HINT" )


}

void function AttemptCancelBannerPickup( entity player )
{
	if ( !HasInterruptableBannerPickup() )
		return

	if ( !IsValid( player ) || !player.IsPlayer() )
		return

	if ( !IsPlayingBannerPickupAnim( player ) )
		return

	Remote_ServerCallFunction( "ClientToServer_CancelBannerPickupAnim" )
}



















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































bool function AnaylsisFuncDropshipTestJumpout( FlightPath flightPath, vector origin, float yaw )
{
	vector angles  = <0, yaw, 0>
	vector forward = AnglesToForward( angles )
	vector right   = AnglesToRight( angles )

	if ( !IsLegalFlightPath( flightPath, origin, forward, right, true ) )
		return false

	if ( !CanDeploy( flightPath, origin, angles, forward, right ) )
		return false

	return true
}

bool function CanDeploy( FlightPath flightPath, vector origin, vector angles, vector forward, vector right )
{
	Point deployPoint   = GetPreviewPoint( flightPath )
	vector deployOrigin = GetOriginFromPoint( deployPoint, origin, forward, right )
	vector deployAngles = GetAnglesFromPoint( deployPoint, angles )

	
	deployAngles.x = 0
	deployAngles.z = 0

	vector deployFwd = AnglesToForward( deployAngles )

	deployOrigin = deployOrigin - deployFwd * 150 

	TraceResults results = TraceHull( deployOrigin, deployOrigin - <0, 0, 1000>, <-300, -300, -300>, <300, 300, 300>, null, flightPath.traceMask, TRACE_COLLISION_GROUP_NONE )
	
	
	

	if ( results.startSolid )
		return false

	if ( results.fraction < 1 )
		return false

	return true
}


void function TryPingRespawnItem( entity player )
{
	if ( !IsSpectating() )
		return

	entity viewPlayer = GetLocalViewPlayer()

	if ( PlayerIsMarkedAsCanBeRespawned( player ) )
	{
		vector org = viewPlayer.GetOrigin()
		Remote_ServerCallFunction( "ClientCallback_PingNearestRespawn", org )
	}


		if ( !PlayerIsMarkedAsCanBeRespawned( player ) )
		{
			vector org = viewPlayer.GetOrigin()
			Remote_ServerCallFunction( "ClientCallback_PingNearestRespawn", org )
		}

}





















































































bool function IsRespawnStationPingType( int pingType )
{
	switch( pingType )
	{
		case ePingType.RESPAWN_STATION:
		case ePingType.RESPAWN_MOBILE:



			return true
	}

	return false
}

void function PlayerWaypoint_CreateCallback( entity wp )
{
	int wpType = wp.GetWaypointType()

	int pingType = Waypoint_GetPingTypeForWaypoint( wp )

	entity pingedEnt = GetPingedEntForLocWaypoint( wp )

	if ( WaypointOwnerIsMuted( wp ) )
		return

	if ( IsRespawnStationPingType( pingType ) )
	{
		if ( IsValid( pingedEnt ) )
		{
			if ( IsRespawnStationEnt( pingedEnt ) )
			{
				var rui = pingedEnt.e.overheadRui
				if ( rui != null )
				{
					RuiSetBool( rui, "isVisible", false )
				}
			}
		}
	}

	if ( pingType == ePingType.RESPAWN_CARD )
	{
		if ( IsValid( pingedEnt ) && pingedEnt.GetNetworkedClassName() == PLAYER_WAYPOINT_CLASSNAME )
		{
			var rui = pingedEnt.wp.ruiHud
			if ( rui != null )
			{
				RuiSetGameTime( rui, "startPingTime", Time() )
			}
		}
	}
}

void function PlayerWaypoint_DestroyCallback( entity wp )
{
	int wpType = wp.GetWaypointType()

	int pingType = Waypoint_GetPingTypeForWaypoint( wp )

	entity pingedEnt = GetPingedEntForLocWaypoint( wp )

	if ( IsRespawnStationPingType( pingType ) )
	{
		if ( IsValid( pingedEnt ) )
		{
			if ( IsRespawnStationEnt( pingedEnt ) )
			{
				var rui = pingedEnt.e.overheadRui
				if ( rui != null )
				{
					RuiSetBool( rui, "isVisible", true )
				}
			}
		}
	}
}

void function ServerCallback_RespawnBeaconStart( float startTime, float endTime )
{
	if ( IsSpectating() )
	{
		thread SpectatorShowRespawnRui( startTime, endTime )
	}
}

void function SpectatorShowRespawnRui( float startTime, float endTime )
{
	entity player = GetLocalViewPlayer()

	if ( !IsValid( player ) )
		return

	if ( Time() > endTime )
		return

	player.EndSignal( "OnDeath" )
	clGlobal.levelEnt.EndSignal( "SpectatorShowRespawnRui" )

	var rui = CreateFullscreenRui( $"ui/health_use_progress.rpak" )
	DisplayRuiForRespawnChamber_Internal( rui, RESPAWN_BEACON_ICON, startTime, endTime, "#HINT_RESPAWNING" )

	EmitSoundOnEntity( player, RESPAWN_BEACON_LOOP_SOUND )

	OnThreadEnd(
		function() : ( rui, player )
		{
			if ( IsValid( player ) )
			{
				StopSoundOnEntity( player, RESPAWN_BEACON_LOOP_SOUND )
			}

			RuiDestroy( rui )
		}
	)

	float waitTime = endTime - Time()
	wait waitTime
	EmitSoundOnEntity( player, RESPAWN_BEACON_SUCCESS_SOUND )
}

void function ServerCallback_RespawnBeaconStop()
{
	if ( IsSpectating() )
		clGlobal.levelEnt.Signal( "SpectatorShowRespawnRui" )

	entity player = GetLocalViewPlayer()




}


bool function IsRespawnStationEnt( entity ent )
{
	switch( ent.GetTargetName() )
	{
		case RESPAWN_CHAMBER_TARGETNAME:
		case MOBILE_RESPAWN_BEACON_TARGETNAME:



			return true

	}

	return false
}


void function RespawnSuccessClient_Mobile( entity ent, entity playerUser, ExtendedUseSettings settings )
{
	file.mobileRespawnSpawnInProgress = true

	entity viewPlayer = GetLocalViewPlayer()

	if ( !IsValid( viewPlayer ) )
		viewPlayer = GetLocalClientPlayer()

	if ( !IsValid( viewPlayer ) )
		return

	bool waitingToBeRespawned = HasTeammatesToRespawn( viewPlayer.GetTeam() )
	foreach ( rui in file.respawnChamberRuis )
	{
		UpdateRespawnChamberRuis( rui, waitingToBeRespawned )
	}
}









































































entity function GetRespawnBeaconUnderAim( vector worldPos, float worldRange )
{
	float closestDistSqr = FLT_MAX
	float worldRangeSqr = worldRange * worldRange
	entity closestEnt = null

	if( MapPing_Modify_DistanceCheck_Enabled() )
	{
		float modifier = MapPing_DistanceCheck_GetModifier()

		if( worldRange >= MapPing_DistanceCheck_GetDistanceRange() )
			modifier *= 0.5

		worldRangeSqr = ( worldRange * modifier ) * ( worldRange * modifier )
	}

	foreach ( beacon in file.allStations )
	{
		if ( !IsValid( beacon ) )
			continue

		vector beaconOrigin = beacon.GetOrigin()

		float distSqr = Distance2DSqr( beaconOrigin, worldPos )
		if ( distSqr < worldRangeSqr && distSqr < closestDistSqr  )
		{
			closestDistSqr = distSqr
			closestEnt     = beacon
		}
	}

	if ( !IsValid( closestEnt ) )
	{
		return null
	}

	
	return closestEnt
}

bool function PingRespawnBeaconUnderAim( entity beacon )
{
	entity player = GetLocalClientPlayer()

	if ( !IsValid( player ) || !IsAlive( player ) )
		return false

	if ( !IsPingEnabledForPlayer( player ) )
		return false

	Remote_ServerCallFunction( FUNCNAME_PingBeaconFromMap, beacon )

	EmitSoundOnEntity( GetLocalViewPlayer(), PING_SOUND_LOCAL_CONFIRM )

	return true
}











