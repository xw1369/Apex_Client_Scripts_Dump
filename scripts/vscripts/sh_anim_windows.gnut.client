global function ShAnimWindows_LevelInit


global function ShowEntityAndChildren
global function HideEntityAndChildren

global function ClientCodeCallback_AnimWindowStream
global function ClientCodeCallback_AnimWindowStart
global function ClientCodeCallback_AnimWindowTransition
global function ClientCodeCallback_AnimWindowStop






global function RegisterScriptAnimWindowCallbacks






global const asset BLOODHOUND_BIRD_MDL = $"mdl/creatures/bird/bird.rmdl"
global const asset REVENANT_MDL = $"mdl/humans/class/heavy/pilot_heavy_revenant.rmdl"
const string BLOODHOUND_BIRD_KEY = "set_bloodhound_raven_skin"
const string REVENANT_SHADOW_KEY = "set_revenant_shadow_skin"
const string MELEE_SKIN_KEY = "match_melee_skin"
const string ARTIFACT_SMEAR_KEY = "artifact_3p_smear"

const bool SCRIPT_ANIM_WINDOWS_DEBUG = false

const MIRAGE_HOLO_FLASH_FX = $"P_mirage_holo_flash"
const MIRAGE_HOLO_TRAIL_FX = $"P_mirage_holo_trail"

const asset SHADOW_TRAIL_FX = $"P_Bshadow_body"
const asset SHADOW_EYE_FX = $"P_BShadow_eye"
const asset SHADOW_DEATH_FX = $"P_BShadow_death"

const asset SHADOWReborn_body_FX = $"P_rev_lobby_ult_body"
const asset SHADOWReborn_EYE_FX = $"P_rev_lobby_eye"
const asset SHADOWReborn_activation_FX = $"p_rev_lobby_ult_activate_body"

const asset LIFELINE_DRONE_MDL = $"mdl/props/lifeline_drone/lifeline_drone.rmdl"
const asset LIFELINE_DRONE_JET_FX = $"P_LL_med_drone_jet_loop"
int LIFELINE_DRONE_JET_FX_IDX = -1
const asset LIFELINE_DRONE_VENT_FX = $"P_LL_med_drone_jet_ctr_loop"
int LIFELINE_DRONE_VENT_FX_IDX = -1
const asset LIFELINE_DRONE_EYEGLOW_FX = $"P_LL_med_drone_eye_loop"
int LIFELINE_DRONE_EYEGLOW_FX_IDX = -1
const int LIFELINE_DRONE_OFFLINE_SKIN = 0
const int LIFELINE_DRONE_ONLINE_SKIN = 1

const asset WRAITH_KUNAI_MDL = $"mdl/props/kunai/kunai.rmdl"
const int WRAITH_KUNAI_SKIN = 0
const int WRAITH_KUNAI_SKIN_NEW = 1


struct {
	table<string, void functionref(ScriptAnimWindow, var, entity)> createPropScriptCallbackMap
	table<string, void functionref(entity ent, string parameter)>  scriptAnimWindowStartCallbacks
	table<string, void functionref(entity ent, string parameter)>  scriptAnimWindowStopCallbacks
} file







void function ShAnimWindows_LevelInit()
{
	const bool BOTH = SERVER || CLIENT


		RegisterAnimWindowPropScriptCallback( "add_glad_card_rui", AddGladCardRUIToProp )
		RegisterAnimWindowPropScriptCallback( BLOODHOUND_BIRD_KEY, AnimWindow_SetBloodhoundRavenPropSkin )
		RegisterAnimWindowPropScriptCallback( REVENANT_SHADOW_KEY, AnimWindow_SetRevenantShadowPropSkin )
		RegisterAnimWindowPropScriptCallback( MELEE_SKIN_KEY, AnimWindow_MatchMeleePropSkin )
		RegisterAnimWindowPropScriptCallback( ARTIFACT_SMEAR_KEY, AnimWindow_SetSmearPropColour )

		RegisterScriptAnimWindowCallbacks( "DisableGunTargetingLaser", AnimWindow_DisableGunTargetingLaser_Start, AnimWindow_DisableGunTargetingLaser_Stop )



		
		RegisterAnimWindowType( BOTH, "CreateProp", null, AnimWindow_CreateProp_Precache, AnimWindow_CreateProp_StreamHint, AnimWindow_CreateProp_Start, AnimWindow_CreateProp_Transition, AnimWindow_CreateProp_Stop )
		RegisterAnimWindowType( CLIENT, "PlaySound", null, AnimWindow_PlaySound_Precache, null, AnimWindow_PlaySound_Start, AnimWindow_PlaySound_Transition, AnimWindow_PlaySound_Stop )
		RegisterAnimWindowType( BOTH, "PlayFX", null, AnimWindow_PlayFX_Precache, null, AnimWindow_PlayFX_Start, AnimWindow_PlayFX_Transition, AnimWindow_PlayFX_Stop )
		RegisterAnimWindowType( BOTH, "SetConVar", null, null, null, AnimWindow_SetConVar_Start, null, AnimWindow_SetConVar_Stop )
		RegisterAnimWindowType( BOTH, "Callback", null, null, null, AnimWindow_Callback_Start, null, AnimWindow_Callback_Stop )
		RegisterAnimWindowType( CLIENT, "FadeAlphaOverTime", null, null, null, AnimWindow_FadeAlphaOverTime_Start, null, AnimWindow_FadeAlphaOverTime_Stop )
		RegisterAnimWindowType( CLIENT, "SetSkin", null, null, null, AnimWindow_SetSkin_Start, null, null )
		RegisterAnimWindowType( BOTH, "SetPropSkin", null, null, null, AnimWindow_SetPropSkin_Start, null, null )
		RegisterAnimWindowType( CLIENT, "SetColorModScaleOverDuration", AnimWindow_SetColorModScaleOverDuration_Init, null, null, AnimWindow_SetColorModScaleOverDuration_Start, AnimWindow_SetColorModScaleOverDuration_Transition, AnimWindow_SetColorModScaleOverDuration_Stop )
		RegisterAnimWindowType( CLIENT, "SetLodOriginAttachment", null, null, null, AnimWindow_SetLodOriginAttachment_Start, null, AnimWindow_SetLodOriginAttachment_Stop )
		RegisterAnimWindowType( CLIENT, "HideEnt", null, null, null, AnimWindow_HideEnt_Start, null, AnimWindow_HideEnt_Stop )

		
		RegisterAnimWindowType( CLIENT, "MirageHoloFX", AnimWindow_MirageHoloFX_Init, AnimWindow_MirageHoloFX_Precache, null, AnimWindow_MirageHoloFX_Start, AnimWindow_MirageHoloFX_Transition, AnimWindow_MirageHoloFX_Stop )
		RegisterAnimWindowType( CLIENT, "ShadowFormFX", AnimWindow_ShadowFormFX_Init, AnimWindow_ShadowFormFX_Precache, null, AnimWindow_ShadowFormFX_Start, AnimWindow_ShadowFormFX_Transition, AnimWindow_ShadowFormFX_Stop )
		RegisterAnimWindowType( CLIENT, "ShadowFormRebornFX", AnimWindow_ShadowFormRebornFX_Init, AnimWindow_ShadowFormRebornFX_Precache, null, AnimWindow_ShadowFormRebornFX_Start, AnimWindow_ShadowFormRebornFX_Transition, AnimWindow_ShadowFormRebornFX_Stop )
		RegisterAnimWindowType( CLIENT, "LifelineDroneCommonFX", AnimWindow_LifelineDroneCommonFX_Init, AnimWindow_LifelineDroneCommonFX_Precache, null, AnimWindow_LifelineDroneCommonFX_Start, AnimWindow_LifelineDroneCommonFX_Transition, AnimWindow_LifelineDroneCommonFX_Stop )
		RegisterAnimWindowType( CLIENT, "HideWeapon3P", AnimWindow_HideWeapon3P_Init, AnimWindow_HideWeapon3P_Precache, null, AnimWindow_HideWeapon3P_Start, AnimWindow_HideWeapon3P_Transition, AnimWindow_HideWeapon3P_Stop )
		RegisterAnimWindowType( CLIENT, "OverrideCharacterSelectCamera", AnimWindow_OverrideCharacterSelectCamera_Init, AnimWindow_OverrideCharacterSelectCamera_Precache, null, AnimWindow_OverrideCharacterSelectCamera_Start, AnimWindow_OverrideCharacterSelectCamera_Transition, AnimWindow_OverrideCharacterSelectCamera_Stop )

		RegisterSignal( "StopLodOriginAttachment" )

}


void function RegisterAnimWindowPropScriptCallback( string ref, void functionref(ScriptAnimWindow, var, entity) func )
{
	file.createPropScriptCallbackMap[ ref ] <- func
}






table<string, entity> windowPropMap = {}

enum eAnimWindowCreatePropModelSelectionStrategy
{
	HARD_CODED,
	COPY_PARENT,
	SCRIPT_KEY,
}

enum eAnimWindowSkinSelectionStrategy
{
	HARD_CODED,
	DEFAULT,
	PLAYER_EQUIPPED,
}



void function AddGladCardRUIToProp( ScriptAnimWindow window, var settingsBlock, entity prop )
{
	thread CreateGladCardRui( prop )
}



void function CreateGladCardRui( entity prop )
{
	prop.EndSignal( "OnDestroy" )
	prop.RenderWithViewModels( true )

	entity viewPlayer = GetLocalViewPlayer()

	if ( !IsValid( viewPlayer ) )
		return

	entity player = viewPlayer.GetPlayerNetEnt( "gladCardPlayer" )

	while ( !IsValid( player ) && IsValid( prop ) )
	{
		player = viewPlayer.GetPlayerNetEnt( "gladCardPlayer" )
		WaitFrame()
	}

	if ( !IsValid( prop ) )
		return

	
	if ( player.IsThirdPersonShoulderModeOn() )
		return

	EHI ehi = ToEHI( player )

	float MAGIC_DEATHBOX_Z_OFFSET = 1.25

	float scale  = 0.0125
	float width  = 264 * scale
	float height = 720 * scale

	float direction = 1.0
	vector right    = <0, 1, 0> * width * 0.5
	vector fwd      = <1, 0, 0> * height * 0.5

	vector org = <0, 0, 0.2>

	var topo = RuiTopology_CreatePlane( org - fwd * 0.5 - right * 0.5, right, fwd, true )
	RuiTopology_SetParent( topo, prop )

	var rui = RuiCreate( $"ui/gladiator_card_deathbox.rpak", topo, RUI_DRAW_VIEW_MODEL, MINIMAP_Z_BASE + 10 )

	NestedGladiatorCardHandle nestedGCHandle = CreateNestedGladiatorCard( rui, "card", eGladCardDisplaySituation.DEATH_BOX_STILL, eGladCardPresentation.FRONT_DETAILS )
	ChangeNestedGladiatorCardOwner( nestedGCHandle, ehi, null, eGladCardLifestateOverride.ALIVE )

	OnThreadEnd (
		void function() : ( topo, rui, nestedGCHandle )
		{
			CleanupNestedGladiatorCard( nestedGCHandle )
			RuiDestroy( rui )
			RuiTopology_Destroy( topo )
			Remote_ServerCallFunction( "ClientToServer_GladCardPlayerReset" )
		}
	)

	while ( IsValid( prop ) )
	{
		WaitFrame()
	}
}




void function CreateTeaseRui( entity prop, asset ruiAsset, int logId )
{
	prop.EndSignal( "OnDestroy" )
	prop.RenderWithViewModels( true )

	entity viewPlayer = GetLocalViewPlayer()

	string screenText = ""
	int phase         = 0

	if ( !IsValid( viewPlayer ) || !IsValid( prop ) )
		return

	float scale  = 0.0125
	float width  = 400 * scale
	float height = 720 * scale

	float direction = 1.0
	vector right    = <0, 1, 0> * width * 0.5
	vector fwd      = <1, 0, 0> * height * 0.5

	vector org = <0, 0, 0.2>

	var topo = RuiTopology_CreatePlane( org - fwd * 0.5 - right * 0.5, right, fwd, true )
	RuiTopology_SetParent( topo, prop )

	var rui = RuiCreate( ruiAsset, topo, RUI_DRAW_VIEW_MODEL, MINIMAP_Z_BASE + 10 )

	OnThreadEnd (
		void function() : ( topo, rui )
		{
			RuiDestroy( rui )
			RuiTopology_Destroy( topo )
		}
	)

	while ( IsValid( prop ) )
	{
		WaitFrame()
	}
}


void function AnimWindow_CreateProp_Precache( var settingsBlock )
{
	int selectModelFrom = eAnimWindowCreatePropModelSelectionStrategy[GetSettingsBlockString( settingsBlock, "selectModelFrom" )]
	if ( selectModelFrom == eAnimWindowCreatePropModelSelectionStrategy.HARD_CODED )
	{
		PrecacheModel( GetSettingsBlockAsset( settingsBlock, "modelName" ) )
	}
	else if ( selectModelFrom == eAnimWindowCreatePropModelSelectionStrategy.SCRIPT_KEY )
	{
		switch ( GetSettingsBlockString( settingsBlock, "modelScriptKey" ) )
		{
			case "wraith_kunai":
			{
				PrecacheModel( WRAITH_KUNAI_MDL )
				break
			}
		}
	}
}

bool function AnimWindow_CreateProp_StreamHint( var settingsBlock )
{

	asset ornull model = null
	int selectModelFrom = eAnimWindowCreatePropModelSelectionStrategy[GetSettingsBlockString( settingsBlock, "selectModelFrom" )]
	if ( selectModelFrom == eAnimWindowCreatePropModelSelectionStrategy.HARD_CODED )
	{
		model = GetSettingsBlockAsset( settingsBlock, "modelName" )
	}
	else if ( selectModelFrom == eAnimWindowCreatePropModelSelectionStrategy.SCRIPT_KEY )
	{
		switch ( GetSettingsBlockString( settingsBlock, "modelScriptKey" ) )
		{
			case "wraith_kunai":
			{
				model = WRAITH_KUNAI_MDL
				break
			}
		}
	}

	if ( model == null )
	{
		return true
	}

	expect asset(model)

	
	int odlHandle = ODL_FindAsset( ODL_SKINS, model )
	if ( odlHandle != -1 )
	{
		if( !ODL_IsLoaded( ODL_SKINS, odlHandle ) )
		{
			ODL_HintNeeded( ODL_SKINS, odlHandle, true )
			return false
		}
	}

	
	if ( !StreamModelIsResident( model ) )
	{
		StreamModelHint( model )
		return false
	}


	return true
}

void function AnimWindow_CreateProp_Start( ScriptAnimWindow window, var settingsBlock )
{
	int selectModelFrom = eAnimWindowCreatePropModelSelectionStrategy[GetSettingsBlockString( settingsBlock, "selectModelFrom" )]
	asset model         = EMPTY_MODEL
	if ( selectModelFrom == eAnimWindowCreatePropModelSelectionStrategy.HARD_CODED )
	{
		model = GetSettingsBlockAsset( settingsBlock, "modelName" )
	}
	else if ( selectModelFrom == eAnimWindowCreatePropModelSelectionStrategy.COPY_PARENT )
	{
		model = window.ent.GetModelName()
	}





		entity prop = CreateClientSidePropDynamic( window.ent.GetOrigin(), window.ent.GetAngles(), model )
		prop.SetParent( window.ent )
		
		prop.MakeSafeForUIScriptHack()

		if ( selectModelFrom == eAnimWindowCreatePropModelSelectionStrategy.SCRIPT_KEY )
		{
			SetModelOnPropByScriptKey( prop, GetSettingsBlockString( settingsBlock, "modelScriptKey" ), window.ent )
		}

		
		
		

		SetTeam( prop, window.ent.GetTeam() )
		prop.kv.renderamt = window.ent.kv.renderamt
		prop.CopyHighlightState( window.ent )
		
			


	
	var bodyGroupArr       = GetSettingsBlockArray( settingsBlock, "propBodygroups" )
	int bodygroupArraySize = GetSettingsArraySize( bodyGroupArr )
	for ( int index = 0; index < bodygroupArraySize; index++ )
	{
		var bodyGroupElem = GetSettingsArrayElem( bodyGroupArr, index )
		string bodyGroup  = GetSettingsBlockString( bodyGroupElem, "bodygroup" )
		int subModelIndex = GetSettingsBlockInt( bodyGroupElem, "index" )

		int bodyGroupIndex = prop.FindBodygroup( bodyGroup )
		if ( bodyGroupIndex != -1 )
			prop.SetBodygroupModelByIndex( bodyGroupIndex, subModelIndex )
	}

	if ( selectModelFrom == eAnimWindowCreatePropModelSelectionStrategy.COPY_PARENT )
	{
		prop.SetSkin( window.ent.GetSkin() )
		prop.SetCamo( window.ent.GetCamo() )
	}
	else if ( selectModelFrom != eAnimWindowCreatePropModelSelectionStrategy.SCRIPT_KEY )
	{
		string characterSkinName = window.ent.GetSkinNameByIndex( window.ent.GetSkin() )
		int characterCamo        = window.ent.GetCamo()
		AbilityCosmetics_Apply( prop, characterSkinName, characterCamo )
	}

	string scriptCallbackKey = GetSettingsBlockString( settingsBlock, "scriptCallbackKey" )
	if ( scriptCallbackKey != "" )
	{
		Assert( scriptCallbackKey in file.createPropScriptCallbackMap )
		file.createPropScriptCallbackMap[scriptCallbackKey]( window, settingsBlock, prop )
	}

#if DEV
		disableoverwrite( windowPropMap )
#endif
	windowPropMap[window.stringID] <- prop

	bool syncCycle = GetSettingsBlockBool( settingsBlock, "syncCycle" )
	if ( syncCycle )
		window.ent.AnimSyncScriptProp_Begin( prop, window.startCycle, window.endCycle, window.windowName )

	AnimWindow_CreateProp_Transition( window, settingsBlock )
}


void function AnimWindow_CreateProp_Transition( ScriptAnimWindow window, var settingsBlock )
{
	string scriptCallbackKey = GetSettingsBlockString( settingsBlock, "scriptCallbackKey" )
	asset animSeq            = GetSettingsBlockAsset( settingsBlock, "animSequence" )
	string attachmentName    = GetSettingsBlockString( settingsBlock, "attachPoint" )
	float scale              = GetSettingsBlockFloat( settingsBlock, "scale" )

	Assert( window.stringID in windowPropMap )
	entity prop = windowPropMap[window.stringID]

	prop.SetParent( window.ent, attachmentName, false )
	
	prop.SetModelScale( scale * window.ent.GetModelScale() )

	
	
	entity parentEnt = window.ent
	if ( !parentEnt.IsPlayer() )
	{
		entity proxyOwner = parentEnt.GetOwner()
		if ( IsValid( proxyOwner ) && proxyOwner.IsPlayer() )
		{
			parentEnt = proxyOwner
		}
	}
	if ( scriptCallbackKey == MELEE_SKIN_KEY )
	{
		string meleeSkinName = ""
		if ( parentEnt.IsPlayer() )
		{
			meleeSkinName = MeleeSkin_GetSkinNameFromPlayer( parentEnt )
			printt( "Execution uses player melee skin: " + meleeSkinName )
		}
		else 
		{

				ItemFlavor ornull meleeSkinFlavor = parentEnt.e.animWindowMeleeSkinItemFlavor

				if ( meleeSkinFlavor != null )
				{
					expect ItemFlavor( meleeSkinFlavor )
					meleeSkinName = MeleeSkin_GetSkinName( meleeSkinFlavor )
					printt( "Glad card uses melee skin: " + meleeSkinName )
				}

		}
		if ( meleeSkinName != "" && meleeSkinName != "default" )
		{
			int skindex = prop.GetSkinIndexByName( meleeSkinName )

			var animArr       = GetSettingsBlockArray( settingsBlock, "additionalAnims" )
			int animArraySize = GetSettingsArraySize( animArr )

			if ( animArraySize > 0 && skindex > 1 && skindex - 2 < animArraySize )
			{
				var animElem = GetSettingsArrayElem( animArr, skindex - 2 )
				asset anim   = GetSettingsBlockAsset( animElem, "animSequence" )

				animSeq = anim
			}
		}
	}

	if ( animSeq != $"" )
	{
		prop.Anim_Play( animSeq )

		float curCycle = window.ent.GetCycle()

		float cycleValue = 0
		if ( window.endCycle > window.startCycle )
			cycleValue = (curCycle - window.startCycle) / (window.endCycle - window.startCycle)
		cycleValue = Clamp( cycleValue, 0.0, 1.0 )
		prop.SetCycle( cycleValue )
	}
	else
	{
		prop.Anim_Stop()
	}
}


void function AnimWindow_CreateProp_Stop( ScriptAnimWindow window, var settingsBlock )
{
	Assert( window.stringID in windowPropMap )
	entity prop = windowPropMap[window.stringID]
	delete windowPropMap[window.stringID]

	bool syncCycle = GetSettingsBlockBool( settingsBlock, "syncCycle" )
	if ( syncCycle )
		window.ent.AnimSyncScriptProp_End( prop )

	if ( IsValid( prop ) )
		prop.Destroy()
}


void function SetModelOnPropByScriptKey( entity propEnt, string key, entity parentEnt )
{
	
	switch( key )
	{
		case "bloodhound_raven":
			propEnt.SetModel( BLOODHOUND_BIRD_MDL )
			break

		case "lifeline_drone":
			propEnt.SetModel( LIFELINE_DRONE_MDL )
			propEnt.SetSkin( LIFELINE_DRONE_ONLINE_SKIN )
			break

		case "wraith_kunai":
			propEnt.SetModel( WRAITH_KUNAI_MDL )

			bool usesNewKunai = false;
			ItemFlavor ornull meleeSkinFlavor = parentEnt.e.animWindowMeleeSkinItemFlavor
			if ( meleeSkinFlavor != null )
			{
				expect ItemFlavor( meleeSkinFlavor )
				asset meleeWeaponAsset = GetGlobalSettingsAsset( ItemFlavor_GetAsset( meleeSkinFlavor ), "parentItemFlavor" )
				ItemFlavor meleeWeapon = GetItemFlavorByAsset( meleeWeaponAsset )
				string skinname        = MeleeWeapon_GetMainWeaponClassname( meleeWeapon )
				usesNewKunai = skinname == "mp_weapon_wraith_kunai_rt01_primary"
			}

			if ( usesNewKunai )
			{
				propEnt.SetSkin( WRAITH_KUNAI_SKIN_NEW )
			}
			else
			{
				propEnt.SetSkin( WRAITH_KUNAI_SKIN )
			}
			break


		default:
			Assert( false, "Unknown script key for CreateProp anim window: " + key )
			break
	}
}







table<string, var> windowSoundHandleMap = {}



void function AnimWindow_PlaySound_Precache( var settingsBlock )
{
	
}


void function AnimWindow_PlaySound_Start( ScriptAnimWindow window, var settingsBlock )
{
	string soundEventName = GetSettingsBlockString( settingsBlock, "soundEventName" )




		entity viewPlayer = GetLocalViewPlayer()
		if ( IsValid( viewPlayer ) && !viewPlayer.DoesShareRealms( window.ent ) )
		{
			windowSoundHandleMap[window.stringID] <- null
			return
		}
		var soundHandle = EmitSoundOnEntity( window.ent, soundEventName )

#if DEV
			disableoverwrite( windowSoundHandleMap )
#endif
		windowSoundHandleMap[window.stringID] <- soundHandle

}


void function AnimWindow_PlaySound_Transition( ScriptAnimWindow window, var settingsBlock )
{
	
}


void function AnimWindow_PlaySound_Stop( ScriptAnimWindow window, var settingsBlock )
{



		entity viewPlayer = GetLocalViewPlayer()
		if ( windowSoundHandleMap[window.stringID] )
			StopSound( windowSoundHandleMap[window.stringID] )
		delete windowSoundHandleMap[window.stringID]

}










typedef AnimWindow_PlayFX_HandleOrNull int ornull

table<string, AnimWindow_PlayFX_HandleOrNull> windowFXHandleMap = {}


void function AnimWindow_PlayFX_Precache( var settingsBlock )
{
	asset particleAsset = GetSettingsBlockStringAsAsset( settingsBlock, "particleSystemName" )
	PrecacheParticleSystem( particleAsset )
}


void function AnimWindow_PlayFX_Start( ScriptAnimWindow window, var settingsBlock )
{
	asset particleAsset     = GetSettingsBlockStringAsAsset( settingsBlock, "particleSystemName" )
	int particleSystemIndex = GetParticleSystemIndex( particleAsset )

	bool shouldFollow = GetSettingsBlockBool( settingsBlock, "followAttach" )
	string attachment = GetSettingsBlockString( settingsBlock, "attachPoint" )


	AnimWindow_PlayFX_HandleOrNull fxHandleOrNull = null

	int attachID
	if ( attachment != "" )
	{
		attachID = window.ent.LookupAttachment( attachment )
		if ( attachID <= 0 )
			Warning( "Attachment %s not found on model %s while trying to create script anim window %s", attachment, string(window.ent.GetModelName()), string(window.settingsAsset) )
	}

	if ( shouldFollow )
	{
		if ( attachment != "" )
		{
			if ( attachID > 0 )
			{



					fxHandleOrNull = StartParticleEffectOnEntity( window.ent, particleSystemIndex, FX_PATTACH_POINT_FOLLOW, attachID )

			}
		}
		else
		{



				fxHandleOrNull = StartParticleEffectOnEntityWithPos( window.ent, particleSystemIndex, FX_PATTACH_CUSTOMORIGIN_FOLLOW, ATTACHMENTID_INVALID, <0, 0, 0>, <0, 0, 0> )

		}
	}
	else
	{
		if ( attachment != "" )
		{
			if ( attachID > 0 )
			{
				vector origin = window.ent.GetAttachmentOrigin( attachID )
				vector angles = window.ent.GetAttachmentAngles( attachID )



					fxHandleOrNull = StartParticleEffectInWorldWithHandle( particleSystemIndex, origin, angles )

			}
		}
		else
		{
			vector origin = window.ent.GetOrigin()
			vector angles = window.ent.GetAngles()



				fxHandleOrNull = StartParticleEffectInWorldWithHandle( particleSystemIndex, origin, angles )

		}
	}


		if ( GetCurrentPlaylistVarBool( "anim_fx_window_sound", true ) && fxHandleOrNull )
		{
			EffectSetSoundEnabled( expect int( fxHandleOrNull ), true )
		}


#if DEV
		disableoverwrite( windowFXHandleMap )
#endif

	windowFXHandleMap[window.stringID] <- fxHandleOrNull
}


void function AnimWindow_PlayFX_Transition( ScriptAnimWindow window, var settingsBlock )
{
	
}


void function AnimWindow_PlayFX_Stop( ScriptAnimWindow window, var settingsBlock )
{
	AnimWindow_PlayFX_HandleOrNull fxHandleOrNull = windowFXHandleMap[window.stringID]
	delete windowFXHandleMap[window.stringID]

	if ( fxHandleOrNull != null )
	{
		bool shouldPlayEndCap = GetSettingsBlockBool( settingsBlock, "playEndCap" )







			if ( shouldPlayEndCap )
				EffectStop( expect int( fxHandleOrNull ), false, true )
			else
				EffectStop( expect int( fxHandleOrNull ), true, false )

	}
}







void function AnimWindow_SetConVar_Start( ScriptAnimWindow window, var settingsBlock )
{
	string conVarName = GetSettingsBlockString( settingsBlock, "conVarName" )
	float startValue  = GetSettingsBlockFloat( settingsBlock, "startValue" )

	SetConVarFloat( strip( conVarName ), startValue )
}


void function AnimWindow_SetConVar_Stop( ScriptAnimWindow window, var settingsBlock )
{
	string conVarName = GetSettingsBlockString( settingsBlock, "conVarName" )
	float endValue    = GetSettingsBlockFloat( settingsBlock, "endValue" )

	if ( endValue == -1.0 )
		SetConVarToDefault( strip( conVarName ) )
	else
		SetConVarFloat( strip( conVarName ), endValue )
}







void function AnimWindow_Callback_Start( ScriptAnimWindow window, var settingsBlock )
{
	string callbackName = GetSettingsBlockString( settingsBlock, "callbackName" )
	string parameter    = GetSettingsBlockString( settingsBlock, "callbackParameter" )

	Assert( callbackName in file.scriptAnimWindowStartCallbacks, "%s callback name doesn't contain a start callback function to call" )
	file.scriptAnimWindowStartCallbacks[callbackName]( window.ent, parameter )
}


void function AnimWindow_Callback_Stop( ScriptAnimWindow window, var settingsBlock )
{
	string callbackName = GetSettingsBlockString( settingsBlock, "callbackName" )
	string parameter    = GetSettingsBlockString( settingsBlock, "callbackParameter" )

	Assert( callbackName in file.scriptAnimWindowStopCallbacks, "%s callback name doesn't contain a stop callback function to call" )
	file.scriptAnimWindowStopCallbacks[callbackName]( window.ent, parameter )
}


void function RegisterScriptAnimWindowCallbacks( string callbackName, void functionref( entity, string ) startCallbackFunc, void functionref( entity, string ) stopCallbackFunc )
{
	Assert( !(callbackName in file.scriptAnimWindowStartCallbacks), "Tried to add Script Anim Window Start Callback that was already added" )
	file.scriptAnimWindowStartCallbacks[ callbackName ] <- startCallbackFunc

	Assert( !(callbackName in file.scriptAnimWindowStopCallbacks), "Tried to add Script Anim Window Stop Callback that was already added" )
	file.scriptAnimWindowStopCallbacks[ callbackName ] <- stopCallbackFunc
}







void function AnimWindow_FadeAlphaOverTime_Start( ScriptAnimWindow window, var settingsBlock )
{
	float fadeDuration = GetSettingsBlockFloat( settingsBlock, "fadeDuration" )
	int alphaStart     = GetSettingsBlockInt( settingsBlock, "alphaStart" )
	int alphaEnd       = GetSettingsBlockInt( settingsBlock, "alphaEnd" )

	window.ent.kv.renderamt = alphaStart

	
	thread PROTO_FadeModelAlphaOverTime( window.ent, fadeDuration, alphaStart, alphaEnd )
}


void function AnimWindow_FadeAlphaOverTime_Stop( ScriptAnimWindow window, var settingsBlock )
{
	
	window.ent.kv.renderamt = GetSettingsBlockInt( settingsBlock, "alphaEnd" )
}







void function AnimWindow_SetSkin_Start( ScriptAnimWindow window, var settingsBlock )
{
	int selectModelFrom = eAnimWindowSkinSelectionStrategy[GetSettingsBlockString( settingsBlock, "selectFlavorFrom" )]

	ItemFlavor ornull skin = null


#if DEV
			
			asset settingsAsset = window.settingsAsset
			string stringID     = window.stringID
			entity ent          = window.ent
#endif

		if ( selectModelFrom == eAnimWindowSkinSelectionStrategy.HARD_CODED )
		{
			asset skinAsset = GetSettingsBlockAsset( settingsBlock, "flavor" )
			if ( IsValidItemFlavorSettingsAsset( skinAsset ) )
				skin = GetItemFlavorByAsset( skinAsset )
		}
		else if ( selectModelFrom == eAnimWindowSkinSelectionStrategy.DEFAULT )
		{
			Assert( window.ent.e.animWindowCosmeticItemFlavor != null )
			ItemFlavor ornull cosmeticFlavor = window.ent.e.animWindowCosmeticItemFlavor
			expect ItemFlavor( cosmeticFlavor )

			LoadoutEntry ornull loadoutEntry = null
			switch ( ItemFlavor_GetType( cosmeticFlavor ) )
			{
				case eItemType.character:
					loadoutEntry = Loadout_CharacterSkin( cosmeticFlavor )
					break

				case eItemType.loot_main_weapon:
					loadoutEntry = Loadout_WeaponSkin( cosmeticFlavor )
					break
			}

			if ( loadoutEntry != null )
				skin = GetDefaultItemFlavorForLoadoutSlot( EHI_null, expect LoadoutEntry( loadoutEntry ) )
		}
		else if ( selectModelFrom == eAnimWindowSkinSelectionStrategy.PLAYER_EQUIPPED )
		{
			Assert( window.ent.e.animWindowCosmeticItemFlavor != null )
			Assert( window.ent.e.animWindowSkinItemFlavor != null )

			ItemFlavor ornull cosmeticFlavor = window.ent.e.animWindowCosmeticItemFlavor
			expect ItemFlavor( cosmeticFlavor )
			ItemFlavor ornull skinFlavor = window.ent.e.animWindowSkinItemFlavor
			expect ItemFlavor( skinFlavor )

			switch ( ItemFlavor_GetType( cosmeticFlavor ) )
			{
				case eItemType.character:
					Assert( CharacterSkin_GetCharacterFlavor( skinFlavor ) == cosmeticFlavor )
					skin = skinFlavor
					break

				case eItemType.loot_main_weapon:
					Assert( WeaponSkin_GetWeaponFlavor( skinFlavor ) == cosmeticFlavor )
					skin = skinFlavor
					break
			}
		}


	if ( skin == null )
		return

	expect ItemFlavor( skin )

	if ( GetSettingsBlockBool( settingsBlock, "isStreamHint" ) )
	{
		asset ornull assetToStreamHint = null
		switch ( ItemFlavor_GetType( skin ) )
		{
			case eItemType.character_skin:
				assetToStreamHint = CharacterSkin_GetBodyModel( skin )
				break

			default:
				Assert( false, "NYI" )
				break
		}

		if ( assetToStreamHint == null )
			return




			StreamModelHint( expect asset( assetToStreamHint ) )

	}
	else
	{
		float cycleValue    = window.ent.GetCycle()
		string sequenceName = window.ent.GetCurrentSequenceName()
		CharacterSkin_Apply( window.ent, skin )
		window.ent.Anim_Play( sequenceName )
		window.ent.SetCycle( cycleValue )
	}
}






void function AnimWindow_SetPropSkin_Start( ScriptAnimWindow window, var settingsBlock )
{
	string skinName = GetSettingsBlockString( settingsBlock, "skinName" )
	int camoIndex   = GetSettingsBlockInt( settingsBlock, "camoIndex" )

	printt( "PROP SKIN: " + window.ent.GetModelName() + " SKIN: " + skinName )
	AbilityCosmetics_Apply ( window.ent, skinName, camoIndex )
}







void function AnimWindow_SetLodOriginAttachment_Thread( entity ent, int attachmentId )
{
	EndSignal( ent, "OnDestroy" )
	EndSignal( ent, "StopLodOriginAttachment" )

	OnThreadEnd( void function() : (ent) {
		ent.DisableLodOriginOverride()
	} )

	while( true )
	{
		vector attachmentOrigin = ent.GetAttachmentOrigin( attachmentId )
		ent.SetLodOriginOverride( attachmentOrigin )
		WaitFrame()
	}
}


void function AnimWindow_SetLodOriginAttachment_Start( ScriptAnimWindow window, var settingsBlock )
{

		string attachment = GetSettingsBlockString( settingsBlock, "attachment" )
		int attachmentId  = window.ent.LookupAttachment( attachment )

		thread AnimWindow_SetLodOriginAttachment_Thread( window.ent, attachmentId )

}


void function AnimWindow_SetLodOriginAttachment_Stop( ScriptAnimWindow window, var settingsBlock )
{

		Signal( window.ent, "StopLodOriginAttachment" )

}






void function AnimWindow_HideEnt_Start( ScriptAnimWindow window, var settingsBlock )
{
	entity ent = window.ent
	Assert( IsValid( ent ) )

	ent.kv.rendermode = 4
	ent.kv.renderamt = 0

	bool hideChildren = GetSettingsBlockBool( settingsBlock, "hideChildren" )
	if ( hideChildren )
	{
		array<entity> hierachy = GetEntityAndAllChildren( ent )
		foreach ( entity hierachyEnt in hierachy )
		{
			hierachyEnt.kv.rendermode = 4
			hierachyEnt.kv.renderamt = 0
		}
	}
}

void function AnimWindow_HideEnt_Stop( ScriptAnimWindow window, var settingsBlock )
{
	entity ent = window.ent
	Assert( IsValid( ent ) )

	ent.kv.rendermode = 4
	ent.kv.renderamt = 255

	bool hideChildren = GetSettingsBlockBool( settingsBlock, "hideChildren" )
	if ( hideChildren )
	{
		array<entity> hierachy = GetEntityAndAllChildren( ent )
		foreach ( entity hierachyEnt in hierachy )
		{
			hierachyEnt.kv.rendermode = 4
			hierachyEnt.kv.renderamt = 255
		}
	}
}






void function AnimWindow_ShadowFormFX_Init()
{
	PrecacheParticleSystem( SHADOW_TRAIL_FX )
	PrecacheParticleSystem( SHADOW_EYE_FX )
	PrecacheParticleSystem( SHADOW_DEATH_FX )

		RegisterSignal( "StopShadowFormFX" )

}


void function AnimWindow_ShadowFormFX_Precache( var settingsBlock )
{
	
	PrecacheSkinName( "ShadowSqaud" )
}


void function AnimWindow_ShadowFormFX_Start( ScriptAnimWindow window, var settingsBlock )
{



		Assert( !window.ent.IsPlayer(), "The \"ShadowFormFX\" script anim window type should not be used on players because it would reset their highlight. Work is required if this is needed." )

		string attachmentName = GetSettingsBlockString( settingsBlock, "attachPoint" )
		int attachIndex       = window.ent.LookupAttachment( attachmentName )

		float fadeInDuration  = GetSettingsBlockFloat( settingsBlock, "fadeInDuration" )
		float fadeOutDuration = GetSettingsBlockFloat( settingsBlock, "fadeOutDuration" )


		bool hasEyes      = GetSettingsBlockBool( settingsBlock, "hasEyes" )
		bool fadeAlphaIN  = GetSettingsBlockBool( settingsBlock, "fadeAlphaIN" )
		bool fadeAlphaOUT = GetSettingsBlockBool( settingsBlock, "fadeAlphaOUT" )

		thread AnimWindow_ShadowFormBodyFX_Thread( window.ent, attachIndex, fadeInDuration, fadeOutDuration, fadeAlphaIN, fadeAlphaOUT )

		if ( hasEyes )
		{
			thread AnimWindow_ShadowFormEyeFX_Thread( window.ent, fadeInDuration, fadeOutDuration )
		}


}



void function AnimWindow_ShadowFormBodyFX_Thread( entity ent, int attachIndex, float fadeInDuration, float fadeOutDuration, bool fadeAlphaIN = false, bool fadeAlphaOUT = false )
{
	EndSignal( ent, "OnDestroy" )

	vector transColor   = < 255, 64, 32 >
	vector defaultColor = < 255, 255, 255 >
	int originalSkin    = ent.GetSkin()

	if ( fadeAlphaIN )
		thread PROTO_FadeModelAlphaOverTime( ent, fadeInDuration, 0, 255 )
	else
		thread PROTO_FadeModelIntensityOverTime( ent, fadeInDuration, 1, 0 )

	wait fadeInDuration

	int FX_BODY = StartParticleEffectOnEntity( ent, GetParticleSystemIndex( SHADOW_TRAIL_FX ), FX_PATTACH_POINT_FOLLOW, attachIndex )

	if ( ent.GetSkinIndexByName( "ShadowSqaud" ) != -1 )
		ent.SetSkin( ent.GetSkinIndexByName( "ShadowSqaud" ) )


	WaitSignal( ent, "StopShadowFormFX" )
	

	OnThreadEnd( void function() : ( FX_BODY ) {
		
		if ( EffectDoesExist( FX_BODY ) )
			EffectStop( FX_BODY, false, true )
	} )

	thread PROTO_FadeModelIntensityOverTime( ent, fadeOutDuration, 0, 1 )

	if ( fadeAlphaOUT )
		thread PROTO_FadeModelAlphaOverTime( ent, fadeOutDuration, 255, 0 )


	wait fadeOutDuration
	if ( ent.GetSkinIndexByName( "ShadowSqaud" ) != -1 )
		ent.SetSkin( originalSkin )
	StartParticleEffectOnEntity( ent, GetParticleSystemIndex( SHADOW_DEATH_FX ), FX_PATTACH_POINT_FOLLOW, attachIndex )
}

void function AnimWindow_ShadowFormEyeFX_Thread( entity ent, float fadeInDuration, float fadeOutDuration )
{
	EndSignal( ent, "OnDestroy" )
	

	wait fadeInDuration
	int FX_EYE_L = StartParticleEffectOnEntity( ent, GetParticleSystemIndex( SHADOW_EYE_FX ), FX_PATTACH_POINT_FOLLOW, ent.LookupAttachment( "EYE_L" ) )
	int FX_EYE_R = StartParticleEffectOnEntity( ent, GetParticleSystemIndex( SHADOW_EYE_FX ), FX_PATTACH_POINT_FOLLOW, ent.LookupAttachment( "EYE_R" ) )

	WaitSignal( ent, "StopShadowFormFX" )
	

	wait fadeOutDuration

	OnThreadEnd( void function() : (FX_EYE_L, FX_EYE_R ) {
		
		if ( EffectDoesExist( FX_EYE_L ) )
			EffectStop( FX_EYE_L, false, true )
		if ( EffectDoesExist( FX_EYE_R ) )
			EffectStop( FX_EYE_R, false, true )
	} )
}


void function AnimWindow_ShadowFormFX_Transition( ScriptAnimWindow window, var settingsBlock )
{
	
}


void function AnimWindow_ShadowFormFX_Stop( ScriptAnimWindow window, var settingsBlock )
{

		Signal( window.ent, "StopShadowFormFX" )
		

}






void function AnimWindow_ShadowFormRebornFX_Init()
{
	PrecacheParticleSystem( SHADOWReborn_body_FX )
	PrecacheParticleSystem( SHADOWReborn_EYE_FX )
	PrecacheParticleSystem( SHADOWReborn_activation_FX )
	PrecacheSkinName( "ShadowSquad_reborn_3p" )

		RegisterSignal( "StopShadowFormRebornFX" )

}


void function AnimWindow_ShadowFormRebornFX_Precache( var settingsBlock )
{
	
}


void function AnimWindow_ShadowFormRebornFX_Start( ScriptAnimWindow window, var settingsBlock )
{



		Assert( !window.ent.IsPlayer(), "The \"ShadowFormRebornFX\" script anim window type should not be used on players because it would reset their highlight. Work is required if this is needed." )

		string attachmentName = GetSettingsBlockString( settingsBlock, "attachPoint" )
		int attachIndex       = window.ent.LookupAttachment( attachmentName )

		float fadeInDuration  = GetSettingsBlockFloat( settingsBlock, "fadeInDuration" )
		float fadeOutDuration = GetSettingsBlockFloat( settingsBlock, "fadeOutDuration" )


		bool hasEyes      = GetSettingsBlockBool( settingsBlock, "hasEyes" )
		bool fadeAlphaIN  = GetSettingsBlockBool( settingsBlock, "fadeAlphaIN" )
		bool fadeAlphaOUT = GetSettingsBlockBool( settingsBlock, "fadeAlphaOUT" )

		thread AnimWindow_ShadowFormRebornBodyFX_Thread( window.ent, attachIndex, fadeInDuration, fadeOutDuration, fadeAlphaIN, fadeAlphaOUT )

		if ( hasEyes )
		{
			thread AnimWindow_ShadowFormRebornEyeFX_Thread( window.ent, fadeInDuration, fadeOutDuration )
		}


}



void function AnimWindow_ShadowFormRebornBodyFX_Thread( entity ent, int attachIndex, float fadeInDuration, float fadeOutDuration, bool fadeAlphaIN = false, bool fadeAlphaOUT = false )
{
	EndSignal( ent, "OnDestroy" )

	vector transColor   = < 255, 64, 32 >
	vector defaultColor = < 255, 255, 255 >
	int originalSkin    = ent.GetSkin()

	if ( fadeAlphaIN )
		thread PROTO_FadeModelAlphaOverTime( ent, fadeInDuration, 0, 255 )
	else
		thread PROTO_FadeModelIntensityOverTime( ent, fadeInDuration, 1, 0 )

	wait fadeInDuration

	int FX_BODY = StartParticleEffectOnEntity( ent, GetParticleSystemIndex( SHADOWReborn_body_FX ), FX_PATTACH_POINT_FOLLOW, attachIndex )

	if ( ent.GetSkinIndexByName( "ShadowSquad_reborn_3p" ) != -1 )
		ent.SetSkin( ent.GetSkinIndexByName( "ShadowSquad_reborn_3p" ) )


	WaitSignal( ent, "StopShadowFormRebornFX" )
	

	OnThreadEnd( void function() : ( FX_BODY ) {
		
		if ( EffectDoesExist( FX_BODY ) )
			EffectStop( FX_BODY, false, true )
	} )

	thread PROTO_FadeModelIntensityOverTime( ent, fadeOutDuration, 0, 1 )

	if ( fadeAlphaOUT )
		thread PROTO_FadeModelAlphaOverTime( ent, fadeOutDuration, 255, 0 )


	wait fadeOutDuration
	if ( ent.GetSkinIndexByName( "ShadowSquad_reborn_3p" ) != -1 )
		ent.SetSkin( originalSkin )
	StartParticleEffectOnEntity( ent, GetParticleSystemIndex( SHADOWReborn_activation_FX ), FX_PATTACH_POINT_FOLLOW, attachIndex )
}

void function AnimWindow_ShadowFormRebornEyeFX_Thread( entity ent, float fadeInDuration, float fadeOutDuration )
{
	EndSignal( ent, "OnDestroy" )
	

	wait fadeInDuration
	int FX_EYE_L = StartParticleEffectOnEntity( ent, GetParticleSystemIndex( SHADOWReborn_EYE_FX ), FX_PATTACH_POINT_FOLLOW, ent.LookupAttachment( "EYE_L" ) )
	int FX_EYE_R = StartParticleEffectOnEntity( ent, GetParticleSystemIndex( SHADOWReborn_EYE_FX ), FX_PATTACH_POINT_FOLLOW, ent.LookupAttachment( "EYE_R" ) )

	WaitSignal( ent, "StopShadowFormRebornFX" )
	

	wait fadeOutDuration

	OnThreadEnd( void function() : (FX_EYE_L, FX_EYE_R ) {
		
		if ( EffectDoesExist( FX_EYE_L ) )
			EffectStop( FX_EYE_L, false, true )
		if ( EffectDoesExist( FX_EYE_R ) )
			EffectStop( FX_EYE_R, false, true )
	} )
}


void function AnimWindow_ShadowFormRebornFX_Transition( ScriptAnimWindow window, var settingsBlock )
{
	
}


void function AnimWindow_ShadowFormRebornFX_Stop( ScriptAnimWindow window, var settingsBlock )
{

		Signal( window.ent, "StopShadowFormRebornFX" )
		

}







void function AnimWindow_SetColorModScaleOverDuration_Init()
{

		RegisterSignal( "SetColorModScaleEnd" )

}


void function AnimWindow_SetColorModScaleOverDuration_Start( ScriptAnimWindow window, var settingsBlock )
{

		AnimWindow_SetColorModScaleOverDuration_Transition( window, settingsBlock )

}


void function AnimWindow_SetColorModScaleOverDuration_Transition( ScriptAnimWindow window, var settingsBlock )
{

		float rampUpDuration   = GetSettingsBlockFloat( settingsBlock, "rampUpDuration" )
		float plateauDuration  = GetSettingsBlockFloat( settingsBlock, "plateauDuration" )
		float rampDownDuration = GetSettingsBlockFloat( settingsBlock, "rampDownDuration" )
		bool fromMinToMax = GetSettingsBlockBool( settingsBlock, "rampFromMinToMax" )

		thread SetColorModScaleOverDuration( window.ent, window.endCycle, rampUpDuration, plateauDuration, rampDownDuration, fromMinToMax )

}


void function SetColorModScaleOverDuration( entity ent, float endCycle, float rampUpDuration, float plateauDuration, float rampDownDuration, bool fromMinToMax)
{
	Signal( ent, "SetColorModScaleEnd" )
	EndSignal( ent, "OnDestroy", "SetColorModScaleEnd" )

	float startTime     = Time()
	float totalDuration = rampUpDuration + plateauDuration + rampDownDuration

	float rampUpCompletion   = rampUpDuration
	float plateauCompletion  = rampUpCompletion + plateauDuration
	float rampDownCompletion = plateauCompletion + rampDownDuration

	OnThreadEnd( void function() : ( ent ) {
		if ( IsValid( ent ) )
			ent.SetColorModScaleIntensity( -1.0 )
	} )

	float timeSinceStart = Time() - startTime
	while( IsValid( ent ) && timeSinceStart < totalDuration && ent.GetCycle() <= endCycle )
	{
		timeSinceStart = Time() - startTime
		if ( timeSinceStart < rampUpCompletion )
		{
			
			if( fromMinToMax )
				ent.SetColorModScaleIntensity( Smooth01( (timeSinceStart / rampUpCompletion) ) )
			else
				ent.SetColorModScaleIntensity( Smooth01( 1.0 - (timeSinceStart / rampUpCompletion) ) )
		}
		else if ( timeSinceStart < plateauCompletion )
		{
			
			if( fromMinToMax )
			{
				if ( ent.GetColorModScaleIntensity() != 1.0 )
					ent.SetColorModScaleIntensity( 1.0 )
			}
			else
			{
				if ( ent.GetColorModScaleIntensity() != 0.0 )
					ent.SetColorModScaleIntensity( 0.0 )
			}

		}
		else if ( timeSinceStart < rampDownCompletion )
		{
			
			if( fromMinToMax )
				ent.SetColorModScaleIntensity( Smooth01( 1.0 - (timeSinceStart - plateauCompletion) / rampDownDuration ) )
			else
				ent.SetColorModScaleIntensity( Smooth01( (timeSinceStart - plateauCompletion) / rampDownDuration ) )
		}

		WaitFrame()
	}
}


void function AnimWindow_SetColorModScaleOverDuration_Stop( ScriptAnimWindow window, var settingsBlock )
{

		if ( IsValid( window.ent ) )
			window.ent.Signal( "SetColorModScaleEnd" )

}






void function AnimWindow_MirageHoloFX_Init()
{
	PrecacheParticleSystem( MIRAGE_HOLO_FLASH_FX )
	PrecacheParticleSystem( MIRAGE_HOLO_TRAIL_FX )

		RegisterSignal( "StopMirageHoloFX" )

}


void function AnimWindow_MirageHoloFX_Precache( var settingsBlock )
{
	
}


void function AnimWindow_MirageHoloFX_Start( ScriptAnimWindow window, var settingsBlock )
{



		Assert( !window.ent.IsPlayer(), "The \"MirageHoloFX\" script anim window type should not be used on players because it would reset their highlight. Work is required if this is needed." )

		string attachmentName = GetSettingsBlockString( settingsBlock, "attachPoint" )
		int attachIndex       = window.ent.LookupAttachment( attachmentName )

		float fadeInDuration  = GetSettingsBlockFloat( settingsBlock, "fadeInDuration" )
		float fadeOutDuration = GetSettingsBlockFloat( settingsBlock, "fadeOutDuration" )

		thread AnimWindow_MirageHoloFX_Thread( window.ent, attachIndex, fadeInDuration, fadeOutDuration )

}



void function AnimWindow_MirageHoloFX_Thread( entity ent, int attachIndex, float fadeInDuration, float fadeOutDuration )
{
	EndSignal( ent, "OnDestroy" )

	thread PROTO_FadeModelAlphaOverTime( ent, fadeInDuration, 0, 255 )

	
	StartParticleEffectOnEntity( ent, GetParticleSystemIndex( MIRAGE_HOLO_FLASH_FX ), FX_PATTACH_POINT, attachIndex )

	
	int trailFXHandle = StartParticleEffectOnEntity( ent, GetParticleSystemIndex( MIRAGE_HOLO_TRAIL_FX ), FX_PATTACH_POINT_FOLLOW, attachIndex )

	
	ent.Highlight_ResetFlags()
	ent.Highlight_SetVisibilityType( HIGHLIGHT_VIS_ALWAYS )
	ent.Highlight_SetCurrentContext( GetHighlightId( "decoy_prop" ) )
	ent.Highlight_SetFadeInTime( 0 )
	ent.Highlight_StartOn()

	OnThreadEnd( void function() : ( trailFXHandle ) {
		if ( EffectDoesExist( trailFXHandle ) )
			EffectStop( trailFXHandle, false, true )
	} )

	WaitSignal( ent, "StopMirageHoloFX" )

	if ( EffectDoesExist( trailFXHandle ) )
		EffectStop( trailFXHandle, false, true )


	StartParticleEffectOnEntity( ent, GetParticleSystemIndex( MIRAGE_HOLO_FLASH_FX ), FX_PATTACH_POINT, attachIndex )

	thread PROTO_FadeModelAlphaOverTime( ent, fadeOutDuration, 255, 0 )
}



void function AnimWindow_MirageHoloFX_Transition( ScriptAnimWindow window, var settingsBlock )
{
	
}


void function AnimWindow_MirageHoloFX_Stop( ScriptAnimWindow window, var settingsBlock )
{

		Signal( window.ent, "StopMirageHoloFX" )

}







void function AnimWindow_LifelineDroneCommonFX_Init()
{
	LIFELINE_DRONE_JET_FX_IDX     = PrecacheParticleSystem( LIFELINE_DRONE_JET_FX )
	LIFELINE_DRONE_VENT_FX_IDX    = PrecacheParticleSystem( LIFELINE_DRONE_VENT_FX )
	LIFELINE_DRONE_EYEGLOW_FX_IDX = PrecacheParticleSystem( LIFELINE_DRONE_EYEGLOW_FX )

		RegisterSignal( "StopLifelineDroneCommonFX" )

}


void function AnimWindow_LifelineDroneCommonFX_Precache( var settingsBlock )
{
	
}


void function AnimWindow_LifelineDroneCommonFX_Start( ScriptAnimWindow window, var settingsBlock )
{



		thread AnimWindow_LifelineDroneCommonFX_Thread( window.ent )

}



void function AnimWindow_LifelineDroneCommonFX_Thread( entity ent )
{
	EndSignal( ent, "OnDestroy" )

	array<int> fxToCleanUp = []

	fxToCleanUp.append( StartParticleEffectOnEntity( ent, LIFELINE_DRONE_JET_FX_IDX, FX_PATTACH_POINT_FOLLOW, ent.LookupAttachment( "vent_LF" ) ) )
	fxToCleanUp.append( StartParticleEffectOnEntity( ent, LIFELINE_DRONE_JET_FX_IDX, FX_PATTACH_POINT_FOLLOW, ent.LookupAttachment( "vent_LR" ) ) )
	fxToCleanUp.append( StartParticleEffectOnEntity( ent, LIFELINE_DRONE_JET_FX_IDX, FX_PATTACH_POINT_FOLLOW, ent.LookupAttachment( "vent_RR" ) ) )
	fxToCleanUp.append( StartParticleEffectOnEntity( ent, LIFELINE_DRONE_JET_FX_IDX, FX_PATTACH_POINT_FOLLOW, ent.LookupAttachment( "vent_RF" ) ) )

	fxToCleanUp.append( StartParticleEffectOnEntity( ent, LIFELINE_DRONE_VENT_FX_IDX, FX_PATTACH_POINT_FOLLOW, ent.LookupAttachment( "vent_bot" ) ) )

	fxToCleanUp.append( StartParticleEffectOnEntity( ent, LIFELINE_DRONE_EYEGLOW_FX_IDX, FX_PATTACH_POINT_FOLLOW, ent.LookupAttachment( "EYEGLOW" ) ) )

	if ( SERVER || (CLIENT && ent.IsClientOnly()) )
		ent.SetSkin( LIFELINE_DRONE_ONLINE_SKIN )

	OnThreadEnd( void function() : ( ent, fxToCleanUp ) {
		foreach ( int fxHandle in fxToCleanUp )
		{
			if ( EffectDoesExist( fxHandle ) )
				EffectStop( fxHandle, true, true )
		}

		if ( IsValid( ent ) && (SERVER || (CLIENT && ent.IsClientOnly())) )
			ent.SetSkin( LIFELINE_DRONE_OFFLINE_SKIN )
	} )

	WaitSignal( ent, "StopLifelineDroneCommonFX" )
}



void function AnimWindow_LifelineDroneCommonFX_Transition( ScriptAnimWindow window, var settingsBlock )
{
	
}


void function AnimWindow_LifelineDroneCommonFX_Stop( ScriptAnimWindow window, var settingsBlock )
{

		Signal( window.ent, "StopLifelineDroneCommonFX" )

}








const string BLOODHOUND_WHITE_RAVEN_SKIN = "bloodhound_epicp_v21_aether"
void function AnimWindow_SetBloodhoundRavenPropSkin( ScriptAnimWindow window, var settingsBlock, entity prop )
{
	if ( IsValid( prop ) )
	{
		entity player            = window.ent
		ItemFlavor character     = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_Character() )
		ItemFlavor skin          = LoadoutSlot_GetItemFlavor( ToEHI( player ), Loadout_CharacterSkin( character ) )

		if ( IsLobby() )
		{
			ItemFlavor ornull previewSkin = clGlobal.previewMenuPilotModels.characterSkin
			if ( previewSkin != null )
			{
				expect ItemFlavor( previewSkin )
				skin = previewSkin
			}
		}

		string characterSkinName = CharacterSkin_GetSkinName( skin )
		

		if ( prop.GetModelName() == BLOODHOUND_BIRD_MDL && characterSkinName == BLOODHOUND_WHITE_RAVEN_SKIN )
		{
			prop.SetSkin ( 2 )
		}
	}
}








void function AnimWindow_SetRevenantShadowPropSkin( ScriptAnimWindow window, var settingsBlock, entity prop )
{
	if ( IsValid( prop ) )
	{
		Assert( prop.GetSkinIndexByName( "ShadowSqaud" ) != -1, "Tried to apply revenant shadow skin through an anim window, but the model doesn't have the ShadowSqaud(sp) skin." )
		prop.SetSkin( prop.GetSkinIndexByName( "ShadowSqaud" ) )
	}
}


void function AnimWindow_MatchMeleePropSkin( ScriptAnimWindow window, var settingsBlock, entity prop )
{
	if ( !IsValid( prop ) )
		return

	entity parentEnt = window.ent

	if ( !IsValid( parentEnt ) )
		return

	string meleeSkinName = ""

	if ( !parentEnt.IsPlayer() )
	{
		entity proxyOwner = parentEnt.GetOwner()
		if ( IsValid( proxyOwner ) && proxyOwner.IsPlayer() )
		{
			parentEnt = proxyOwner
		}
	}

	if ( parentEnt.IsPlayer() )
	{
		meleeSkinName = MeleeSkin_GetSkinNameFromPlayer( parentEnt )
		printt( "Execution uses player melee skin: " + meleeSkinName )
	}
	else 
	{
		ItemFlavor ornull meleeSkinFlavor = parentEnt.e.animWindowMeleeSkinItemFlavor

		if ( meleeSkinFlavor != null )
		{
			expect ItemFlavor( meleeSkinFlavor )
			meleeSkinName = MeleeSkin_GetSkinName( meleeSkinFlavor )
			printt( "Glad card uses melee skin: " + meleeSkinName )
		}
	}

	if ( meleeSkinName != "" && meleeSkinName != "default" )
	{
		int skindex = prop.GetSkinIndexByName( meleeSkinName )
		printt( "Setting prop melee skin to " + meleeSkinName + " :: " + skindex )
		if ( skindex != -1 )
			prop.SetSkin( skindex )
	}
}

void function AnimWindow_SetSmearPropColour( ScriptAnimWindow window, var settingsBlock, entity prop )
{
	printt( "setting colour for artifact prop smear" )

	entity owner = window.ent
	if( !IsValid( owner ) )
		return

	if ( owner.IsPlayerDecoy() )
		owner = owner.GetBossPlayer()

	if ( IsValid( owner ) && owner.IsPlayer() )
	{
		if ( owner == GetLocalClientPlayer() && owner.p.artifactConfig == null ) 
			Artifacts_StoreLoadoutDataOnPlayerEntityStruct( owner, null, false )

		if ( owner.p.artifactConfig == null )
			return

		ArtifactConfig artifactConfig = expect ArtifactConfig( owner.p.artifactConfig )

		prop.kv.rendercolor = Artifacts_FX_GetEmissiveAndSmearColor( artifactConfig.powerSource, false )
	}
}








void function AnimWindow_HideWeapon3P_Init()
{
	
}


void function AnimWindow_HideWeapon3P_Precache( var settingsBlock )
{
	
}


void function AnimWindow_HideWeapon3P_Start( ScriptAnimWindow window, var settingsBlock )
{



		if ( window.ent.IsPlayer() || window.ent.IsNPC() )
			window.ent.Set3PWeaponClonesVisibility( false )
		else
			Warning( "HideWeapon anim windows are only valid for players and NPCs. Trying to create window %s for entity %s.", string(window.settingsAsset), string(window.ent) )

}


void function AnimWindow_HideWeapon3P_Transition( ScriptAnimWindow window, var settingsBlock )
{
	
}


void function AnimWindow_HideWeapon3P_Stop( ScriptAnimWindow window, var settingsBlock )
{

		if ( window.ent.IsPlayer() || window.ent.IsNPC() )
			window.ent.Set3PWeaponClonesVisibility( true )
		else
			Warning( "HideWeapon anim windows are only valid for players and NPCs. Trying to create window %s for entity %s.", string(window.settingsAsset), string(window.ent) )

}








void function AnimWindow_OverrideCharacterSelectCamera_Init()
{
}


void function AnimWindow_OverrideCharacterSelectCamera_Precache( var settingsBlock )
{
}


void function AnimWindow_OverrideCharacterSelectCamera_Start( ScriptAnimWindow window, var settingsBlock )
{



		OverrideCharacterSelectCamera( window.ent )

}


void function AnimWindow_OverrideCharacterSelectCamera_Transition( ScriptAnimWindow window, var settingsBlock )
{
}


void function AnimWindow_OverrideCharacterSelectCamera_Stop( ScriptAnimWindow window, var settingsBlock )
{

		RestoreCharacterSelectCamera()

}








void function AnimWindow_DisableGunTargetingLaser_Start( entity ent , string params )
{
	ViewModel_GetWeapon( ent ).SetClientTargetingLaserVisible( false )
}

void function AnimWindow_DisableGunTargetingLaser_Stop( entity ent , string params )
{
	if ( !IsValid( ent ) )
		return

	entity weapon = ViewModel_GetWeapon( ent )

	if ( !IsValid( weapon ) )
		return

	weapon.SetClientTargetingLaserVisible( true )
}







struct AnimWindowTypeInfo
{
	bool isForThisVM

	void functionref( var )                   precacheFunc
	bool functionref( var )                   streamFunc
	void functionref( ScriptAnimWindow, var ) startFunc
	void functionref( ScriptAnimWindow, var ) transitionFunc
	void functionref( ScriptAnimWindow, var ) stopFunc
}

struct
{
	table<string, AnimWindowTypeInfo> animWindowTypeNameInfoMap
} fileLevel


void function RegisterAnimWindowType( bool isForThisVM, string type,
		void functionref() initFunc, 
		void functionref( var ) precacheFunc, 
		bool functionref( var ) streamFunc,
		void functionref(ScriptAnimWindow, var ) startFunc,
		void functionref( ScriptAnimWindow, var ) transitionFunc, 
		void functionref(ScriptAnimWindow, var ) stopFunc )
{
	Assert( !(type in fileLevel.animWindowTypeNameInfoMap) )
	Assert( startFunc != null )
	AnimWindowTypeInfo awti
	awti.isForThisVM    = isForThisVM
	awti.precacheFunc   = precacheFunc
	awti.streamFunc		= streamFunc
	awti.startFunc      = startFunc
	awti.transitionFunc = transitionFunc
	awti.stopFunc       = stopFunc
#if DEV
		disableoverwrite( fileLevel.animWindowTypeNameInfoMap )
#endif
	fileLevel.animWindowTypeNameInfoMap[type] <- awti

	if ( initFunc != null )
		initFunc()
}























bool function ClientCodeCallback_AnimWindowStream( asset windowSettingsAsset )
{
	var block = GetSettingsBlockForAsset( windowSettingsAsset )

	string windowType = GetSettingsBlockString( block, "type" )
	Assert( windowType in fileLevel.animWindowTypeNameInfoMap, "Unknown script anim window type on \"" + string(windowSettingsAsset) + "\": " + windowType )

	AnimWindowTypeInfo awti = fileLevel.animWindowTypeNameInfoMap[windowType]
	if ( awti.streamFunc != null )
		return awti.streamFunc( block )

	return true
}

void function ClientCodeCallback_AnimWindowStart( ScriptAnimWindow window )
{
	Assert( IsValid( window.ent ) )

	var block = GetSettingsBlockForAsset( window.settingsAsset )

	string windowType = GetSettingsBlockString( block, "type" )
	Assert( windowType in fileLevel.animWindowTypeNameInfoMap, "Unknown script anim window type on animseq \"" + window.ent.GetCurrentSequenceName() + "\": " + windowType )

#if SCRIPT_ANIM_WINDOWS_DEBUG
		printt ( "><><><><><><>" + FUNC_NAME() + ": id : " + window.stringID + "; type: " + windowType + "; name: " + window.windowName + "; startCycle: " + window.startCycle + "><><><><><><><><><><" )
#endif

	AnimWindowTypeInfo awti = fileLevel.animWindowTypeNameInfoMap[windowType]
	Assert( awti.isForThisVM, "Script anim window \"" + window.windowName + "\" on animseq \"" + window.ent.GetCurrentSequenceName() + "\" is marked as " + (SERVER ? "SERVER" : "CLIENT") + " but its type (\"" + windowType + "\") is " + (SERVER ? "CLIENT" : "SERVER") + " only." )
	awti.startFunc( window, block )
}




void function ClientCodeCallback_AnimWindowTransition( ScriptAnimWindow window )
{
	Assert( IsValid( window.ent ) )

	var block = GetSettingsBlockForAsset( window.settingsAsset )

	string windowType = GetSettingsBlockString( block, "type" )
	Assert( windowType in fileLevel.animWindowTypeNameInfoMap, "Unknown script anim window type on animseq \"" + window.ent.GetCurrentSequenceName() + "\": " + windowType )

#if SCRIPT_ANIM_WINDOWS_DEBUG
		printt ( "><><><><><><>" + FUNC_NAME() + ": id : " + window.stringID + "; type: " + windowType + "; name: " + window.windowName )
#endif

	AnimWindowTypeInfo awti = fileLevel.animWindowTypeNameInfoMap[windowType]
	Assert( awti.isForThisVM, "Script anim window \"" + window.windowName + "\" on animseq \"" + window.ent.GetCurrentSequenceName() + "\" is marked as " + (SERVER ? "SERVER" : "CLIENT") + " but its type (\"" + windowType + "\") is " + (SERVER ? "CLIENT" : "SERVER") + " only." )
	if ( awti.transitionFunc == null )
		return

	awti.transitionFunc( window, block )
}




void function ClientCodeCallback_AnimWindowStop( ScriptAnimWindow window )
{
	Assert( IsValid( window.ent ) )

	var block = GetSettingsBlockForAsset( window.settingsAsset )

	string windowType = GetSettingsBlockString( block, "type" )
	Assert( windowType in fileLevel.animWindowTypeNameInfoMap, "Unknown script anim window type on animseq \"" + window.ent.GetCurrentSequenceName() + "\": " + windowType )

#if SCRIPT_ANIM_WINDOWS_DEBUG
		printt ( "><><><><><><>" + FUNC_NAME() + ": id : " + window.stringID + "; type: " + windowType + "; name: " + window.windowName )
#endif

	AnimWindowTypeInfo awti = fileLevel.animWindowTypeNameInfoMap[windowType]
	Assert( awti.isForThisVM, "Script anim window \"" + window.windowName + "\" on animseq \"" + window.ent.GetCurrentSequenceName() + "\" is marked as " + (SERVER ? "SERVER" : "CLIENT") + " but its type (\"" + windowType + "\") is " + (SERVER ? "CLIENT" : "SERVER") + " only." )
	if ( awti.stopFunc == null )
		return

	awti.stopFunc( window, block )
}





void function ShowEntityAndChildren( entity ent )
{
	ent.Show()

	foreach ( entity hierarchyEnt in GetEntityAndImmediateChildren( ent ) )
		hierarchyEnt.Show()
}

void function HideEntityAndChildren( entity ent )
{
	ent.Hide()

	foreach ( entity hierarchyEnt in GetEntityAndImmediateChildren( ent ) )
		hierarchyEnt.Hide()
}



